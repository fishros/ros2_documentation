<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tutorials/Demos/Intra-Process-Communication</title>
</head>
<body>
  <div class="section" id="setting-up-efficient-intra-process-communication">
<h1>设置高效的进程内通信 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5035">[5035]</a><a class="headerlink" href="#setting-up-efficient-intra-process-communication" title="永久链接至标题"></a></h1>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title">目录 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3070">[]</a></p>
<ul class="simple">
<li><p><a class="reference internal" href="#background" id="id1">背景 [3072]</a></p></li>
<li><p><a class="reference internal" href="#installing-the-demos" id="id2">安装演示 [5038]</a></p></li>
<li><p><a class="reference internal" href="#running-and-understanding-the-demos" id="id3">运行和理解演示 [5040]</a></p></li>
</ul>
</div>
<div class="section" id="background">
<h2>背景 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3072">[3072]</a><a class="headerlink" href="#background" title="永久链接至标题"></a></h2>
<p>ROS应用程序通常由一系列独立的“节点”组成，每个节点执行特定的任务，并与系统的其他部分解耦。这促进了故障隔离、更快的开发、模块化和代码重用，但通常会以性能为代价。在最初开发ROS 1后，人们意识到需要有效地组合节点，并因此开发了Nodelets。在ROS 2中，我们旨在改进Nodelets的设计，解决一些需要对节点进行重组的根本性问题。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5036">[5036]</a></p>
<p>在这个演示中，我们将重点介绍如何手动组合节点，通过分别定义节点，但在不更改节点的代码或限制其功能的情况下，将它们组合在不同的进程布局中。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5037">[5037]</a></p>
</div>
<div class="section" id="installing-the-demos">
<h2>安装演示 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5038">[5038]</a><a class="headerlink" href="#installing-the-demos" title="永久链接至标题"></a></h2>
<p>详细了解安装ROS 2的方法，请参阅:doc:<a class="reference internal" href="../../Installation.html"><span class="doc">安装说明</span></a>。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5016">[5016]</a></p>
<p>如果你是通过包安装ROS 2，请确保已安装``ros-humble-intra-process-demo``。如果你从存档文件下载或从源代码构建ROS 2，它已经包含在安装中。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5039">[5039]</a></p>
</div>
<div class="section" id="running-and-understanding-the-demos">
<h2>运行和理解演示 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5040">[5040]</a><a class="headerlink" href="#running-and-understanding-the-demos" title="永久链接至标题"></a></h2>
<p>有几个不同的演示：其中一些是玩具问题，旨在突出显示进程内通信功能的特点，另一些是端到端示例，使用OpenCV，并演示了将节点重新组合成不同配置的能力。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5041">[5041]</a></p>
<div class="section" id="the-two-node-pipeline-demo">
<h3>两个节点管道演示 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5042">[5042]</a><a class="headerlink" href="#the-two-node-pipeline-demo" title="永久链接至标题"></a></h3>
<p>此演示旨在展示进程内发布/订阅连接在使用``std::unique_ptr``进行发布和订阅时可以实现零拷贝传输。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5043">[5043]</a></p>
<p>首先，让我们来看一下源代码: <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5044">[5044]</a></p>
<p><a class="reference external" href="https://github.com/ros2/demos/blob/humble/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp">https://github.com/ros2/demos/blob/humble/intra_process_demo/src/two_node_pipeline/two_node_pipeline.cpp</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5045">[5045]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cinttypes&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;rclcpp/rclcpp.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;std_msgs/msg/int32.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="o">::</span><span class="nn">chrono_literals</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Node that produces messages.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Producer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Producer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">NodeOptions</span><span class="p">().</span><span class="n">use_intra_process_comms</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a publisher on the output topic.</span>
<span class="w">    </span><span class="n">pub_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_pointer</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">pub_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">captured_pub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pub_</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a timer which publishes on the output topic at ~1Hz.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">captured_pub</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">pub_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">captured_pub</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pub_ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">::</span><span class="n">UniquePtr</span><span class="w"> </span><span class="nf">msg</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="s">&quot;Published message with value: %d, and address: 0x%&quot;</span><span class="w"> </span><span class="n">PRIXPTR</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="n">pub_ptr</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span><span class="w"></span>
<span class="w">      </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">timer_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">create_wall_timer</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">pub_</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">TimerBase</span><span class="o">::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">timer_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Node that consumes messages.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Consumer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Consumer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">NodeOptions</span><span class="p">().</span><span class="n">use_intra_process_comms</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a subscription on the input topic which prints on receipt of new messages.</span>
<span class="w">    </span><span class="n">sub_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">create_subscription</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">input</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">[](</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">::</span><span class="n">UniquePtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="s">&quot; Received message with value: %d, and address: 0x%&quot;</span><span class="w"> </span><span class="n">PRIXPTR</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span><span class="w"></span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Subscription</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">sub_</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">_IONBF</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">executors</span><span class="o">::</span><span class="n">SingleThreadedExecutor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">producer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Producer</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;producer&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;number&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">consumer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Consumer</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;consumer&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;number&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">spin</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">shutdown</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>通过查看 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数，您可以看到我们有一个生产者节点和一个消费者节点，我们将它们添加到一个单线程执行器中，然后调用 spin 函数。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5046">[5046]</a></p>
<p>如果您查看 <code class="docutils literal notranslate"><span class="pre">Producer</span></code> 结构体中的“生产者”节点实现，您会发现我们创建了一个在“number”主题上发布消息的发布者和一个定时器，该定时器周期性地创建一个新的消息，打印出它在内存中的地址和其内容的值，然后将其发布出去。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5047">[5047]</a></p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>consumer``节点相对简单，可以在``Consumer``结构体中看到其实现，它只订阅&quot;number&quot;主题，并打印出接收到的消息的地址和值。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5048">[5048]</a></p>
<p>预期结果是生产者将打印出地址和值，而消费者将打印出匹配的地址和值。这证明了进程内通信确实起作用，并且至少对于简单的图形，避免了不必要的复制。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5049">[5049]</a></p>
<p>让我们通过执行``ros2 run intra_process_demo two_node_pipeline``可执行文件来运行演示（不要忘记先执行设置文件）： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5050">[5050]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ros2 run intra_process_demo two_node_pipeline
Published message with value: <span class="m">0</span>, and address: 0x7fb02303faf0
Published message with value: <span class="m">1</span>, and address: 0x7fb020cf0520
 Received message with value: <span class="m">1</span>, and address: 0x7fb020cf0520
Published message with value: <span class="m">2</span>, and address: 0x7fb020e12900
 Received message with value: <span class="m">2</span>, and address: 0x7fb020e12900
Published message with value: <span class="m">3</span>, and address: 0x7fb020cf0520
 Received message with value: <span class="m">3</span>, and address: 0x7fb020cf0520
Published message with value: <span class="m">4</span>, and address: 0x7fb020e12900
 Received message with value: <span class="m">4</span>, and address: 0x7fb020e12900
Published message with value: <span class="m">5</span>, and address: 0x7fb02303cea0
 Received message with value: <span class="m">5</span>, and address: 0x7fb02303cea0
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>你会注意到一件事，消息大约每秒钟传递一次。这是因为我们告诉定时器大约每秒触发一次。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5051">[5051]</a></p>
<p>你可能已经注意到第一条消息（值为``0``）没有对应的&quot;Received message ...&quot;行。这是因为发布/订阅是&quot;尽力而为&quot;的，我们没有启用任何&quot;锁存&quot;行为。这意味着如果发布者在建立订阅之前发布一条消息，订阅将不会接收到该消息。这种竞争条件可能导致前几条消息丢失。在这种情况下，由于它们每秒只出现一次，通常只会丢失第一条消息。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5052">[5052]</a></p>
<p>最后，你可以看到具有相同值的&quot;Published message...&quot;和&quot;Received message ...&quot;行也具有相同的地址。这表明接收到的消息的地址与发布的消息相同，并且它不是一个副本。这是因为我们使用``std::unique_ptr``进行发布和订阅，它允许消息的所有权在系统中安全地移动。你也可以使用``const &amp;``和``std::shared_ptr``进行发布和订阅，但在这种情况下不会进行零拷贝。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5053">[5053]</a></p>
</div>
<div class="section" id="the-cyclic-pipeline-demo">
<h3>循环管道示例 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5054">[5054]</a><a class="headerlink" href="#the-cyclic-pipeline-demo" title="永久链接至标题"></a></h3>
<p>这个示例与之前的示例类似，但是不同的是，生产者在每次迭代中不会创建新的消息，而是始终使用同一个消息实例。通过在图中创建一个循环，并在旋转执行器之前通过外部方式使其中一个节点发布消息，可以实现这一点： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5055">[5055]</a></p>
<p><a class="reference external" href="https://github.com/ros2/demos/blob/humble/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp">https://github.com/ros2/demos/blob/humble/intra_process_demo/src/cyclic_pipeline/cyclic_pipeline.cpp</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5056">[5056]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cinttypes&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;rclcpp/rclcpp.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;std_msgs/msg/int32.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="o">::</span><span class="nn">chrono_literals</span><span class="p">;</span><span class="w"></span>

<span class="c1">// This node receives an Int32, waits 1 second, then increments and sends it.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">IncrementerPipe</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">IncrementerPipe</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">out</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">NodeOptions</span><span class="p">().</span><span class="n">use_intra_process_comms</span><span class="p">(</span><span class="nb">true</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a publisher on the output topic.</span>
<span class="w">    </span><span class="n">pub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_pointer</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">pub</span><span class="p">.</span><span class="n">get</span><span class="p">())</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">captured_pub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pub</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Create a subscription on the input topic.</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">create_subscription</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">in</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="mi">10</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="n">captured_pub</span><span class="p">](</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">::</span><span class="n">UniquePtr</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">pub_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">captured_pub</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pub_ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="s">&quot;Received message with value:         %d, and address: 0x%&quot;</span><span class="w"> </span><span class="n">PRIXPTR</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  sleeping for 1 second...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rclcpp</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="p">;</span><span class="w">    </span><span class="c1">// Return if the sleep failed (e.g. on :kbd:`ctrl-c`).</span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;  done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">++</span><span class="p">;</span><span class="w">    </span><span class="c1">// Increment the message&#39;s data.</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="s">&quot;Incrementing and sending with value: %d, and address: 0x%&quot;</span><span class="w"> </span><span class="n">PRIXPTR</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span><span class="w"></span>
<span class="w">        </span><span class="n">pub_ptr</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span><span class="w">    </span><span class="c1">// Send the message along to the output topic.</span>
<span class="w">      </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">pub</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Subscription</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;::</span><span class="n">SharedPtr</span><span class="w"> </span><span class="n">sub</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">_IONBF</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">executors</span><span class="o">::</span><span class="n">SingleThreadedExecutor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create a simple loop by connecting the in and out topics of two IncrementerPipe&#39;s.</span>
<span class="w">  </span><span class="c1">// The expectation is that the address of the message being passed between them never changes.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">pipe1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">IncrementerPipe</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;pipe1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;topic1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;topic2&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">pipe2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">IncrementerPipe</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;pipe2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;topic1&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mi">1</span><span class="n">s</span><span class="p">);</span><span class="w">  </span><span class="c1">// Wait for subscriptions to be established to avoid race conditions.</span>
<span class="w">  </span><span class="c1">// Publish the first message (kicking off the cycle).</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="o">&gt;</span><span class="w"> </span><span class="n">msg</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">Int32</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;Published first message with value:  %d, and address: 0x%&quot;</span><span class="w"> </span><span class="n">PRIXPTR</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span><span class="w"></span>
<span class="w">  </span><span class="n">pipe1</span><span class="o">-&gt;</span><span class="n">pub</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">pipe1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">pipe2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">spin</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">shutdown</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>与之前的演示不同，此演示只使用一个节点，使用不同的名称和配置实例化两次。图的结构为“pipe1” -&gt; “pipe2” -&gt; “pipe1”... 形成循环。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5057">[5057]</a></p>
<p>代码行“pipe1-&gt;pub-&gt;publish(msg);”启动了该过程，但之后消息通过每个节点在自己的订阅回调中调用publish来来回传递。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5058">[5058]</a></p>
<p>这里的期望是节点之间每秒传递消息一次，每次递增消息的值。由于消息作为“unique_ptr”发布和订阅，开始时创建的同一消息会不断使用。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5059">[5059]</a></p>
<p>为了测试这些期望，让我们运行它： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5060">[5060]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ros2 run intra_process_demo cyclic_pipeline
Published first message with value:  <span class="m">42</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">42</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
  <span class="k">done</span>.
Incrementing and sending with value: <span class="m">43</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">43</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
  <span class="k">done</span>.
Incrementing and sending with value: <span class="m">44</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">44</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
  <span class="k">done</span>.
Incrementing and sending with value: <span class="m">45</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">45</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
  <span class="k">done</span>.
Incrementing and sending with value: <span class="m">46</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">46</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
  <span class="k">done</span>.
Incrementing and sending with value: <span class="m">47</span>, and address: 0x7fd2ce0a2bc0
Received message with value:         <span class="m">47</span>, and address: 0x7fd2ce0a2bc0
  sleeping <span class="k">for</span> <span class="m">1</span> second...
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
<p>你应该在每次迭代中看到不断增加的数字，从42开始...因为42，而且整个时间它重复使用相同的消息，如指针地址所示，它们不会改变，这避免了不必要的拷贝。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5061">[5061]</a></p>
</div>
<div class="section" id="the-image-pipeline-demo">
<h3>图像处理演示 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5062">[5062]</a><a class="headerlink" href="#the-image-pipeline-demo" title="永久链接至标题"></a></h3>
<p>在这个演示中，我们将使用OpenCV来捕获、注释和查看图像。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5063">[5063]</a></p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>如果您使用的是 macOS，而这些示例不起作用，或者您收到类似 <code class="docutils literal notranslate"><span class="pre">ddsi_conn_write</span> <span class="pre">failed</span> <span class="pre">-1</span></code> 的错误，那么您需要增加系统范围内的 UDP 数据包大小： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5064">[5064]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo sysctl -w net.inet.udp.recvspace<span class="o">=</span><span class="m">209715</span>
$ sudo sysctl -w net.inet.udp.maxdgram<span class="o">=</span><span class="m">65500</span>
</pre></div>
</div>
<p>这些更改在重启后将不会保留。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5065">[5065]</a></p>
</div>
<div class="section" id="simple-pipeline">
<h4>简单的流水线 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5066">[5066]</a><a class="headerlink" href="#simple-pipeline" title="永久链接至标题"></a></h4>
<p>首先，我们将有一个由三个节点组成的流水线，安排如下：<code class="docutils literal notranslate"><span class="pre">camera_node</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">watermark_node</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">image_view_node</span></code> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5067">[5067]</a></p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>camera_node``从计算机上的相机设备``0``读取数据，并在图像上写入一些信息后进行发布。<a href="#id3"><span class="problematic" id="id4">``</span></a>watermark_node``订阅``camera_node``的输出，并在发布之前添加更多的文本。最后，<a href="#id5"><span class="problematic" id="id6">``</span></a>image_view_node``订阅``watermark_node``的输出，向图像中添加更多的文本，并使用``cv::imshow``进行可视化。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5068">[5068]</a></p>
<p>在每个节点中，发送或接收到的消息的地址都写入图像中。水印节点和图像查看节点设计为在不复制图像的情况下修改图像，因此只要节点在同一进程中，并且图形以上述流水线的方式保持组织，图像上印刻的地址应该都是相同的。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5069">[5069]</a></p>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>在某些系统上（我们在Linux上遇到过这种情况），打印到屏幕上的地址可能不会改变。这是因为正在重复使用相同的唯一指针。在这种情况下，流水线仍在运行。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5070">[5070]</a></p>
</div>
<p>通过执行以下可执行文件来运行演示： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5071">[5071]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ros2 run intra_process_demo image_pipeline_all_in_one
</pre></div>
</div>
<p>你应该看到类似这样的内容： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5072">[5072]</a></p>
<img alt="../../_images/intra-process-demo-pipeline-single-window.png" src="../../_images/intra-process-demo-pipeline-single-window.png" />
<p>你可以通过按下空格键暂停图像的渲染，再次按下空格键可以恢复。你还可以按下 <code class="docutils literal notranslate"><span class="pre">q</span></code> 或 <code class="docutils literal notranslate"><span class="pre">ESC</span></code> 键退出。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5073">[5073]</a></p>
<p>如果你暂停了图像查看器，你应该能够比较图像上的地址，并看到它们是相同的。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5074">[5074]</a></p>
</div>
<div class="section" id="pipeline-with-two-image-viewers">
<h4>带有两个图像查看器的流水线 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5075">[5075]</a><a class="headerlink" href="#pipeline-with-two-image-viewers" title="永久链接至标题"></a></h4>
<p>现在让我们看一个与上面相似的示例，只是这次有两个图像视图节点。所有节点仍然在同一个进程中，但现在应该会出现两个图像视图窗口。（注意 macOS 用户：你的图像视图窗口可能会重叠在一起）。让我们用以下命令运行它： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5076">[5076]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ros2 run intra_process_demo image_pipeline_with_two_image_view
</pre></div>
</div>
<img alt="../../_images/intra-process-demo-pipeline-two-windows-copy.png" src="../../_images/intra-process-demo-pipeline-two-windows-copy.png" />
<p>与上一个示例一样，你可以使用空格键暂停渲染，再次按下空格键继续。你可以停止更新以检查写入屏幕的指针。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5077">[5077]</a></p>
<p>如上面的示例图所示，我们有一个图像，其中所有指针都相同，然后另一个图像的前两个条目与第一个图像的指针相同，但第二个图像的最后一个指针不同。要理解为什么会发生这种情况，请考虑图的拓扑结构： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5078">[5078]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>camera_node -&gt; watermark_node -&gt; image_view_node
                              -&gt; image_view_node2
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">camera_node</span></code> 和 <code class="docutils literal notranslate"><span class="pre">watermark_node</span></code> 之间的链接可以使用相同的指针而不进行复制，因为只有一个进程内的订阅应将消息传递给该指针。但是，对于 <code class="docutils literal notranslate"><span class="pre">watermark_node</span></code> 和两个图像视图节点之间的链接，关系是一对多的，因此，如果图像视图节点使用 <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> 回调，那么将不可能将同一指针的所有权分别传递给它们。然而，它可以被传递给其中一个。哪个节点会获得原始指针并没有定义，而是简单地取决于最后被传递的节点。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5079">[5079]</a></p>
<p>注意，图像视图节点没有使用``unique_ptr``回调函数进行订阅，而是使用``const shared_ptr``进行订阅。这意味着系统将向两个回调函数提供相同的``shared_ptr``。在处理第一个进程内订阅时，内部存储的``unique_ptr``将被提升为``shared_ptr``。每个回调函数将共享同一消息的所有权。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5080">[5080]</a></p>
</div>
<div class="section" id="pipeline-with-interprocess-viewer">
<h4>具有进程间查看器的流水线 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5081">[5081]</a><a class="headerlink" href="#pipeline-with-interprocess-viewer" title="永久链接至标题"></a></h4>
<p>还有一件重要的事情需要注意，即在进行进程间订阅时，避免中断进程内的零拷贝行为。为了测试这一点，我们可以运行第一个图像流水线演示程序``image_pipeline_all_in_one``，然后运行一个独立的``image_view_node``实例（不要忘记在终端中加上``ros2 run intra_process_demo``前缀）。大致如下所示： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5082">[5082]</a></p>
<img alt="../../_images/intra-process-demo-pipeline-inter-process.png" src="../../_images/intra-process-demo-pipeline-inter-process.png" />
<p>很难同时暂停两个图像，因此图像可能不会对齐，但需要注意的重要事项是，<a href="#id1"><span class="problematic" id="id2">``</span></a>image_pipeline_all_in_one``图像视图显示了每个步骤的相同地址。这意味着即使订阅了外部视图，进程内的零拷贝仍然得到保留。您还可以看到进程间图像视图在文本的前两行具有不同的进程 ID，并且独立图像查看器的进程 ID 在第三行文本中。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=5083">[5083]</a></p>
</div>
</div>
</div>
</div>

  <div id="footer">
    <p>欢迎帮助改进！</p>
  </div>
</body>
</html>