<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tutorials/Advanced/Allocator-Template-Tutorial</title>
</head>
<body>
  <div class="section" id="implementing-a-custom-memory-allocator">
<h1>实现自定义内存分配器 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3066">[3066]</a><a class="headerlink" href="#implementing-a-custom-memory-allocator" title="永久链接至标题"></a></h1>
<p><strong>目标：</strong> 本教程将展示如何在编写 ROS 2 C++ 代码时使用自定义内存分配器。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3067">[3067]</a></p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>教程级别：<a href="#id3"><span class="problematic" id="id4">**</span></a>高级 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3068">[3068]</a></p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>时间：<a href="#id3"><span class="problematic" id="id4">**</span></a>20分钟 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3069">[3069]</a></p>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title">目录 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3070">[]</a></p>
<ul class="simple">
<li><p><a class="reference internal" href="#background" id="id1">背景 [3072]</a></p></li>
<li><p><a class="reference internal" href="#writing-an-allocator" id="id2">编写一个分配器 [3076]</a></p></li>
<li><p><a class="reference internal" href="#writing-an-example-main" id="id3">编写一个示例主函数 [3083]</a></p></li>
<li><p><a class="reference internal" href="#passing-an-allocator-to-the-intra-process-pipeline" id="id4">将分配器传递给进程内管道 [3087]</a></p></li>
<li><p><a class="reference internal" href="#testing-and-verifying-the-code" id="id5">对代码进行测试和验证。 [3091]</a></p></li>
<li><p><a class="reference internal" href="#the-tlsf-allocator" id="id6">TLSF 分配器 [3105]</a></p></li>
</ul>
</div>
<p>本教程将教你如何为发布者和订阅者集成自定义分配器，以便在你的ROS节点执行时永远不会调用默认的堆分配器。该教程的代码可在`此处&lt;<a class="reference external" href="https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/topics/allocator_tutorial.cpp">https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/topics/allocator_tutorial.cpp</a>&gt;`__获取。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3071">[3071]</a></p>
<div class="section" id="background">
<h2>背景 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3072">[3072]</a><a class="headerlink" href="#background" title="永久链接至标题"></a></h2>
<p>假设您想编写实时安全的代码，并且听说在实时关键部分调用&quot;new&quot;存在许多危险，因为大多数平台上的默认堆分配器是不确定的。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3073">[3073]</a></p>
<p>默认情况下，许多C++标准库的结构在增长时会隐式分配内存，比如``std::vector``。然而，这些数据结构还接受一个&quot;Allocator&quot;模板参数。如果您为这些数据结构指定了自定义分配器，它将使用该分配器来代替系统分配器来增长或缩小数据结构。您的自定义分配器可以在堆栈上预分配一块内存池，这可能更适合实时应用程序。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3074">[3074]</a></p>
<p>在ROS 2的C++客户端库（rclcpp）中，我们遵循与C++标准库类似的理念。发布者、订阅者和执行器（Executor）接受一个Allocator模板参数，用于控制实体在执行期间进行的分配。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3075">[3075]</a></p>
</div>
<div class="section" id="writing-an-allocator">
<h2>编写一个分配器 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3076">[3076]</a><a class="headerlink" href="#writing-an-allocator" title="永久链接至标题"></a></h2>
<p>要编写与ROS 2的分配器接口兼容的分配器，您的分配器必须与C++标准库的分配器接口兼容。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3077">[3077]</a></p>
<p>C++11库提供了一种称为“allocator_traits”的东西。C++11标准规定，自定义分配器只需要满足一组最小要求，就可以按照标准方式分配和释放内存。<a href="#id1"><span class="problematic" id="id2">``</span></a>allocator_traits``是一个通用的结构，它根据满足最小要求的分配器填充其他属性。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3078">[3078]</a></p>
<p>例如，下面这个自定义分配器的声明将满足``allocator_traits``（当然，您仍然需要在该结构中实现声明的函数）： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3079">[3079]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">custom_allocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">custom_allocator</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">custom_allocator</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">custom_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="nf">allocate</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">custom_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">custom_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">custom_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">custom_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>然后，您可以通过``allocator_traits``填充的其他函数和成员来访问分配器，如下所示：<code class="docutils literal notranslate"><span class="pre">std::allocator_traits&lt;custom_allocator&lt;T&gt;&gt;::construct(...)</span></code> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3080">[3080]</a></p>
<p>要了解``allocator_traits``的全部功能，请参阅 <a class="reference external" href="https://en.cppreference.com/w/cpp/memory/allocator_traits">https://en.cppreference.com/w/cpp/memory/allocator_traits</a> 。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3081">[3081]</a></p>
<p>然而，一些只支持部分C++11的编译器（如GCC 4.8）仍然需要分配器实现大量样板代码，以便与标准库结构（如向量和字符串）一起工作，因为这些结构在内部不使用``allocator_traits``。因此，如果您正在使用支持部分C++11的编译器，则您的分配器需要更像这样： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3082">[3082]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pointer_traits</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">reference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Avoid declaring a reference to void with an empty specialization</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">pointer_traits</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyAllocator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">pointer_traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">const_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">difference_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">pointer_traits</span><span class="o">&lt;</span><span class="n">pointer</span><span class="o">&gt;::</span><span class="n">difference_type</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">MyAllocator</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="o">~</span><span class="n">MyAllocator</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="n">MyAllocator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">rebind</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">U</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="writing-an-example-main">
<h2>编写一个示例主函数 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3083">[3083]</a><a class="headerlink" href="#writing-an-example-main" title="永久链接至标题"></a></h2>
<p>一旦您编写了一个有效的C++分配器，您必须将其作为共享指针传递给您的发布者、订阅者和执行器。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3084">[3084]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="n">rclcpp</span><span class="o">::</span><span class="n">PublisherOptionsWithAllocator</span><span class="o">&lt;</span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">publisher_options</span><span class="p">;</span><span class="w"></span>
<span class="n">publisher_options</span><span class="p">.</span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">publisher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">create_publisher</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">UInt32</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;allocator_tutorial&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">publisher_options</span><span class="p">);</span><span class="w"></span>

<span class="n">rclcpp</span><span class="o">::</span><span class="n">SubscriptionOptionsWithAllocator</span><span class="o">&lt;</span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">subscription_options</span><span class="p">;</span><span class="w"></span>
<span class="n">subscription_options</span><span class="p">.</span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">;</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">msg_mem_strat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">message_memory_strategy</span><span class="o">::</span><span class="n">MessageMemoryStrategy</span><span class="o">&lt;</span><span class="w"></span>
<span class="w">    </span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">UInt32</span><span class="p">,</span><span class="w"> </span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">alloc</span><span class="p">);</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">subscriber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">create_subscription</span><span class="o">&lt;</span><span class="n">std_msgs</span><span class="o">::</span><span class="n">msg</span><span class="o">::</span><span class="n">UInt32</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="s">&quot;allocator_tutorial&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">,</span><span class="w"> </span><span class="n">subscription_options</span><span class="p">,</span><span class="w"> </span><span class="n">msg_mem_strat</span><span class="p">);</span><span class="w"></span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">rclcpp</span><span class="o">::</span><span class="n">memory_strategy</span><span class="o">::</span><span class="n">MemoryStrategy</span><span class="o">&gt;</span><span class="w"> </span><span class="n">memory_strategy</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">AllocatorMemoryStrategy</span><span class="o">&lt;</span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">alloc</span><span class="p">);</span><span class="w"></span>
<span class="n">rclcpp</span><span class="o">::</span><span class="n">ExecutorOptions</span><span class="w"> </span><span class="n">options</span><span class="p">;</span><span class="w"></span>
<span class="n">options</span><span class="p">.</span><span class="n">memory_strategy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_strategy</span><span class="p">;</span><span class="w"></span>
<span class="n">rclcpp</span><span class="o">::</span><span class="n">executors</span><span class="o">::</span><span class="n">SingleThreadedExecutor</span><span class="w"> </span><span class="nf">executor</span><span class="p">(</span><span class="n">options</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>你还需要使用你的分配器来分配通过执行代码路径传递的任何消息。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3085">[3085]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MyAllocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>一旦你实例化了节点并将执行器添加到节点中，就可以开始运行了： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3086">[3086]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">rclcpp</span><span class="o">::</span><span class="n">ok</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">i</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">publisher</span><span class="o">-&gt;</span><span class="n">publish</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">executor</span><span class="p">.</span><span class="n">spin_some</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="passing-an-allocator-to-the-intra-process-pipeline">
<h2>将分配器传递给进程内管道 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3087">[3087]</a><a class="headerlink" href="#passing-an-allocator-to-the-intra-process-pipeline" title="永久链接至标题"></a></h2>
<p>即使我们在同一个进程中实例化了发布者和订阅者，但我们还没有使用进程内管道。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3088">[3088]</a></p>
<p>IntraProcessManager是一个通常对用户隐藏的类，但是为了向其传递自定义分配器，我们需要通过从rclcpp Context中获取它来公开它。IntraProcessManager使用了几个标准库结构，因此如果没有自定义分配器，它将调用默认的new函数。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3089">[3089]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">contexts</span><span class="o">::</span><span class="n">get_global_default_context</span><span class="p">();</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">NodeOptions</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">.</span><span class="n">use_intra_process_comms</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rclcpp</span><span class="o">::</span><span class="n">Node</span><span class="o">::</span><span class="n">make_shared</span><span class="p">(</span><span class="s">&quot;allocator_example&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">options</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>请确保在以此方式构建节点后实例化发布者和订阅者。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3090">[3090]</a></p>
</div>
<div class="section" id="testing-and-verifying-the-code">
<h2>对代码进行测试和验证。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3091">[3091]</a><a class="headerlink" href="#testing-and-verifying-the-code" title="永久链接至标题"></a></h2>
<p>您如何知道自定义分配器实际上被调用了？ <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3092">[3092]</a></p>
<p>显而易见的做法是统计自定义分配器的``allocate``和``deallocate``函数的调用次数，并将其与``new``和``delete``的调用次数进行比较。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3093">[3093]</a></p>
<p>在自定义分配器中添加计数很简单： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3094">[3094]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">num_allocs</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">deallocate</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">num_deallocs</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>您还可以重载全局的``new``和``delete``运算符： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3095">[3095]</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_running</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">global_runtime_deallocs</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_running</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">global_runtime_deallocs</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>其中我们递增的变量只是全局静态整数，而``is_running``是一个全局静态布尔值，在调用``spin``之前切换。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3096">[3096]</a></p>
<p>这个 <a class="reference external" href="https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/topics/allocator_tutorial.cpp">示例可执行文件</a> 打印变量的值。要运行示例可执行文件，请使用： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3097">[3097]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ros2 run demo_nodes_cpp allocator_tutorial
</pre></div>
</div>
<p>或者，要在进程内管道上运行示例： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3098">[3098]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ros2 run demo_nodes_cpp allocator_tutorial intra
</pre></div>
</div>
<p>你应该会得到如下的数字： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3099">[3099]</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Global new was called <span class="m">15590</span> <span class="nb">times</span> during spin
Global delete was called <span class="m">15590</span> <span class="nb">times</span> during spin
Allocator new was called <span class="m">27284</span> <span class="nb">times</span> during spin
Allocator delete was called <span class="m">27281</span> <span class="nb">times</span> during spin
</pre></div>
</div>
<p>我们捕获到了大约三分之二发生在执行路径上的分配/释放，但是剩下的三分之一从哪里来？ <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3100">[3100]</a></p>
<p>事实上，这些分配/释放操作源于在本示例中使用的底层DDS实现。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3101">[3101]</a></p>
<p>证明这一点超出了本教程的范围，但您可以查看作为ROS 2持续集成测试的一部分运行的分配路径测试，该测试通过代码回溯并确定某些函数调用是在rmw实现中还是在DDS实现中发起的： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3102">[3102]</a></p>
<p><a class="reference external" href="https://github.com/ros2/realtime_support/blob/humble/tlsf_cpp/test/test_tlsf.cpp#L41">https://github.com/ros2/realtime_support/blob/humble/tlsf_cpp/test/test_tlsf.cpp#L41</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3103">[3103]</a></p>
<p>请注意，该测试未使用刚刚创建的自定义分配器，而是使用了TLSF分配器（请参阅下文）。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3104">[3104]</a></p>
</div>
<div class="section" id="the-tlsf-allocator">
<h2>TLSF 分配器 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3105">[3105]</a><a class="headerlink" href="#the-tlsf-allocator" title="永久链接至标题"></a></h2>
<p>ROS 2 提供对 TLSF（Two Level Segregate Fit）分配器的支持，该分配器旨在满足实时要求： <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3106">[3106]</a></p>
<p><a class="reference external" href="https://github.com/ros2/realtime_support/tree/humble/tlsf_cpp">https://github.com/ros2/realtime_support/tree/humble/tlsf_cpp</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3107">[3107]</a></p>
<p>有关 TLSF 的更多信息，请参阅 <a class="reference external" href="http://www.gii.upv.es/tlsf/">http://www.gii.upv.es/tlsf/</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3108">[3108]</a></p>
<p>请注意，TLSF分配器使用双重GPL/LGPL许可证授权。 <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3109">[3109]</a></p>
<p>这里有一个使用TLSF分配器的完整工作示例：<a class="reference external" href="https://github.com/ros2/realtime_support/blob/humble/tlsf_cpp/example/allocator_example.cpp">https://github.com/ros2/realtime_support/blob/humble/tlsf_cpp/example/allocator_example.cpp</a> <a class="reference external" href="http://fishros.org/page/calib/#/home?apihost=http://fishros.org:2023/ros2/calib&amp;msgid=3110">[3110]</a></p>
</div>
</div>

  <div id="footer">
    <p>欢迎帮助改进！</p>
  </div>
</body>
</html>