<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>How-To-Guides/Sync-Vs-Async</title>
</head>
<body>
  <div class="section" id="synchronous-vs-asynchronous-service-clients">
<span id="syncasync"></span><h1>同步与异步服务客户端<a class="headerlink" href="#synchronous-vs-asynchronous-service-clients" title="永久链接至标题"></a></h1>
<p><strong>级别：</strong> 中级</p>
<p><strong>时间:</strong> 10分钟</p>
<div class="contents local topic" id="contents">
<p class="topic-title">内容</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">介绍</a></p></li>
<li><p><a class="reference internal" href="#synchronous-calls" id="id2">1 同步调用</a></p></li>
<li><p><a class="reference internal" href="#sync-deadlock" id="id3">1.1 同步死锁</a></p></li>
<li><p><a class="reference internal" href="#asynchronous-calls" id="id4">2 异步调用</a></p></li>
<li><p><a class="reference internal" href="#summary" id="id5">总结</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">介绍</a><a class="headerlink" href="#introduction" title="永久链接至标题"></a></h2>
<p>本指南旨在提醒用户有关与Python同步服务客户端``call()`` API相关的风险。在调用服务时，很容易错误地导致死锁，因此我们不建议使用``call()``。</p>
<p>对于希望使用同步调用并且了解其中陷阱的有经验的用户，我们提供了正确使用``call()``的示例。我们还强调了可能导致死锁的情景。</p>
<p>因为我们建议避免使用同步调用，所以本指南还将介绍推荐替代方案异步调用（<code class="docutils literal notranslate"><span class="pre">call_async()</span></code>）的功能和用法。</p>
<p>C++服务调用API仅支持异步调用，因此本指南中的比较和示例适用于Python服务和客户端。此处给出的异步定义通常也适用于C++，但存在一些例外情况。</p>
</div>
<div class="section" id="synchronous-calls">
<h2><a class="toc-backref" href="#id2">1 同步调用</a><a class="headerlink" href="#synchronous-calls" title="永久链接至标题"></a></h2>
<p>在发送请求到服务时，同步客户端会阻塞调用线程，直到接收到响应；在调用过程中该线程无法执行其他任务。调用的完成时间可以是任意长。一旦完成，响应直接返回给客户端。</p>
<p>以下是一个正确执行同步服务调用的示例，类似于教程中的异步节点（<a class="reference internal" href="../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client.html"><span class="doc">简单服务和客户端</span></a>）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="kn">from</span> <span class="nn">example_interfaces.srv</span> <span class="kn">import</span> <span class="n">AddTwoInts</span>
<span class="kn">import</span> <span class="nn">rclpy</span>
<span class="kn">from</span> <span class="nn">rclpy.node</span> <span class="kn">import</span> <span class="n">Node</span>

<span class="k">class</span> <span class="nc">MinimalClientSync</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s1">&#39;minimal_client_sync&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="n">AddTwoInts</span><span class="p">,</span> <span class="s1">&#39;add_two_ints&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">wait_for_service</span><span class="p">(</span><span class="n">timeout_sec</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;service not available, waiting again...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req</span> <span class="o">=</span> <span class="n">AddTwoInts</span><span class="o">.</span><span class="n">Request</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">req</span><span class="p">)</span>
        <span class="c1"># This only works because rclpy.spin() is called in a separate thread below.</span>
        <span class="c1"># Another configuration, like spinning later in main() or calling this method from a timer callback, would result in a deadlock.</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">rclpy</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

    <span class="n">minimal_client</span> <span class="o">=</span> <span class="n">MinimalClientSync</span><span class="p">()</span>

    <span class="n">spin_thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">rclpy</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">minimal_client</span><span class="p">,))</span>
    <span class="n">spin_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">minimal_client</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>
    <span class="n">minimal_client</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s1">&#39;Result of add_two_ints: for </span><span class="si">%d</span><span class="s1"> + </span><span class="si">%d</span><span class="s1"> = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
        <span class="p">(</span><span class="n">minimal_client</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">minimal_client</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">sum</span><span class="p">))</span>

    <span class="n">minimal_client</span><span class="o">.</span><span class="n">destroy_node</span><span class="p">()</span>
    <span class="n">rclpy</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>请注意，在 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 中，客户端在单独的线程中调用 <code class="docutils literal notranslate"><span class="pre">rclpy.spin</span></code>。<code class="docutils literal notranslate"><span class="pre">send_request</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rclpy.spin</span></code> 都是阻塞的，因此它们需要在不同的线程中执行。</p>
</div>
<div class="section" id="sync-deadlock">
<h2><a class="toc-backref" href="#id3">1.1 同步死锁</a><a class="headerlink" href="#sync-deadlock" title="永久链接至标题"></a></h2>
<p>同步的 <code class="docutils literal notranslate"><span class="pre">call()</span></code> API 可能会导致死锁的几种方式。</p>
<p>如上例的评论中提到的，未能创建一个单独的线程来运行 <code class="docutils literal notranslate"><span class="pre">rclpy</span></code> 是造成死锁的一个原因。当客户端阻塞一个线程等待响应，但是响应只能在同一线程上返回时，客户端将永远等待，而其他任何操作都无法进行。</p>
<p>另一个造成死锁的原因是在订阅、定时器回调或服务回调中同步调用服务导致阻塞了 <code class="docutils literal notranslate"><span class="pre">rclpy.spin</span></code>。例如，如果将同步客户端的 <code class="docutils literal notranslate"><span class="pre">send_request</span></code> 放在回调中：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trigger_request</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">minimal_client</span><span class="o">.</span><span class="n">send_request</span><span class="p">()</span>  <span class="c1"># This will cause deadlock</span>
    <span class="n">minimal_client</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s1">&#39;Result of add_two_ints: for </span><span class="si">%d</span><span class="s1"> + </span><span class="si">%d</span><span class="s1"> = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
        <span class="p">(</span><span class="n">minimal_client</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">minimal_client</span><span class="o">.</span><span class="n">req</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">sum</span><span class="p">))</span>
<span class="n">subscription</span> <span class="o">=</span> <span class="n">minimal_client</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="s1">&#39;trigger&#39;</span><span class="p">,</span> <span class="n">trigger_request</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="n">rclpy</span><span class="o">.</span><span class="n">spin</span><span class="p">(</span><span class="n">minimal_client</span><span class="p">)</span>
</pre></div>
</div>
<p>死锁发生是因为 <code class="docutils literal notranslate"><span class="pre">rclpy.spin</span></code> 不会在回调中与 <code class="docutils literal notranslate"><span class="pre">send_request</span></code> 调用进行抢占。一般情况下，回调函数应该只执行轻量且快速的操作。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>当发生死锁时，你将不会收到任何关于服务被阻塞的指示。不会有警告或异常抛出，堆栈跟踪中也没有指示，调用也不会失败。</p>
</div>
</div>
<div class="section" id="asynchronous-calls">
<h2><a class="toc-backref" href="#id4">2 异步调用</a><a class="headerlink" href="#asynchronous-calls" title="永久链接至标题"></a></h2>
<p>在 <code class="docutils literal notranslate"><span class="pre">rclpy</span></code> 中，异步调用是完全安全且推荐的调用服务的方法。与同步调用不同，它们可以在任何地方进行，而不会阻塞其他ROS和非ROS进程的运行风险。</p>
<p>在向服务发送请求后，异步客户端会立即返回一个表示调用和响应是否完成的 <code class="docutils literal notranslate"><span class="pre">future</span></code> 值（而不是响应本身的值）。可以随时查询返回的 <code class="docutils literal notranslate"><span class="pre">future</span></code> 是否有响应。</p>
<p>由于发送请求不会阻塞任何操作，可以使用循环在同一线程中既运行 <code class="docutils literal notranslate"><span class="pre">rclpy</span></code> 又检查 <code class="docutils literal notranslate"><span class="pre">future</span></code>，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="n">rclpy</span><span class="o">.</span><span class="n">ok</span><span class="p">():</span>
    <span class="n">rclpy</span><span class="o">.</span><span class="n">spin_once</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
        <span class="c1">#Get response</span>
</pre></div>
</div>
<p>Python的教程 <a class="reference internal" href="../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client.html"><span class="doc">简单的服务和客户端</span></a> 展示了如何使用循环执行异步服务调用并检索 <code class="docutils literal notranslate"><span class="pre">future</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">future</span></code> 也可以使用定时器或回调来检索，就像在 <a class="reference external" href="https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py">这个示例</a> 中一样，可以使用专用线程或其他方法。作为调用者，您可以自行决定如何存储 <code class="docutils literal notranslate"><span class="pre">future</span></code>，检查其状态并检索响应。</p>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id5">总结</a><a class="headerlink" href="#summary" title="永久链接至标题"></a></h2>
<p>不推荐实现同步服务客户端。它们容易发生死锁，但当死锁发生时不会提供任何问题指示。如果必须使用同步调用，可以使用 <a class="reference internal" href="#synchronous-calls">1 同步调用</a> 部分中的示例来安全地进行。您还应该了解在 <a class="reference internal" href="#sync-deadlock">1.1 同步死锁</a> 部分中概述的导致死锁的条件。我们推荐使用异步服务客户端。</p>
</div>
</div>

  <div id="footer">
    <p>欢迎帮助改进！</p>
  </div>
</body>
</html>