# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 Documentation: Humble package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 Documentation: Humble \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-15 19:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"


#: ../../source/How-To-Guides.rst:8
msgid "How-to Guides"
msgstr "如何指南"


#: ../../source/How-To-Guides.rst:10
msgid "How-to Guides provide direct and modular answers to \"How-to\" questions regarding key aspects of ROS 2. They contain succinct steps to help you accomplish important tasks quickly."
msgstr "如何指南提供 ROS 2 关键方面的“如何”问题的直接和模块化答案。它们包含简明的步骤，帮助您快速完成重要任务。"


#: ../../source/How-To-Guides.rst:13
msgid "How-to Guides are meant for users who already have some knowledge of ROS 2 and just want to find out how to implement something specific. They will not go in-depth by providing background information or teaching how a concept ties into the greater ROS 2 ecosystem."
msgstr "如何指南适用于已经具有一定 ROS 2 知识并且只想了解如何实现特定内容的用户。它们不会提供深入的背景信息或教授概念如何与更广泛的 ROS 2 生态系统相关联。"


#: ../../source/How-To-Guides.rst:16
msgid "If you are new and looking to learn the ropes, start with the :doc:`Tutorials <Tutorials>` for a more well-rounded progression through ROS 2."
msgstr "如果您是新手并且希望学习 ROS 2 的基础知识，请从 :doc:`教程 <Tutorials>` 开始，以更全面地掌握 ROS 2 的进展。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:7
msgid "ament_cmake user documentation"
msgstr "ament_cmake 用户文档"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:9
msgid "ament_cmake is the build system for CMake based packages in ROS 2 (in particular, it will be used for most if not all C/C++ projects). It is a set of scripts enhancing CMake and adding convenience functionality for package authors. Knowing the basics of `CMake <https://cmake.org/cmake/help/v3.5/>`__ will be very helpful, an official tutorial can be found `here <https://cmake.org/cmake/help/latest/guide/tutorial/index.html>`__."
msgstr "ament_cmake 是 ROS 2 中基于 CMake 的软件包构建系统（特别是将用于大多数，如果不是全部 C/C++ 项目）。它是一组增强 CMake 功能并为软件包作者添加便利功能的脚本。了解 `CMake <https://cmake.org/cmake/help/v3.5/>`__ 的基础知识将非常有帮助，可以在 `这里 <https://cmake.org/cmake/help/latest/guide/tutorial/index.html>`__ 找到官方教程。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:15 ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:20 ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:6 ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:12 ../../source/How-To-Guides/Cross-compilation.rst:11 ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:12 ../../source/How-To-Guides/Launch-file-different-formats.rst:10 ../../source/How-To-Guides/Launch-files-migration-guide.rst:13 ../../source/How-To-Guides/Launching-composable-nodes.rst:6 ../../source/How-To-Guides/Node-arguments.rst:13 ../../source/How-To-Guides/Package-maintainer-guide.rst:12 ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:12 ../../source/How-To-Guides/Releasing/First-Time-Release.rst:9 ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:6 ../../source/How-To-Guides/Releasing/Release-Track.rst:6 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:8 ../../source/How-To-Guides/Using-callback-groups.rst:11 ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:6 ../../source/How-To-Guides/Using-ros2-param.rst:6 ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:12
msgid "Table of Contents"
msgstr "目录"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:18 ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:23
msgid "Basics"
msgstr "基础知识"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:20
msgid "A basic CMake outline can be produced using ``ros2 pkg create <package_name>`` on the command line. The basic build information is then gathered in two files: the ``package.xml`` and the ``CMakeLists.txt``. The ``package.xml`` must contain all dependencies and a bit of metadata to allow colcon to find the correct build order for your packages, to install the required dependencies in CI as well as provide the information for a release with ``bloom``. The ``CMakeLists.txt`` contains the commands to build and package executables and libraries and will be the main focus of this document."
msgstr "可以使用命令行上的 ``ros2 pkg create <package_name>`` 创建基本的 CMake 概述。基本的构建信息然后会在两个文件中收集：``package.xml`` 和 ``CMakeLists.txt``。``package.xml`` 必须包含所有依赖项和一些元数据，以使 colcon 能够找到正确的软件包构建顺序，以在 CI 中安装所需的依赖项，并提供用于 ``bloom`` 发布的信息。``CMakeLists.txt`` 包含构建和打包可执行文件和库的命令，并且将是本文档的主要焦点。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:26 ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:26
msgid "Basic project outline"
msgstr "基本项目概述"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:28
msgid "The basic outline of the ``CMakeLists.txt`` of an ament package contains:"
msgstr "一个ament包的``CMakeLists.txt``的基本概述包括："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:37
msgid "The argument to ``project`` will be the package name and must be identical to the package name in the ``package.xml``."
msgstr "``project``的参数将是包名，并且必须与``package.xml``中的包名完全相同。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:39
msgid "The project setup is done by ``ament_package()`` and this call must occur exactly once per package. ``ament_package()`` installs the ``package.xml``, registers the package with the ament index, and installs config (and possibly target) files for CMake so that it can be found by other packages using ``find_package``. Since ``ament_package()`` gathers a lot of information from the ``CMakeLists.txt`` it should be the last call in your ``CMakeLists.txt``. Although it is possible to follow calls to ``ament_package()`` by calls to ``install`` functions copying files and directories, it is simpler to just keep ``ament_package()`` the last call."
msgstr "项目的设置由``ament_package()``完成，此调用必须每个包只出现一次。``ament_package()``安装``package.xml``，在ament索引中注册包，并安装用于CMake的配置（以及可能的目标）文件，以便其他使用``find_package``的包可以找到它。由于``ament_package()``从``CMakeLists.txt``中收集了大量信息，因此它应该是``CMakeLists.txt``中的最后一个调用。尽管可以在``ament_package()``调用之后跟随``install``函数调用以复制文件和目录，但简单起见，最好将``ament_package()``保持为最后一个调用。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:44
msgid "``ament_package`` can be given additional arguments:"
msgstr "``ament_package`` 可以接受额外的参数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:46
msgid "``CONFIG_EXTRAS``: a list of CMake files (``.cmake`` or ``.cmake.in`` templates expanded by ``configure_file()``) which should be available to clients of the package. For an example of when to use these arguments, see the discussion in `Adding resources`_. For more information on how to use template files, see `the official documentation <https://cmake.org/cmake/help/v3.5/command/configure_file.html>`__."
msgstr "``CONFIG_EXTRAS``：CMake 文件列表（通过 ``configure_file()`` 扩展的 ``.cmake`` 或 ``.cmake.in`` 模板），应该对软件包的客户端可用。关于何时使用这些参数的示例，请参阅 `Adding resources`_ 中的讨论。有关如何使用模板文件的更多信息，请参阅 `官方文档 <https://cmake.org/cmake/help/v3.5/command/configure_file.html>`__。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:50
msgid "``CONFIG_EXTRAS_POST``: same as ``CONFIG_EXTRAS``, but the order in which the files are added differs. While ``CONFIG_EXTRAS`` files are included before the files generated for the ``ament_export_*`` calls the files from ``CONFIG_EXTRAS_POST`` are included afterwards."
msgstr "``CONFIG_EXTRAS_POST``：与 ``CONFIG_EXTRAS`` 相同，但添加文件的顺序不同。``CONFIG_EXTRAS`` 文件在为 ``ament_export_*`` 调用生成文件之前包含，而 ``CONFIG_EXTRAS_POST`` 的文件在之后包含。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:53
msgid "Instead of adding to ``ament_package``, you can also add to the variable ``${PROJECT_NAME}_CONFIG_EXTRAS`` and ``${PROJECT_NAME}_CONFIG_EXTRAS_POST`` with the same effect. The only difference is again the order in which the files are added with the following total order:"
msgstr "除了向 ``ament_package`` 添加外，您还可以添加到变量 ``${PROJECT_NAME}_CONFIG_EXTRAS`` 和 ``${PROJECT_NAME}_CONFIG_EXTRAS_POST``，效果相同。唯一的区别是再次添加文件的顺序，具体顺序如下："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:56
msgid "files added by ``CONFIG_EXTRAS``"
msgstr "由``CONFIG_EXTRAS``添加的文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:58
msgid "files added by appending to ``${PROJECT_NAME}_CONFIG_EXTRAS``"
msgstr "通过附加到``${PROJECT_NAME}_CONFIG_EXTRAS``添加的文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:60
msgid "files added by appending to ``${PROJECT_NAME}_CONFIG_EXTRAS_POST``"
msgstr "通过附加到``${PROJECT_NAME}_CONFIG_EXTRAS_POST``添加的文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:62
msgid "files added by ``CONFIG_EXTRAS_POST``"
msgstr "由``CONFIG_EXTRAS_POST``添加的文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:65
msgid "Adding files and headers"
msgstr "添加文件和头文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:67
msgid "There are two main targets to build: libraries and executables which are built by ``add_library`` and ``add_executable`` respectively."
msgstr "有两个主要的构建目标：库和可执行文件分别通过``add_library``和``add_executable``构建。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:69
msgid "With the separation of header files and implementation in C/C++, it is not always necessary to add both files as argument to ``add_library``/ ``add_executable``."
msgstr "在C/C++中，由于头文件和实现文件的分离，不一定需要将这两个文件都作为``add_library``/ ``add_executable``的参数添加进去。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:71
msgid "The following best practice is proposed:"
msgstr "建议采用以下最佳实践："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:73
msgid "if you are building a library, put all headers which should be usable by clients and therefore must be installed into a subdirectory of the ``include`` folder named like the package, while all other files (``.c/.cpp`` and header files which should not be exported) are inside the ``src`` folder."
msgstr "如果您正在构建一个库，将所有应该可供客户使用并且必须安装的头文件放入名为包名称的``include``文件夹的子目录中，而其他文件（``.c/.cpp``和不应导出的头文件）则放在``src``文件夹中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:75
msgid "only cpp files are explicitly referenced in the call to ``add_library`` or ``add_executable``"
msgstr "只有cpp文件在调用``add_library``或``add_executable``时被显式引用。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:77
msgid "allow to find headers via"
msgstr "通过允许找到头文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:86
msgid "This adds all files in the folder ``${CMAKE_CURRENT_SOURCE_DIR}/include`` to the public interface during build time and all files in the include folder (relative to ``${CMAKE_INSTALL_DIR}``) when being installed."
msgstr "这将在构建时将``${CMAKE_CURRENT_SOURCE_DIR}/include``文件夹中的所有文件添加到公共接口中，并在安装时将所有文件添加到include文件夹中（相对于``${CMAKE_INSTALL_DIR}``）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:88
msgid "In principle, using generator expressions here is not necessary if both folders are called ``include`` and top-level with respect to ``${CMAKE_CURRENT_SOURCE_DIR}`` and ``${CMAKE_INSTALL_DIR}``, but it is very common."
msgstr "原则上，如果两个文件夹都称为“include”并且相对于“${CMAKE_CURRENT_SOURCE_DIR}”和“${CMAKE_INSTALL_DIR}”是顶层的话，在这里使用生成器表达式是不必要的，但这是非常常见的。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:91
msgid "Adding Dependencies"
msgstr "添加依赖项"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:93
msgid "There are two ways to link your packages against a new dependency."
msgstr "有两种方法可以将您的软件包与新的依赖关系进行链接。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:95
msgid "The first and recommended way is to use the ament macro ``ament_target_dependencies``. As an example, suppose we want to link ``my_target`` against the linear algebra library Eigen3."
msgstr "第一种推荐的方法是使用ament宏 ``ament_target_dependencies``。例如，假设我们想将``my_target``与线性代数库Eigen3进行链接。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:103
msgid "It includes the necessary headers and libraries and their dependencies to be correctly found by the project. It will also ensure that the include directories of all dependencies are ordered correctly when using overlay workspaces."
msgstr "它包含了必要的头文件、库文件及其依赖项，以便项目能够正确找到它们。同时，在使用叠加工作空间时，它还会确保所有依赖项的包含目录被正确排序。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:106
msgid "The second way is to use ``target_link_libraries``."
msgstr "第二种方法是使用``target_link_libraries``函数。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:108
msgid "The recommended way in modern CMake is to only use targets, exporting and linking against them. CMake targets are namespaced, similar to C++. For instance, ``Eigen3`` defines the target ``Eigen3::Eigen``."
msgstr "在现代CMake中，推荐的方式是仅使用目标（targets），并将其导出和链接。CMake目标使用命名空间，类似于C++。例如，``Eigen3``定义了目标``Eigen3::Eigen``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:112
msgid "At least until ``Crystal Clemmys`` target names are not supported in the ``ament_target_dependencies`` macro. Sometimes it will be necessary to call the ``target_link_libaries`` CMake function. In the example of Eigen3, the call should then look like"
msgstr "至少在``ament_target_dependencies``宏中不支持``Crystal Clemmys``目标名称之前，有时需要调用``target_link_libraries`` CMake函数。以Eigen3为例，调用应该如下所示："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:121
msgid "This will also include necessary headers, libraries and their dependencies, but in contrast to ``ament_target_dependencies`` it might not correctly order the dependencies when using overlay workspaces."
msgstr "这也会包括必要的头文件、库以及它们的依赖项，但与 ``ament_target_dependencies`` 不同的是，使用覆盖工作空间时它可能无法正确地排序依赖项。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:125
msgid "It should never be necessary to ``find_package`` a library that is not explicitly needed but is a dependency of another dependency that is explicitly needed. If that is the case, file a bug against the corresponding package."
msgstr "通常情况下不需要对不明确需要但是另一个明确需要的依赖项的依赖项进行 ``find_package``。如果出现这种情况，请向相应的软件包提交错误报告。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:129
msgid "Building a Library"
msgstr "构建库"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:131
msgid "When building a reusable library, some information needs to be exported for downstream packages to easily use it."
msgstr "在构建可重用库时，需要导出一些信息以便下游软件包能够轻松使用它。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:153
msgid "Here, we assume that the folder ``include`` contains the headers which need to be exported. Note that it is not necessary to put all headers into a separate folder, only those that should be included by clients."
msgstr "这里我们假设文件夹 ``include`` 包含需要导出的头文件。请注意，并不需要将所有的头文件放入单独的文件夹中，只需将需要由客户端包含的头文件放入其中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:156
msgid "Here is what's happening in the snippet above:"
msgstr "上面的代码片段中发生了什么，下面是说明："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:158
msgid "The ``ament_export_targets`` macro exports the targets for CMake. This is necessary to allow your library's clients to use the ``target_link_libraries(client my_library::my_library)`` syntax. ``ament_export_targets`` can take an arbitrary list of targets named as ``EXPORT`` in an install call and an additional option ``HAS_LIBRARY_TARGET``, which adds potential libraries to environment variables."
msgstr "``ament_export_targets`` 宏将 CMake 的目标导出。这是必要的，以便允许库的客户端使用 ``target_link_libraries(client my_library::my_library)`` 语法。``ament_export_targets`` 可以在 install 调用中使用一个名为 ``EXPORT`` 的任意目标列表，并添加一个额外的选项 ``HAS_LIBRARY_TARGET``，它将潜在的库添加到环境变量中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:162
msgid "The ``ament_export_dependencies`` exports dependencies to downstream packages. This is necessary so that the user of the library does not have to call ``find_package`` for those dependencies, too."
msgstr "``ament_export_dependencies`` 将依赖项导出到下游包。这是必要的，这样库的使用者也不必为这些依赖项调用 ``find_package``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:165
msgid "The first ``install`` commands installs the header files which should be available to clients."
msgstr "第一个 ``install`` 命令安装了应该对客户端可用的头文件。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:169
msgid "Calling ``ament_export_targets``, ``ament_export_dependencies``, or other ament commands from a CMake subdirectory will not work as expected. This is because the CMake subdirectory has no way of setting necessary variables in the parent scope where ``ament_package`` is called."
msgstr "从CMake子目录调用``ament_export_targets``、``ament_export_dependencies``或其他ament命令将不会按预期工作。这是因为CMake子目录无法在调用``ament_package``的父范围中设置必要的变量。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:172
msgid "The last large install command installs the library. Archive and library files will be exported to the lib folder, runtime binaries will be installed to the bin folder and the path to installed headers is ``include``."
msgstr "最后一个大型安装命令安装库。存档和库文件将被导出到lib文件夹，运行时二进制文件将被安装到bin文件夹，已安装头文件的路径为``include``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:177
msgid "Windows DLLs are treated as runtime artifacts and installed into the ``RUNTIME DESTINATION`` folder. It is therefore advised to not leave out the ``RUNTIME`` install even when developing libraries on Unix based systems."
msgstr "Windows DLL被视为运行时工件，并安装到``RUNTIME DESTINATION``文件夹中。因此，建议即使在基于Unix的系统上开发库时也不要忽略``RUNTIME``安装。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:180
msgid "Regarding the ``include directory``, the install command only adds information to CMake, it does not actually install the includes folder. This is done by copying the headers via ``install(DIRECTORY <dir> DESTINATION <dest>)`` as described above."
msgstr "关于``include directory``，安装命令只是向CMake添加信息，实际上并没有安装包含文件夹。这是通过复制头文件来实现的，方法是使用``install(DIRECTORY <dir> DESTINATION <dest>)``，如上所述。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:183
msgid "The ``EXPORT`` notation of the install call requires additional attention: It installs the CMake files for the ``my_library`` target. It is named exactly like the argument in ``ament_export_targets`` and could be named like the library. However, this will then prohibit using the ``ament_target_dependencies`` way of including your library. To allow for full flexibility, it is advised to prepend the export target with something like ``<target>Targets``."
msgstr "安装调用中``EXPORT``标注需要额外注意：它安装了``my_library``目标的CMake文件。它的名称与``ament_export_targets``中的参数完全相同，并且可以与库的名称相同。然而，这将阻止使用``ament_target_dependencies``包含库的方式。为了实现完全的灵活性，建议在导出目标之前添加类似``<target>Targets``的内容。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:189
msgid "All install paths are relative to ``CMAKE_INSTALL_PREFIX``, which is already set correctly by colcon/ament"
msgstr "所有安装路径都相对于``CMAKE_INSTALL_PREFIX``，colcon/ament已经正确设置了该值。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:191
msgid "There are two additional functions which can be used but are superfluous for target based installs:"
msgstr "还有两个可以使用但对于基于目标的安装来说是多余的函数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:198
msgid "The first macro marks the directory of the exported include directories (this is achieved by ``INCLUDES DESTINATION`` in the target ``install`` call). The second macro marks the location of the installed library (this is done by the ``HAS_LIBRARY_TARGET`` argument in the call to ``ament_export_targets``)."
msgstr "第一个宏标记导出包含目录的目录（这通过目标“install”调用中的“INCLUDES DESTINATION”实现）。第二个宏标记已安装库的位置（这是通过调用“ament_export_targets”中的“HAS_LIBRARY_TARGET”参数完成的）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:201
msgid "Some of the macros can take different types of arguments for non-target exports, but since the recommended way for modern Make is to use targets, we will not cover them here. Documentation of these options can be found in the source code itself."
msgstr "一些宏可以接受不同类型的参数用于非目标导出，但由于现代Make的推荐方式是使用目标，我们将不在此处介绍它们。这些选项的文档可以在源代码本身中找到。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:205
msgid "Compiler and linker options"
msgstr "编译器和链接器选项"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:207
msgid "ROS 2 targets compilers which comply with the C++14 and C99 standard until at least ``Crystal Clemmys``. Newer versions might be targeted in the future and are referenced `here <https://www.ros.org/reps/rep-2000.html>`__. Therefore it is customary to set the corresponding CMake flags:"
msgstr "ROS 2针对符合C++14和C99标准的编译器进行编译，至少到“Crystal Clemmys”。将来可能针对更新版本进行目标设置，并在此处引用。因此，惯例是设置相应的CMake标志："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:220
msgid "To keep the code clean, compilers should throw warnings for questionable code and these warnings should be fixed."
msgstr "为了保持代码的清洁，编译器应该对可疑的代码发出警告，并且这些警告应该被修复。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:222
msgid "It is recommended to at least cover the following warning levels:"
msgstr "建议至少包括以下警告级别："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:224
msgid "For Visual Studio, the default ``W1`` warnings are kept"
msgstr "对于Visual Studio，保留了默认的``W1``警告级别。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:226
msgid "For GCC and Clang: ``-Wall -Wextra -Wpedantic`` are required and ``-Wshadow -Werror`` are advisable (the latter makes warnings errors)."
msgstr "对于GCC和Clang：需要使用``-Wall -Wextra -Wpedantic``，建议使用``-Wshadow -Werror``（后者将警告转为错误）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:228
msgid "Although modern CMake advises to add compiler flags on a target basis, i.e. call"
msgstr "尽管现代CMake建议根据目标添加编译器标志，即调用"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:234
msgid "it is at the moment recommended to use the directory level function ``add_compile_options(-Wall)`` to not clutter the code with target-based compile options for all executables and tests."
msgstr "目前建议使用目录级别的函数 ``add_compile_options(-Wall)`` ，以避免为所有可执行文件和测试添加基于目标的编译选项，从而不会使代码混乱。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:237
msgid "Building libraries on Windows"
msgstr "在Windows上构建库"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:239
msgid "Since Linux, Mac and Windows are all officially supported platforms, to have maximum impact any package should also build on Windows. The Windows library format enforces symbol visibility: Every symbol which should be used from a client has to be explicitly exported by the library (and data symbols need to be implicitly imported)."
msgstr "由于Linux、Mac和Windows都是官方支持的平台，为了最大限度地发挥作用，任何软件包也应该在Windows上构建。Windows库格式强制执行符号可见性：应该由库显式导出要从客户端使用的每个符号（并且数据符号需要隐式导入）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:243
msgid "To keep this compatible with Clang and GCC builds, it is advised to use the logic in `the GCC wiki <https://gcc.gnu.org/wiki/Visibility>`__. To use it for a package called ``my_library``:"
msgstr "为了与Clang和GCC构建兼容，建议使用`GCC维基 <https://gcc.gnu.org/wiki/Visibility>`__中的逻辑。要在名为``my_library``的软件包中使用它："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:246
msgid "Copy the logic in the link into a header file called ``visibility_control.hpp``."
msgstr "将链接中的逻辑复制到名为``visibility_control.hpp``的头文件中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:248
msgid "Replace ``DLL`` by ``MY_LIBRARY`` (for an example, see visibility control of `rviz_rendering <https://github.com/ros2/rviz/blob/ros2/rviz_rendering/include/rviz_rendering/visibility_control.hpp>`__)."
msgstr "将``DLL``替换为``MY_LIBRARY``（例如，查看`rviz_rendering的可见性控制 <https://github.com/ros2/rviz/blob/ros2/rviz_rendering/include/rviz_rendering/visibility_control.hpp>`__）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:250
msgid "Use the macros \"MY_LIBRARY_PUBLIC\" for all symbols you need to export (i.e. classes or functions)."
msgstr "对于需要导出的所有符号（例如类或函数），请使用宏\"MY_LIBRARY_PUBLIC\"。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:252
msgid "In the project ``CMakeLists.txt`` use:"
msgstr "在项目的 ``CMakeLists.txt`` 中使用："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:258
msgid "For more details, see :ref:`Windows Symbol Visibility in the Windows Tips and Tricks document <Windows_Symbol_Visibility>`."
msgstr "有关更多详细信息，请参阅：:ref:`Windows_Tips_and_Tricks 文档中的 Windows 符号可见性 <Windows_Symbol_Visibility>`。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:261
msgid "Testing and Linting"
msgstr "测试和代码检查"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:263
msgid "In order to separate testing from building the library with colcon, wrap all calls to linters and tests in a conditional:"
msgstr "为了将测试与使用 colcon 构建库分开，将所有对代码检查和测试的调用都包装在条件语句中："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:273
msgid "Linting"
msgstr "代码检查"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:275
msgid "It's advised to use the combined call from `ament_lint_auto <https://github.com/ament/ament_lint/blob/humble/ament_lint_auto/doc/index.rst#ament_lint_auto>`_:"
msgstr "建议使用`ament_lint_auto <https://github.com/ament/ament_lint/blob/humble/ament_lint_auto/doc/index.rst#ament_lint_auto>`_中的组合调用："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:282
msgid "This will run linters as defined in the ``package.xml``. It is recommended to use the set of linters defined by the package ``ament_lint_common``. The individual linters included there, as well as their functions, can be seen in the `ament_lint_common docs <https://github.com/ament/ament_lint/blob/humble/ament_lint_common/doc/index.rst>`_."
msgstr "这将按照``package.xml``中定义的方式运行代码检查工具。建议使用由``ament_lint_common``软件包定义的代码检查工具集。其中包含的各个代码检查工具及其功能可以在`ament_lint_common文档 <https://github.com/ament/ament_lint/blob/humble/ament_lint_common/doc/index.rst>`_中查看。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:286
msgid "Linters provided by ament can also be added separately, instead of running ``ament_lint_auto``. One example of how to do so can be found in the `ament_cmake_lint_cmake documentation <https://github.com/ament/ament_lint/blob/humble/ament_cmake_lint_cmake/doc/index.rst>`_."
msgstr "ament提供的代码检查工具也可以单独添加，而不是运行``ament_lint_auto``。如何添加的一个示例可以在`ament_cmake_lint_cmake文档 <https://github.com/ament/ament_lint/blob/humble/ament_cmake_lint_cmake/doc/index.rst>`_中找到。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:290
msgid "Testing"
msgstr "测试"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:292
msgid "Ament contains CMake macros to simplify setting up GTests. Call:"
msgstr "Ament包含CMake宏，可以简化设置GTests的过程。调用："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:299
msgid "to add a GTest. This is then a regular target which can be linked against other libraries (such as the project library). The macros have additional parameters:"
msgstr "以添加一个GTest。然后，这是一个常规目标，可以与其他库链接（如项目库）。这些宏有额外的参数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:303
msgid "``APPEND_ENV``: append environment variables. For instance you can add to the ament prefix path by calling:"
msgstr "``APPEND_ENV``：追加环境变量。例如，您可以通过调用来添加到ament前缀路径："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:312
msgid "``APPEND_LIBRARY_DIRS``: append libraries so that they can be found by the linker at runtime. This can be achieved by setting environment variables like ``PATH`` on Windows and ``LD_LIBRARY_PATH`` on Linux, but this makes the call platform specific."
msgstr "``APPEND_LIBRARY_DIRS``：追加库文件目录，以便链接器在运行时能够找到它们。这可以通过设置环境变量，如在Windows上设置``PATH``，在Linux上设置``LD_LIBRARY_PATH``来实现，但这样做会使调用与特定平台相关。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:315
msgid "``ENV``: set environment variables (same syntax as ``APPEND_ENV``)."
msgstr "``ENV``：设置环境变量（语法与``APPEND_ENV``相同）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:317
msgid "``TIMEOUT``: set a test timeout in second. The default for GTests is 60 seconds.  For example:"
msgstr "``TIMEOUT``：设置测试的超时时间（以秒为单位）。GTests的默认超时时间为60秒。例如："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:323
msgid "``SKIP_TEST``: skip this test (will be shown as \"passed\" in the console output)."
msgstr "``SKIP_TEST``：跳过此测试（在控制台输出中将显示为“通过”）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:325
msgid "``SKIP_LINKING_MAIN_LIBRARIES``: Don't link against GTest."
msgstr "``SKIP_LINKING_MAIN_LIBRARIES``：不链接GTest。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:327
msgid "``WORKING_DIRECTORY``: set the working directory for the test."
msgstr "``WORKING_DIRECTORY``：设置测试的工作目录。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:329
msgid "The default working directory otherwise is the ``CMAKE_CURRENT_BINARY_DIR``, which is described in the `CMake documentation <https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html>`_."
msgstr "否则，默认工作目录是 ``CMAKE_CURRENT_BINARY_DIR``，在 `CMake 文档 <https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html>`_ 中有描述。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:331
msgid "Similarly, there is a CMake macro to set up GTest including GMock:"
msgstr "类似地，有一个 CMake 宏用于设置 GTest，包括 GMock："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:338
msgid "It has the same additional parameters as ``ament_add_gtest``."
msgstr "它具有与 ``ament_add_gtest`` 相同的附加参数。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:341
msgid "Extending ament"
msgstr "扩展 ament"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:343
msgid "It is possible to register additional macros/functions with ``ament_cmake`` and extend it in several ways."
msgstr "可以使用 ``ament_cmake`` 注册附加的宏/函数，并以多种方式进行扩展。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:346
msgid "Adding a function/macro to ament"
msgstr "向 ament 添加函数/宏"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:348
msgid "Extending ament will often times mean that you want to have some functions available to other packages. The best way to provide the macro to client packages is to register it with ament."
msgstr "扩展ament通常意味着您希望其他软件包可以使用某些函数。向客户端软件包提供宏的最佳方法是将其注册到ament中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:351
msgid "This can be done by appending the ``${PROJECT_NAME}_CONFIG_EXTRAS`` variable, which is used by ``ament_package()`` via"
msgstr "可以通过追加``${PROJECT_NAME}_CONFIG_EXTRAS``变量来实现，该变量由``ament_package()``使用，通过以下方式："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:360
msgid "Alternatively, you can directly add the files to the ``ament_package()`` call:"
msgstr "或者，您可以直接将文件添加到``ament_package()``调用中："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:370
msgid "Adding to extension points"
msgstr "添加到扩展点"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:372
msgid "In addition to simple files with functions that can be used in other packages, you can also add extensions to ament. Those extensions are scripts which are executed with the function which defines the extension point. The most common use-case for ament extensions is probably registering rosidl message generators: When writing a generator, you normally want to generate all messages and services with your generator also without modifying the code for the message/service definition packages. This is possible by registering the generator as an extension to ``rosidl_generate_interfaces``."
msgstr "除了可以在其他软件包中使用的简单函数文件外，您还可以向ament添加扩展。这些扩展是通过定义扩展点的函数执行的脚本。ament扩展的最常见用例可能是注册rosidl消息生成器：当编写生成器时，通常希望使用生成器生成所有消息和服务，而无需修改消息/服务定义软件包的代码。通过将生成器注册为``rosidl_generate_interfaces``的扩展，可以实现这一点。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:378
msgid "As an example, see"
msgstr "例如，参见"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:387
msgid "which registers the macro ``rosidl_generator_cpp_generate_interfaces.cmake`` for the package ``rosidl_generator_cpp`` to the extension point ``rosidl_generate_interfaces``. When the extension point gets executed, this will trigger the execution of the script ``rosidl_generator_cpp_generate_interfaces.cmake`` here. In particular, this will call the generator whenever the function ``rosidl_generate_interfaces`` gets executed."
msgstr "它为软件包``rosidl_generator_cpp``在扩展点``rosidl_generate_interfaces``上注册了宏``rosidl_generator_cpp_generate_interfaces.cmake``。当扩展点被执行时，它将触发在此处执行脚本``rosidl_generator_cpp_generate_interfaces.cmake``。特别地，这将在每次执行函数``rosidl_generate_interfaces``时调用生成器。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:391
msgid "The most important extension point for generators, aside from ``rosidl_generate_interfaces``, is ``ament_package``, which will simply execute scripts with the ``ament_package()`` call. This extension point is useful when registering resources (see below)."
msgstr "除了``rosidl_generate_interfaces``之外，生成器的最重要的扩展点是``ament_package``，它将通过``ament_package()``调用简单地执行脚本。在注册资源时，此扩展点非常有用（请参见下文）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:394
msgid "``ament_register_extension`` is a function which takes exactly three arguments:"
msgstr "``ament_register_extension``是一个接受三个参数的函数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:396
msgid "``extension_point``: The name of the extension point (most of the time this will be one of ``ament_package`` or ``rosidl_generate_interfaces``)"
msgstr "``extension_point``：扩展点的名称（大多数情况下，这将是 ``ament_package`` 或 ``rosidl_generate_interfaces`` 中的一个）"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:398
msgid "``package_name``: The name of the package containing the CMake file (i.e. the project name of the project where the file is written to)"
msgstr "``package_name``：包含CMake文件的包的名称（即文件所在的项目的项目名称）"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:400
msgid "``cmake_filename``: The CMake file executed when the extension point is run"
msgstr "``cmake_filename``：当运行扩展点时执行的CMake文件"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:404
msgid "It is possible to define custom extension points in a similar manner to ``ament_package`` and ``rosidl_generate_interfaces``, but this should hardly be necessary."
msgstr "可以以类似于 ``ament_package`` 和 ``rosidl_generate_interfaces`` 的方式定义自定义扩展点，但这几乎是不必要的。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:407
msgid "Adding extension points"
msgstr "添加扩展点"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:409
msgid "Very rarely, it might be interesting to define a new extension point to ament."
msgstr "非常罕见的情况下，定义一个新的扩展点到ament可能是有趣的。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:411
msgid "Extension points can be registered within a macro so that all extensions will be executed when the corresponding macro is called. To do so:"
msgstr "扩展点可以在宏中注册，以便在调用相应的宏时执行所有扩展。要实现这一点"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:414
msgid "Define and document a name for your extension (e.g. ``my_extension_point``), which is the name passed to the ``ament_register_extension`` macro when using the extension point."
msgstr "为您的扩展定义和记录一个名称（例如``my_extension_point``），这个名称将在使用扩展点时传递给``ament_register_extension``宏。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:416
msgid "In the macro/function which should execute the extensions call:"
msgstr "在应执行扩展调用的宏/函数中："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:422
msgid "Ament extensions work by defining a variable containing the name of the extension point and filling it with the macros to be executed. Upon calling ``ament_execute_extensions``, the scripts defined in the variable are then executed one after another."
msgstr "Ament扩展通过定义一个变量来工作，该变量包含扩展点的名称，并用要执行的宏填充该变量。在调用``ament_execute_extensions``时，然后按顺序执行变量中定义的脚本。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:426
msgid "Adding resources"
msgstr "添加资源"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:428
msgid "Especially when developing plugins or packages which allow plugins it is often essential to add resources to one ROS package from another (e.g. a plugin). Examples can be plugins for tools using the pluginlib."
msgstr "特别是在开发插件或允许插件的软件包时，通常需要从另一个ROS软件包（例如插件）中添加资源。示例可以是使用pluginlib的工具的插件。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:431
msgid "This can be achieved using the ament index (also called \"resource index\")."
msgstr "这可以通过使用ament索引（也称为“资源索引”）来实现。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:434
msgid "The ament index explained"
msgstr "解释ament索引"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:436
msgid "For details on the design and intentions, see `here <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`__"
msgstr "有关设计和意图的详细信息，请参阅`此处 <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`__"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:438
msgid "In principle, the ament index is contained in a folder within the install/share folder of your package. It contains shallow subfolders named after different types of resources. Within the subfolder, each package providing said resource is referenced by name with a \"marker file\". The file may contain whatever content necessary to obtain the resources, e.g. relative paths to the installation directories of the resource, it may also be simply empty."
msgstr "原则上，ament索引包含在您的软件包的install/share文件夹中的一个文件夹中。它包含以不同类型资源命名的浅层子文件夹。在子文件夹内，每个提供该资源的软件包都以“标记文件”的形式引用。该文件可以包含获取资源所需的任何内容，例如资源的安装目录的相对路径，也可以是空的。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:443
msgid "To give an example, consider providing display plugins for RViz: When providing RViz plugins in a project named ``my_rviz_displays`` which will be read by the pluginlib, you will provide a ``plugin_description.xml`` file, which will be installed and used by the pluginlib to load the plugins. To achieve this, the plugin_description.xml is registered as a resource in the resource_index via"
msgstr "举个例子，考虑为RViz提供显示插件：在名为``my_rviz_displays``的项目中提供RViz插件，这些插件将被pluginlib读取，您将提供一个``plugin_description.xml``文件，该文件将被安装和用于pluginlib来加载插件。为了实现这一点，通过资源索引将plugin_description.xml注册为资源"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:451
msgid "When running ``colcon build``, this installs a file ``my_rviz_displays`` into a subfolder ``rviz_common__pluginlib__plugin`` into the resource_index. Pluginlib factories within rviz_common will know to gather information from all folders named ``rviz_common__pluginlib__plugin`` for packages that export plugins. The marker file for pluginlib factories contains an install-folder relative path to the ``plugins_description.xml`` file (and the name of the library as marker file name). With this information, the pluginlib can load the library and know which plugins to load from the ``plugin_description.xml`` file."
msgstr "运行``colcon build``时，它会将文件``my_rviz_displays``安装到resource_index的子文件夹``rviz_common__pluginlib__plugin``中。rviz_common内的Pluginlib工厂将从所有名为``rviz_common__pluginlib__plugin``的文件夹中收集来自导出插件的软件包的信息。Pluginlib工厂的标记文件包含到``plugins_description.xml``文件的安装文件夹相对路径（以及库的名称作为标记文件名）。有了这些信息，pluginlib可以加载库并从``plugin_description.xml``文件中知道要加载哪些插件。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:456
msgid "As a second example, consider the possibility to let your own RViz plugins use your own custom meshes. Meshes get loaded at startup time so that the plugin owner does not have to deal with it, but this implies RViz has to know about the meshes. To achieve this, RViz provides a function:"
msgstr "作为第二个例子，考虑让您自己的RViz插件使用您自己的自定义网格的可能性。网格在启动时加载，这样插件所有者就不必处理它，但这意味着RViz必须知道这些网格。为了实现这一点，RViz提供了一个函数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:464
msgid "This registers the directories as an ogre_media resource in the ament index. In short, it installs a file named after the project which calls the function into a subfolder called ``rviz_ogre_media_exports``. The file contains the install folder relative paths to the directories listed in the macros. On startup time, RViz can now search for all folders called ``rviz_ogre_media_exports`` and load resources in all folders provided. These searches are done using ``ament_index_cpp`` (or ``ament_index_py`` for Python packages)."
msgstr "这将目录注册为ament索引中的ogre_media资源。简而言之，它会将名为该项目的文件安装到名为“rviz_ogre_media_exports”的子文件夹中，该文件调用该函数。该文件包含安装文件夹相对于宏中列出的目录的路径。在启动时，RViz现在可以搜索所有名为“rviz_ogre_media_exports”的文件夹，并加载所提供文件夹中的资源。这些搜索使用``ament_index_cpp``（对于Python软件包，使用``ament_index_py``）进行。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:470
msgid "In the following sections we will explore how to add your own resources to the ament index and provide best practices for doing so."
msgstr "在接下来的几节中，我们将探讨如何将您自己的资源添加到ament索引中，并提供最佳实践。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:473
msgid "Querying the ament index"
msgstr "查询ament索引"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:475
msgid "If necessary, it is possible to query the ament index for resources via CMake. To do so, there are three functions:"
msgstr "如有必要，可以通过CMake查询ament索引中的资源。为此，有三个函数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:478
msgid "``ament_index_has_resource``: obtain a prefix path to the resource if it exists with the following parameters:"
msgstr "``ament_index_has_resource``：如果资源存在，则使用以下参数获取资源的前缀路径："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:480
msgid "``var``: the output parameter: fill this variable with FALSE if the resource does not exist or the prefix path to the resource otherwise"
msgstr "``var``：输出参数：如果资源不存在，请将此变量填充为FALSE，否则填充为资源的前缀路径"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:482 ../../source/How-To-Guides/Ament-CMake-Documentation.rst:490 ../../source/How-To-Guides/Ament-CMake-Documentation.rst:502
msgid "``resource_type``: The type of the resource (e.g. ``rviz_common__pluginlib__plugin``)"
msgstr "``resource_type``：资源的类型（例如``rviz_common__pluginlib__plugin``）"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:484 ../../source/How-To-Guides/Ament-CMake-Documentation.rst:492
msgid "``resource_name``: The name of the resource which usually amounts to the name of the package having added the resource of type resource_type (e.g. ``rviz_default_plugins``)"
msgstr "``resource_name``: 资源的名称通常等于添加资源的包的名称，资源的类型为 resource_type（例如 ``rviz_default_plugins``）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:486
msgid "``ament_index_get_resource``: Obtain the content of a specific resource, i.e. the contents of the marker file in the ament index."
msgstr "``ament_index_get_resource``: 获取特定资源的内容，即 ament 索引中标记文件的内容。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:488
msgid "``var``: the output parameter: filled with the content of the resource marker file if it exists."
msgstr "``var``: 输出参数，如果存在，将填充资源标记文件的内容。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:494 ../../source/How-To-Guides/Ament-CMake-Documentation.rst:504
msgid "``PREFIX_PATH``: The prefix path to search for (usually, the default ``ament_index_get_prefix_path()`` will be enough)."
msgstr "``PREFIX_PATH``: 要搜索的前缀路径（通常，默认的 ``ament_index_get_prefix_path()`` 就足够了）。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:496
msgid "Note that ``ament_index_get_resource`` will throw an error if the resource does not exist, so it might be necessary to check using ``ament_index_has_resource``."
msgstr "请注意，如果资源不存在，``ament_index_get_resource`` 将抛出错误，因此可能需要使用 ``ament_index_has_resource`` 进行检查。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:498
msgid "``ament_index_get_resources``: Get all packages which registered resources of a specific type from the index"
msgstr "``ament_index_get_resources``：从索引中获取所有注册了特定类型资源的软件包"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:500
msgid "``var``: Output parameter: filled with a list of names of all packages which registered a resource of resource_type"
msgstr "``var``：输出参数，包含所有注册了指定资源类型的软件包名称列表"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:507
msgid "Adding to the ament index"
msgstr "添加到 ament 索引"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:509
msgid "Defining a resource requires two bits of information:"
msgstr "定义资源需要两个信息："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:511
msgid "a name for the resource which must be unique,"
msgstr "资源的名称必须是唯一的，"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:513
msgid "a layout of the marker file, which can be anything and could also be empty (this is true for instance for the \"package\" resource marking a ROS 2 package)"
msgstr "标记文件的布局可以是任意的，也可以是空的（例如，用于标记ROS 2包的“package”资源）"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:515
msgid "For the RViz mesh resource, the corresponding choices were:"
msgstr "对于RViz网格资源，对应的选择是："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:517
msgid "``rviz_ogre_media_exports`` as name of the resource,"
msgstr "``rviz_ogre_media_exports`` 作为资源的名称，"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:519
msgid "install path relative paths to all folders containing resources. This will already enable you to write the logic for using the corresponding resource in your package."
msgstr "安装路径相对于包含资源的所有文件夹的路径。这将使您能够编写使用包中相应资源的逻辑。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:521
msgid "To allow users to easily register resources for your package, you should furthermore provide macros or functions such as the pluginlib function or ``rviz_ogre_media_exports`` function."
msgstr "为了让用户能够轻松地为您的软件包注册资源，您还应该提供宏或函数，例如 pluginlib 函数或 ``rviz_ogre_media_exports`` 函数。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:523
msgid "To register a resource, use the ament function ``ament_index_register_resource``. This will create and install the marker files in the resource_index. As an example, the corresponding call for ``rviz_ogre_media_exports`` is the following:"
msgstr "要注册一个资源，请使用 ament 函数 ``ament_index_register_resource``。这将在资源索引中创建和安装标记文件。例如，对于 ``rviz_ogre_media_exports`` 的相应调用如下所示："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:531
msgid "This installs a file named like ``${PROJECT_NAME}`` into a folder ``rviz_ogre_media_exports`` into the resource_index with content given by variable ``${OGRE_MEDIA_RESOURCE_FILE}``. The macro has a number of parameters that can be useful:"
msgstr "这将安装一个名为 ``${PROJECT_NAME}`` 的文件到资源索引中的文件夹 ``rviz_ogre_media_exports`` 中，其内容由变量 ``${OGRE_MEDIA_RESOURCE_FILE}`` 提供。该宏有一些可能有用的参数："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:534
msgid "the first (unnamed) parameter is the name of the resource, which amounts to the name of the folder in the resource_index"
msgstr "第一个（无名称）参数是资源的名称，对应于资源索引中文件夹的名称"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:536
msgid "``CONTENT``: The content of the marker file as string. This could be a list of relative paths, etc. ``CONTENT`` cannot be used together with ``CONTENT_FILE``."
msgstr "``CONTENT``: 标记文件的内容作为字符串。这可以是一个相对路径列表等。``CONTENT`` 不能与 ``CONTENT_FILE`` 一起使用。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:538
msgid "``CONTENT_FILE``: The path to a file which will be use to create the marker file. The file can be a plain file or a template file expanded with ``configure_file()``. ``CONTENT_FILE`` cannot be used together with ``CONTENT``."
msgstr "``CONTENT_FILE``: 用于创建标记文件的文件的路径。该文件可以是一个普通文件或使用 ``configure_file()`` 扩展的模板文件。``CONTENT_FILE`` 不能与 ``CONTENT`` 一起使用。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:541
msgid "``PACKAGE_NAME``: The name of the package/library exporting the resource, which amounts to the name of the marker file. Defaults to ``${PROJECT_NAME}``."
msgstr "``PACKAGE_NAME``：导出资源的软件包/库的名称，即标记文件的名称。默认为 ``${PROJECT_NAME}``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:543
msgid "``AMENT_INDEX_BINARY_DIR``: The base path of the generated ament index. Unless really necessary, always use the default ``${CMAKE_BINARY_DIR}/ament_cmake_index``."
msgstr "``AMENT_INDEX_BINARY_DIR``：生成的ament索引的基路径。除非真的有必要，否则始终使用默认值 ``${CMAKE_BINARY_DIR}/ament_cmake_index``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:545
msgid "``SKIP_INSTALL``: Skip installing the marker file."
msgstr "``SKIP_INSTALL``：跳过安装标记文件。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:547
msgid "Since only one marker file exists per package, it is usually a problem if the CMake function/macro gets called twice by the same project. However, for large projects it might be best to split up calls registering resources."
msgstr "由于每个软件包只存在一个标记文件，如果同一项目调用了两次CMake函数/宏，则通常会出现问题。然而，对于大型项目，最好将调用注册资源的操作拆分为多次。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:550
msgid "Therefore, it is best practice to let a macro registering a resource such as ``register_rviz_ogre_media_exports.cmake`` only fill some variables. The real call to ``ament_index_register_resource`` can then be added within an ament extension to ``ament_package``. Since there must only ever be one call to ``ament_package`` per project, there will always only be one place where the resource gets registered. In the case of ``rviz_ogre_media_exports`` this amounts to the following strategy:"
msgstr "因此，最佳实践是让一个注册资源的宏，例如 ``register_rviz_ogre_media_exports.cmake``，仅填充一些变量。然后，在 ``ament_package`` 的扩展中添加对 ``ament_index_register_resource`` 的真实调用。由于每个项目只能有一次对 ``ament_package`` 的调用，因此资源的注册始终只有一个位置。对于 ``rviz_ogre_media_exports``，这就是以下策略："


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:555
msgid "The macro ``register_rviz_ogre_media_exports`` takes a list of folders and appends them to a variable called ``OGRE_MEDIA_RESOURCE_FILE``."
msgstr "宏 ``register_rviz_ogre_media_exports`` 接受一个文件夹列表，并将它们附加到名为 ``OGRE_MEDIA_RESOURCE_FILE`` 的变量中。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:557
msgid "Another macro called ``register_rviz_ogre_media_exports_hook`` calls ``ament_index_register_resource`` if ``${OGRE_MEDIA_RESOURCE_FILE}`` is non-empty."
msgstr "另一个名为 ``register_rviz_ogre_media_exports_hook`` 的宏在 ``${OGRE_MEDIA_RESOURCE_FILE}`` 非空时调用 ``ament_index_register_resource``。"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:559
msgid "The ``register_rviz_ogre_media_exports_hook.cmake`` file is registered as an ament extension in a third file ``register_rviz_ogre_media_exports_hook-extras.cmake`` via calling"
msgstr "通过调用，将 ``register_rviz_ogre_media_exports_hook.cmake`` 文件在第三个文件 ``register_rviz_ogre_media_exports_hook-extras.cmake`` 中注册为 ament 扩展"


#: ../../source/How-To-Guides/Ament-CMake-Documentation.rst:566
msgid "The files ``register_rviz_ogre_media_exports.cmake`` and ``register_rviz_ogre_media_exports_hook-extra.cmake`` are registered as ``CONFIG_EXTRA`` with ``ament_package()``."
msgstr "文件 ``register_rviz_ogre_media_exports.cmake`` 和 ``register_rviz_ogre_media_exports_hook-extra.cmake`` 在 ``ament_package()`` 中被注册为 ``CONFIG_EXTRA``。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:6
msgid "ament_cmake_python user documentation"
msgstr "ament_cmake_python 用户文档"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:8
msgid "``ament_cmake_python`` is a package that provides CMake functions for packages of the ``ament_cmake`` build type that contain Python code. See the :doc:`ament_cmake user documentation <Ament-CMake-Documentation>` for more information."
msgstr "``ament_cmake_python`` 是一个为包含 Python 代码的 ``ament_cmake`` 构建类型的软件包提供 CMake 函数的软件包。有关更多信息，请参阅 :doc:`ament_cmake 用户文档 <Ament-CMake-Documentation>`。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:13
msgid "Pure Python packages should use the ``ament_python`` build type in most cases. To create an ``ament_python`` package, see :doc:`Creating your first ROS 2 package <../Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`. ``ament_cmake_python`` should only be used in cases where that is not possible, like when mixing C/C++ and Python code."
msgstr "在大多数情况下，纯 Python 包应使用 ``ament_python`` 构建类型。要创建一个 ``ament_python`` 包，请参阅 :doc:`创建你的第一个 ROS 2 包 <../Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package>`。``ament_cmake_python`` 仅在不可能的情况下才应使用，例如在混合使用 C/C++ 和 Python 代码时。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:28
msgid "The outline of a package called \"my_project\" with the ``ament_cmake`` build type that uses ``ament_cmake_python`` looks like:"
msgstr "具有``ament_cmake``构建类型，并使用``ament_cmake_python``的名为\"my_project\"的软件包的概要如下："


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:40
msgid "The ``__init__.py`` file can be empty, but it is needed to `make Python treat the directory containing it as a package <https://docs.python.org/3/tutorial/modules.html#packages>`__. There can also be a ``src`` or ``include`` directory alongside the ``CMakeLists.txt`` which holds C/C++ code."
msgstr "``__init__.py``文件可以为空，但需要它来`使Python将包含它的目录视为软件包 <https://docs.python.org/3/tutorial/modules.html#packages>`__。在``CMakeLists.txt``旁边还可以有一个包含C/C++代码的``src``或``include``目录。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:44
msgid "Using ament_cmake_python"
msgstr "使用ament_cmake_python"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:46
msgid "The package must declare a dependency on ``ament_cmake_python`` in its ``package.xml``."
msgstr "该软件包必须在其``package.xml``中声明对``ament_cmake_python``的依赖关系。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:52 ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:100
msgid "The ``CMakeLists.txt`` should contain:"
msgstr "``CMakeLists.txt`` 应包含："


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:60
msgid "The argument to ``ament_python_install_package()`` is the name of the directory alongside the ``CMakeLists.txt`` that contains the Python file. In this case, it is ``my_project``, or ``${PROJECT_NAME}``."
msgstr "``ament_python_install_package()`` 的参数是与包含 Python 文件的 ``CMakeLists.txt`` 并列的目录的名称。在这种情况下，它是 ``my_project`` 或者 ``${PROJECT_NAME}``。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:65
msgid "Calling ``rosidl_generate_interfaces`` and ``ament_python_install_package`` in the same CMake project does not work. See this `Github issue <https://github.com/ros2/rosidl_python/issues/141>`_ for more info. It is best practice to instead separate out the message generation into a separate package."
msgstr "在同一个 CMake 项目中调用 ``rosidl_generate_interfaces`` 和 ``ament_python_install_package`` 是不起作用的。请参阅此 `Github 问题 <https://github.com/ros2/rosidl_python/issues/141>`_ 了解更多信息。最佳实践是将消息生成分离到一个单独的包中。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:69
msgid "Then, another Python package that correctly depends on ``my_project`` can use it as a normal Python module:"
msgstr "然后，另一个正确依赖于 ``my_project`` 的 Python 包可以将其作为普通的 Python 模块使用："


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:75
msgid "Assuming ``my_script.py`` contains a function called ``my_function()``."
msgstr "假设 ``my_script.py`` 包含一个名为 ``my_function()`` 的函数。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:78
msgid "Using ament_cmake_pytest"
msgstr "使用 ament_cmake_pytest"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:80
msgid "The package ``ament_cmake_pytest`` is used to make tests discoverable to ``cmake``. The package must declare a test dependency on ``ament_cmake_pytest`` in its ``package.xml``."
msgstr "包 ``ament_cmake_pytest`` 用于使测试在 ``cmake`` 中可被发现。包必须在其 ``package.xml`` 中声明对 ``ament_cmake_pytest`` 的测试依赖。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:87
msgid "Say the package has a file structure like below, with tests in the ``tests`` folder."
msgstr "假设该包的文件结构如下所示，其中的测试位于 ``tests`` 文件夹中。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:121
msgid "Compared to the usage of ament_python, which supports automatic test discovery, ament_cmake_pytest must be called with the path to each test file. The timeout can be reduced as needed."
msgstr "与支持自动测试发现的ament_python的使用相比，ament_cmake_pytest必须使用每个测试文件的路径进行调用。超时时间可以根据需要缩短。"


#: ../../source/How-To-Guides/Ament-CMake-Python-Documentation.rst:124
msgid "Now, you can invoke your tests with the :doc:`standard colcon testing commands <../Tutorials/Intermediate/Testing/CLI>`."
msgstr "现在，您可以使用:doc:`标准的colcon测试命令<../Tutorials/Intermediate/Testing/CLI>`来调用您的测试。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:2
msgid "Building ROS 2 with tracing instrumentation"
msgstr "使用跟踪工具构建ROS 2"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:8
msgid "This guide shows you how to build ROS 2 with the tracing instrumentation provided by ``ros2_tracing``. For more information, see `the repository <https://github.com/ros2/ros2_tracing>`__."
msgstr "本指南介绍了如何使用``ros2_tracing``提供的跟踪工具构建ROS 2。更多信息请参见`存储库 <https://github.com/ros2/ros2_tracing>`__。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:11
msgid "Instrumentation is included in the ROS 2 source code. However, if using the binaries or when building from source, the instrumentation does not actually trigger tracepoints by default. To get the tracepoints, the LTTng tracer needs to be installed, and then part of ROS 2 needs to be (re)built from source."
msgstr "ROS 2源代码中包含了工具仪器。然而，如果使用二进制文件或从源代码构建时，默认情况下工具仪器不会触发跟踪点。要获取跟踪点，需要安装LTTng跟踪器，然后重新从源代码构建ROS 2的一部分。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:17
msgid "This guide only applies to Linux systems and assumes that Ubuntu is used."
msgstr "本指南仅适用于Linux系统，并假设使用的是Ubuntu。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:20 ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:15 ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:18 ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:17
msgid "Prerequisites"
msgstr "先决条件"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:22
msgid "Set up your system to build ROS 2 from source. See :doc:`the source installation page <../Installation/Alternatives/Ubuntu-Development-Setup>` for more information."
msgstr "设置您的系统以从源代码构建ROS 2。有关更多信息，请参阅:doc:`源安装页面 <../Installation/Alternatives/Ubuntu-Development-Setup>`。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:26
msgid "Installing the tracer"
msgstr "安装追踪器"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:28
msgid "Install the `LTTng tracer <https://lttng.org/docs>`__ and related tools and dependencies."
msgstr "安装 `LTTng追踪器 <https://lttng.org/docs>`__ 及其相关工具和依赖项。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:35
msgid "This only installs the LTTng userspace tracer, and not the LTTng kernel tracer, since it is not needed to trace ROS 2 applications."
msgstr "这只安装了LTTng用户空间追踪器，而不安装LTTng内核追踪器，因为它不需要跟踪ROS 2应用程序。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:38
msgid "Building"
msgstr "构建中"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:40
msgid "This step depends on whether you are building ROS 2 from source or using ROS 2 binaries."
msgstr "这一步取决于您是从源代码构建ROS 2还是使用ROS 2二进制文件。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:43
msgid "With source installation"
msgstr "使用源代码安装"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:45
msgid "If you have already :doc:`built ROS 2 from source <../Installation/Alternatives/Ubuntu-Development-Setup>` before installing LTTng, you will need to re-build at least up to the ``tracetools`` package:"
msgstr "如果在安装LTTng之前已经 :doc:`从源代码构建了ROS 2 <../Installation/Alternatives/Ubuntu-Development-Setup>`，您将需要重新构建至少到 ``tracetools`` 软件包："


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:53
msgid "With binary installation"
msgstr "使用二进制安装"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:55
msgid "If you rely on the ROS 2 binaries (:doc:`Debian packages <../Installation/Ubuntu-Install-Debians>` or :doc:`\"fat\" archive <../Installation/Alternatives/Ubuntu-Install-Binary>`), you will need to clone the ``ros2_tracing`` repository into your workspace and build at least up to the ``tracetools`` package:"
msgstr "如果您依赖于ROS 2二进制文件（:doc:`Debian packages <../Installation/Ubuntu-Install-Debians>`或:doc:`\"fat\" archive <../Installation/Alternatives/Ubuntu-Install-Binary>`），您需要将``ros2_tracing``存储库克隆到您的工作空间中，并至少构建到``tracetools``包为止："


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:65
msgid "Validating"
msgstr "正在验证"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:67
msgid "Source and validate that tracing is enabled:"
msgstr "源代码并验证跟踪已启用："


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:75
msgid "It should print out:"
msgstr "它应该打印出："


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:81
msgid "If something else is printed, then something went wrong."
msgstr "如果打印出其他内容，那么出现了错误。"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:84
msgid "Disabling tracing"
msgstr "禁用跟踪"


#: ../../source/How-To-Guides/Building-ROS-2-with-Tracing-Instrumentation.rst:86
msgid "If the LTTng userspace tracer is installed and found when building ``tracetools``, tracing will be automatically enabled. Alternatively, to build and completely remove both the tracepoints and the tracing instrumentation from ROS 2, set the ``TRACETOOLS_DISABLED`` CMake option to ``ON``:"
msgstr "如果在构建``tracetools``时安装并找到了LTTng用户空间跟踪器，将自动启用跟踪。或者，要从ROS 2中构建并完全删除跟踪点和跟踪工具，将``TRACETOOLS_DISABLED`` CMake选项设置为``ON``："


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:6
msgid "Building a custom Debian package"
msgstr "构建自定义的Debian软件包"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:8
msgid "Many Ubuntu users install ROS 2 on their system by installing :doc:`debian packages <../Installation/Ubuntu-Install-Debians>`. This guide gives a short set of instructions to build local, custom Debian packages."
msgstr "许多Ubuntu用户通过安装:doc:`Debian软件包 <../Installation/Ubuntu-Install-Debians>`在其系统上安装ROS 2。本指南提供了一组简短的说明，用于构建本地的自定义Debian软件包。"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:17
msgid "To successfully build a custom package, all of the dependencies of the package to be built must be available locally or in rosdep. Additionally, all of the dependencies of the package should be properly declared in the ``package.xml`` file of the package."
msgstr "为了成功构建自定义软件包，构建软件包的所有依赖项必须在本地或rosdep中可用。此外，软件包的所有依赖项应在软件包的``package.xml``文件中正确声明。"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:21 ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:24 ../../source/How-To-Guides/Releasing/First-Time-Release.rst:27 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:16
msgid "Install dependencies"
msgstr "安装依赖项"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:23
msgid "Run the following command to install utilities needed for the build:"
msgstr "运行以下命令安装构建所需的实用工具："


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:30
msgid "Initialize rosdep"
msgstr "初始化 rosdep"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:32
msgid "Initialize the rosdep database by calling:"
msgstr "通过调用以下命令来初始化 rosdep 数据库："


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:39
msgid "Note that the ``rosdep init`` command may fail if it has already been initialized in the past; this can safely be ignored."
msgstr "请注意，如果 rosdep 在过去已经被初始化过，``rosdep init`` 命令可能会失败，但可以安全地忽略这个错误。"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:42
msgid "Build the debian from the package"
msgstr "从软件包中构建 Debian 包"


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:44
msgid "Run the following commands to build the debian:"
msgstr "运行以下命令以构建Debian："


#: ../../source/How-To-Guides/Building-a-Custom-Debian-Package.rst:52
msgid "Assuming that all required dependencies are available and that compilation succeeds, the new package will be available in the parent directory of this directory."
msgstr "假设所有所需的依赖项都可用且编译成功，新软件包将在此目录的上级目录中可用。"


#: ../../source/How-To-Guides/Cross-compilation.rst:7
msgid "Cross-compilation"
msgstr "交叉编译"


#: ../../source/How-To-Guides/Cross-compilation.rst:13
msgid "For background information on cross-compilation, see the :doc:`conceptual article <../Concepts/About-Cross-Compilation>`."
msgstr "有关交叉编译的背景信息，请参阅 :doc:`概念文章 <../Concepts/About-Cross-Compilation>`。"


#: ../../source/How-To-Guides/Cross-compilation.rst:15
msgid "This document provides you with details on how to cross-compile the ROS 2 software stack as well as provide examples for cross-compiling to systems based on the Arm cores."
msgstr "本文档为您提供有关如何交叉编译ROS 2软件栈的详细信息，以及提供基于Arm核心的系统的交叉编译示例。"


#: ../../source/How-To-Guides/Cross-compilation.rst:18
msgid "cross_compile tool"
msgstr "交叉编译工具"


#: ../../source/How-To-Guides/Cross-compilation.rst:20
msgid "Instructions to use the tool are in the `cross_compile package <https://github.com/ros-tooling/cross_compile>`__."
msgstr "使用该工具的说明在 `cross_compile package <https://github.com/ros-tooling/cross_compile>`__ 中。"


#: ../../source/How-To-Guides/Cross-compilation.rst:23
msgid "Legacy tool instructions"
msgstr "传统工具说明"


#: ../../source/How-To-Guides/Cross-compilation.rst:25
msgid "Follow the steps below only if you are using the old version (release `0.0.1 <https://github.com/ros-tooling/cross_compile/releases/tag/0.0.1>`__) of the cross-compile tool. For all other purposes, follow the `cross_compile <https://github.com/ros-tooling/cross_compile>`__ package documentation."
msgstr "只有在使用旧版本（发布版 `0.0.1 <https://github.com/ros-tooling/cross_compile/releases/tag/0.0.1>`__）的交叉编译工具时才按照以下步骤操作。对于其他情况，请参考 `cross_compile <https://github.com/ros-tooling/cross_compile>`__ 包文档。"


#: ../../source/How-To-Guides/Cross-compilation.rst:29
msgid "Although ROS 2 is a rich software stack with a number of dependencies, it primarily uses two different types of packages:"
msgstr "尽管ROS 2是一个具有多个依赖项的丰富软件堆栈，但它主要使用两种不同类型的软件包："


#: ../../source/How-To-Guides/Cross-compilation.rst:28
msgid "Python based software, which requires no cross-compilation."
msgstr "基于Python的软件，不需要进行交叉编译。"


#: ../../source/How-To-Guides/Cross-compilation.rst:29
msgid "CMake based software, which provides a mechanism to do cross-compilation."
msgstr "基于CMake的软件，提供了进行交叉编译的机制。"


#: ../../source/How-To-Guides/Cross-compilation.rst:31
msgid "Furthermore, the ROS 2 software stack is built with `Colcon <https://github.com/colcon/colcon-core>`__ which provides a mechanism to forward parameters to the CMake instance used for the individual build of each package/library that is part of the ROS 2 distribution."
msgstr "此外，ROS 2 软件栈使用 `Colcon <https://github.com/colcon/colcon-core>`__ 构建，它提供了一种机制，可以将参数传递给用于构建 ROS 2 发行版中每个包/库的单独构建的 CMake 实例。"


#: ../../source/How-To-Guides/Cross-compilation.rst:33
msgid "When building ROS 2 natively, the developer is required to download all the dependencies (e.g. Python and other libraries) before compiling the packages that are part of the ROS 2 distribution. When cross-compiling, the same approach is required. The developer must first have the target system's filesystem with all dependencies already installed."
msgstr "在本地构建 ROS 2 时，开发人员需要在编译 ROS 2 发行版中的包之前下载所有的依赖项（例如 Python 和其他库）。在交叉编译时，也需要相同的方法。开发人员必须首先拥有目标系统的文件系统，并已安装所有的依赖项。"


#: ../../source/How-To-Guides/Cross-compilation.rst:35
msgid "The next sections of this document explain in detail the use of `cmake-toolchains <https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html>`__ and the `CMAKE_SYSROOT <https://cmake.org/cmake/help/latest/variable/CMAKE_SYSROOT.html>`__ feature to cross-compile ROS 2."
msgstr "本文档的后续部分详细说明了使用 `cmake-toolchains <https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html>`__ 和 `CMAKE_SYSROOT <https://cmake.org/cmake/help/latest/variable/CMAKE_SYSROOT.html>`__ 功能进行 ROS 2 交叉编译的方法。"


#: ../../source/How-To-Guides/Cross-compilation.rst:38
msgid "CMake toolchain-file"
msgstr "CMake 工具链文件"


#: ../../source/How-To-Guides/Cross-compilation.rst:40
msgid "A CMake toolchain-file is a file which defines variables to configure CMake for cross-compilation. The basic entries are:"
msgstr "CMake工具链文件是用于配置CMake进行交叉编译的文件，它定义了变量。基本条目如下："


#: ../../source/How-To-Guides/Cross-compilation.rst:42
msgid "``CMAKE_SYSTEM_NAME``: the target platform, e.g. ``linux``"
msgstr "``CMAKE_SYSTEM_NAME``：目标平台，例如``linux``"


#: ../../source/How-To-Guides/Cross-compilation.rst:43
msgid "``CMAKE_SYSTEM_PROCESSOR``: the target architecture, e.g. ``aarch64`` or ``arm``"
msgstr "``CMAKE_SYSTEM_PROCESSOR``：目标架构，例如``aarch64``或``arm``"


#: ../../source/How-To-Guides/Cross-compilation.rst:44
msgid "``CMAKE_SYSROOT``: the path to the target file-system"
msgstr "``CMAKE_SYSROOT``：目标文件系统的路径"


#: ../../source/How-To-Guides/Cross-compilation.rst:45
msgid "``CMAKE_C_COMPILER``: the C cross-compiler, e.g. ``aarch64-linux-gnu-gcc``"
msgstr "``CMAKE_C_COMPILER``：C交叉编译器，例如``aarch64-linux-gnu-gcc``"


#: ../../source/How-To-Guides/Cross-compilation.rst:46
msgid "``CMAKE_CXX_COMPILER``: the C++ cross-compiler, e.g. ``aarch64-linux-gnu-g++``"
msgstr "``CMAKE_CXX_COMPILER``：C++交叉编译器，例如``aarch64-linux-gnu-g++``"


#: ../../source/How-To-Guides/Cross-compilation.rst:47
msgid "``CMAKE_FIND_ROOT_PATH``: an alternative path used by the ``find_*`` command to find the file-system"
msgstr "``CMAKE_FIND_ROOT_PATH``：``find_*``命令用来查找文件系统的替代路径"


#: ../../source/How-To-Guides/Cross-compilation.rst:49
msgid "When cross-compiling ROS 2, the following options are required to be set:"
msgstr "在进行ROS 2交叉编译时，需要设置以下选项："


#: ../../source/How-To-Guides/Cross-compilation.rst:51
msgid "``CMAKE_FIND_ROOT_PATH``: the alternative path used by the ``find_*`` command, use it to specify the path to ROS 2 ``/install`` folder"
msgstr "``CMAKE_FIND_ROOT_PATH``：``find_*``命令使用的替代路径，用于指定ROS 2 ``/install``文件夹的路径"


#: ../../source/How-To-Guides/Cross-compilation.rst:52
msgid "``CMAKE_FIND_ROOT_PATH_MODE_*``: the search strategy for program,package,library, and include, usually: ``NEVER`` (look on the host-fs), ``ONLY`` (look on sysroot), and ``BOTH`` (look on both sysroot and host-fs)"
msgstr "``CMAKE_FIND_ROOT_PATH_MODE_*``：程序、包、库和包含文件的搜索策略，通常有：``NEVER``（在主机文件系统上查找）、``ONLY``（在sysroot上查找）和``BOTH``（在sysroot和主机文件系统上都查找）"


#: ../../source/How-To-Guides/Cross-compilation.rst:53
msgid "``PYTHON_SOABI``: the index name of the python libraries generated by ROS 2, e.g. ``cpython-36m-aarch64-linux-gnu``"
msgstr "``PYTHON_SOABI``：由ROS 2生成的Python库的索引名称，例如``cpython-36m-aarch64-linux-gnu``"


#: ../../source/How-To-Guides/Cross-compilation.rst:54
msgid "``THREADS_PTHREAD_ARG \"0\" CACHE STRING \"Result from TRY_RUN\" FORCE``: Force the result of the ``TRY_RUN`` cmd to 0 (success) because binaries can not run on the host system."
msgstr "``THREADS_PTHREAD_ARG \"0\" CACHE STRING \"Result from TRY_RUN\" FORCE``：将``TRY_RUN``命令的结果强制为0（成功），因为二进制文件无法在主机系统上运行。"


#: ../../source/How-To-Guides/Cross-compilation.rst:56
msgid "The toolchain-file is provided to CMake with the ``-DCMAKE_TOOLCHAIN_FILE=path/to/file`` parameter. This will also set the ``CMAKE_CROSSCOMPILING`` variable to ``true`` which can be used by the software being built."
msgstr "将工具链文件提供给CMake时，使用``-DCMAKE_TOOLCHAIN_FILE=path/to/file``参数。这还将把``CMAKE_CROSSCOMPILING``变量设置为``true``，软件构建时可以使用该变量。"


#: ../../source/How-To-Guides/Cross-compilation.rst:58
msgid "The ``CMAKE_SYSROOT`` is particularly important for ROS 2 as the packages need many dependencies (e.g. python, openssl, opencv, poco, eigen3, ...). Setting ``CMAKE_SYSROOT`` to a target file-system with all the dependencies installed on it will allow CMake to find them during the cross-compilation."
msgstr "对于ROS 2来说，``CMAKE_SYSROOT``非常重要，因为软件包需要许多依赖项（例如python、openssl、opencv、poco、eigen3等）。将``CMAKE_SYSROOT``设置为安装了所有依赖项的目标文件系统，将允许CMake在交叉编译过程中找到它们。"


#: ../../source/How-To-Guides/Cross-compilation.rst:61
msgid "You can find more information on the CMake `documentation <https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html>`__ page."
msgstr "您可以在CMake的 `文档 <https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html>`__ 页面上找到更多信息。"


#: ../../source/How-To-Guides/Cross-compilation.rst:63
msgid "When downloading the ROS 2 source code, a generic toolchain-file is available in the repository `ros-tooling/cross_compile/cmake-toolchains <https://github.com/ros-tooling/cross_compile>`__ which can be downloaded separately. Further examples on using it can be found on the `Cross-compiling examples for Arm`_ section."
msgstr "在下载ROS 2源代码时，存储库`ros-tooling/cross_compile/cmake-toolchains <https://github.com/ros-tooling/cross_compile>`__中提供了一个通用的工具链文件，可以单独下载。有关如何使用它的更多示例，请参阅`Cross-compiling examples for Arm`_部分。"


#: ../../source/How-To-Guides/Cross-compilation.rst:66
msgid "Target file-system"
msgstr "目标文件系统"


#: ../../source/How-To-Guides/Cross-compilation.rst:68
msgid "As mentioned previously, ROS 2 requires different libraries which needs to be provided to cross-compile."
msgstr "如前所述，ROS 2需要不同的库文件来进行交叉编译。"


#: ../../source/How-To-Guides/Cross-compilation.rst:73
msgid "There are a number of ways to obtain the file-system:"
msgstr "获取文件系统有多种方式："


#: ../../source/How-To-Guides/Cross-compilation.rst:71
msgid "downloading a pre-built image"
msgstr "下载预构建的映像"


#: ../../source/How-To-Guides/Cross-compilation.rst:72
msgid "installing the dependencies on the target and exporting the file-system (e.g. with sshfs)"
msgstr "在目标设备上安装依赖项并导出文件系统（例如使用sshfs）"


#: ../../source/How-To-Guides/Cross-compilation.rst:73
msgid "using qemu + docker (or chroot) to generate the file-system on the host machine."
msgstr "使用qemu + docker（或chroot）在主机上生成文件系统。"


#: ../../source/How-To-Guides/Cross-compilation.rst:75
msgid "You can find information on how to use Docker + qemu on the next `Cross-compiling examples for Arm`_ section."
msgstr "您可以在接下来的`Cross-compiling examples for Arm`_部分找到有关如何使用Docker + qemu的信息。"


#: ../../source/How-To-Guides/Cross-compilation.rst:78
msgid "Build process"
msgstr "构建过程"


#: ../../source/How-To-Guides/Cross-compilation.rst:80
msgid "The build process is similar to native compilation. The only difference is an extra argument to ``Colcon`` to specify the ``toolchain-file``:"
msgstr "构建过程类似于本地编译，唯一的区别是给 ``Colcon`` 添加了一个额外的参数来指定 ``toolchain-file``："


#: ../../source/How-To-Guides/Cross-compilation.rst:89
msgid "The ``toolchain-file`` provide to CMake the information of the ``cross-compiler`` and the ``target file-system``. ``Colcon`` will call CMake with the given toolchain-file on every package of ROS 2."
msgstr "``toolchain-file`` 提供给 CMake 有关 ``交叉编译器`` 和 ``目标文件系统`` 的信息。``Colcon`` 将在 ROS 2 的每个软件包上使用给定的 toolchain-file 来调用 CMake。"


#: ../../source/How-To-Guides/Cross-compilation.rst:93
msgid "Cross-compiling examples for Arm"
msgstr "为 Arm 进行交叉编译示例"


#: ../../source/How-To-Guides/Cross-compilation.rst:94
msgid "After :doc:`downloading the ROS 2 source code <../Installation/Alternatives/Ubuntu-Development-Setup>`, you can add cross-compilation assets to the workspace via ``git clone https://github.com/ros-tooling/cross_compile.git -b 0.0.1 src/ros2/cross_compile``. These are working examples on how to cross-compile for Arm cores."
msgstr "在 :doc:`下载 ROS 2 源代码 <../Installation/Alternatives/Ubuntu-Development-Setup>` 后，您可以通过 ``git clone https://github.com/ros-tooling/cross_compile.git -b 0.0.1 src/ros2/cross_compile`` 将交叉编译资产添加到工作空间。这些是关于如何为 Arm 内核进行交叉编译的可行示例。"


#: ../../source/How-To-Guides/Cross-compilation.rst:98
msgid "The following targets are supported:"
msgstr "支持以下目标："


#: ../../source/How-To-Guides/Cross-compilation.rst:97
msgid "Ubuntu-arm64: To be used with any ARMv8-A based system."
msgstr "Ubuntu-arm64：适用于任何基于ARMv8-A的系统。"


#: ../../source/How-To-Guides/Cross-compilation.rst:98
msgid "Ubuntu-armhf: To be used with any modern ARMv7-A based system."
msgstr "Ubuntu-armhf：适用于任何现代基于ARMv7-A的系统。"


#: ../../source/How-To-Guides/Cross-compilation.rst:105
msgid "These are the main steps:"
msgstr "以下是主要步骤："


#: ../../source/How-To-Guides/Cross-compilation.rst:101
msgid "Installing development tools"
msgstr "安装开发工具"


#: ../../source/How-To-Guides/Cross-compilation.rst:102
msgid "Downloading ROS 2 source code"
msgstr "下载 ROS 2 源代码"


#: ../../source/How-To-Guides/Cross-compilation.rst:103
msgid "Downloading the ROS 2 cross-compilation assets"
msgstr "下载 ROS 2 交叉编译资产"


#: ../../source/How-To-Guides/Cross-compilation.rst:104
msgid "Preparing the sysroot"
msgstr "准备 sysroot"


#: ../../source/How-To-Guides/Cross-compilation.rst:105
msgid "Cross-compiling the ROS 2 software stack"
msgstr "交叉编译ROS 2软件栈"


#: ../../source/How-To-Guides/Cross-compilation.rst:107
msgid "The next sections explains in detail each of these steps. For a quick-setup, have a look at the `Automated Cross-compilation`_."
msgstr "下面的章节详细解释了每个步骤。如果需要快速设置，请参阅`Automated Cross-compilation`_。"


#: ../../source/How-To-Guides/Cross-compilation.rst:110
msgid "These steps were tested on an Ubuntu 18.04 (Bionic)"
msgstr "这些步骤在Ubuntu 18.04（Bionic）上进行了测试"


#: ../../source/How-To-Guides/Cross-compilation.rst:113
msgid "1. Install development tools"
msgstr "1. 安装开发工具"


#: ../../source/How-To-Guides/Cross-compilation.rst:115
msgid "This step is similar to when building natively. The difference is that some of the libraries and tools are not required because they will be in the sysroot instead. The following packages are required"
msgstr "这个步骤与本地构建类似。不同之处在于一些库和工具不需要，因为它们将在sysroot中。需要以下软件包："


#: ../../source/How-To-Guides/Cross-compilation.rst:134
msgid "You can install vcstool and colcon-common-extensions via pip. This means you are not required to add extra apt repositories."
msgstr "您可以使用pip安装vcstool和colcon-common-extensions。这意味着您不需要添加额外的apt仓库。"


#: ../../source/How-To-Guides/Cross-compilation.rst:137
msgid "Docker is used to build the target environment. Follow the official `documentation <https://docs.docker.com/install/linux/docker-ce/ubuntu/>`__ for the installation."
msgstr "Docker用于构建目标环境。请按照官方 `文档 <https://docs.docker.com/install/linux/docker-ce/ubuntu/>`__ 进行安装。"


#: ../../source/How-To-Guides/Cross-compilation.rst:140
msgid "2. Download ROS 2 source code"
msgstr "2. 下载ROS 2源代码"


#: ../../source/How-To-Guides/Cross-compilation.rst:142
msgid "Then create a workspace and download the ROS 2 source code:"
msgstr "然后创建一个工作空间并下载ROS 2源代码："


#: ../../source/How-To-Guides/Cross-compilation.rst:154
msgid "3. Prepare the sysroot"
msgstr "3. 准备 sysroot"


#: ../../source/How-To-Guides/Cross-compilation.rst:156
msgid "Build an arm Ubuntu image with all the ROS 2 dependencies using Docker and qemu: Copy the ``qemu-static`` binary to the workspace. It will be used to install the ROS 2 dependencies on the target file-system with docker."
msgstr "使用Docker和qemu构建带有所有ROS 2依赖项的arm Ubuntu镜像：将``qemu-static``二进制文件复制到工作空间。它将用于使用Docker在目标文件系统上安装ROS 2依赖项。"


#: ../../source/How-To-Guides/Cross-compilation.rst:165
msgid "The standard :doc:`setup <../Installation/Alternatives/Ubuntu-Development-Setup>` process of ROS 2 is run inside an arm docker. This is possible thanks to ``qemu-static``, which will emulate an arm machine. The base image used is an Ubuntu Bionic from Docker Hub."
msgstr "ROS 2的标准:doc:`设置 <../Installation/Alternatives/Ubuntu-Development-Setup>`过程在arm docker内运行。这得益于``qemu-static``，它将模拟一个arm机器。使用的基础镜像是来自Docker Hub的Ubuntu Bionic。"


#: ../../source/How-To-Guides/Cross-compilation.rst:172
msgid "Export the resulting container to a tarball and extract it:"
msgstr "将生成的容器导出为tarball文件并解压缩："


#: ../../source/How-To-Guides/Cross-compilation.rst:181
msgid "This container can be used later as virtual target to run the created file-system and run the demo code."
msgstr "此容器稍后可用作虚拟目标，以运行创建的文件系统和运行演示代码。"


#: ../../source/How-To-Guides/Cross-compilation.rst:184
msgid "4. Build"
msgstr "4. 构建"


#: ../../source/How-To-Guides/Cross-compilation.rst:186
msgid "Set the variables used by the generic toolchain-file"
msgstr "设置通用工具链文件使用的变量"


#: ../../source/How-To-Guides/Cross-compilation.rst:199
msgid "The following packages still cause errors during the cross-compilation (under investigation) and must be disabled for now."
msgstr "以下软件包在交叉编译过程中仍然导致错误（正在调查中），现在必须禁用它们。"


#: ../../source/How-To-Guides/Cross-compilation.rst:207
msgid "The ``Poco`` pre-built has a known issue where it is searching for ``libz`` and ``libpcre`` on the host system instead of SYSROOT. As a workaround for the moment, please link both libraries into the the host's file-system."
msgstr "预构建的 ``Poco`` 存在一个已知问题，它在主机系统上搜索 ``libz`` 和 ``libpcre`` 而不是 SYSROOT。暂时的解决方法是，请将这两个库链接到主机的文件系统中。"


#: ../../source/How-To-Guides/Cross-compilation.rst:216
msgid "Then, start a build with colcon specifying the toolchain-file:"
msgstr "然后，使用 colcon 指定工具链文件启动构建："


#: ../../source/How-To-Guides/Cross-compilation.rst:229
msgid "Done! The install and build directories will contain the cross-compiled assets."
msgstr "完成！安装目录和构建目录将包含交叉编译的资源。"


#: ../../source/How-To-Guides/Cross-compilation.rst:232
msgid "Automated Cross-compilation"
msgstr "自动交叉编译"


#: ../../source/How-To-Guides/Cross-compilation.rst:234
msgid "All the steps above are also included into a Dockerfile and can be used for automation/CI."
msgstr "上述所有步骤也包含在一个Dockerfile中，可以用于自动化/持续集成。"


#: ../../source/How-To-Guides/Cross-compilation.rst:236
msgid "First, download the dockerfile and build the image:"
msgstr "首先，下载Dockerfile并构建镜像："


#: ../../source/How-To-Guides/Cross-compilation.rst:243
msgid "Now run the image with: (it will take a while !)"
msgstr "现在运行镜像：（这将需要一些时间！）"


#: ../../source/How-To-Guides/Cross-compilation.rst:252
msgid "..note:: The -v /var/run/docker.sock allow us to use Docker inside Docker."
msgstr "..注意:: 使用 -v /var/run/docker.sock 允许我们在 Docker 中使用 Docker。"


#: ../../source/How-To-Guides/Cross-compilation.rst:254
msgid "The result of the build will be inside the ``ros2_ws`` directory, which can be exported with:"
msgstr "构建的结果将在 ``ros2_ws`` 目录中，可以使用以下命令导出："


#: ../../source/How-To-Guides/Cross-compilation.rst:261
msgid "Cross-compiling against a pre-built ROS 2"
msgstr "针对预构建的 ROS 2 进行交叉编译"


#: ../../source/How-To-Guides/Cross-compilation.rst:263
msgid "It is possible to cross-compile your packages against a pre-built ROS 2. The steps are similar to the previous `Cross-compiling examples for Arm`_ section, with the following modifications:"
msgstr "您可以将您的软件包与预构建的 ROS 2 进行交叉编译。步骤与之前的“为 ARM 进行交叉编译示例”_ 部分相似，只需进行以下修改："


#: ../../source/How-To-Guides/Cross-compilation.rst:265
msgid "Instead of downloading the ROS 2 stack, just populate your workspace with your package (ros2 examples on this case) and the cross-compilation assets:"
msgstr "不需要下载ROS 2堆栈，只需将您的软件包（在此示例中是ros2 examples）和交叉编译资产填充到您的工作空间中："


#: ../../source/How-To-Guides/Cross-compilation.rst:275
msgid "Generate and export the file-system as described in `3. Prepare the sysroot`_, but with the provided ``Dockerfile_ubuntu_arm64_prebuilt``. These ``_prebuilt`` Dockerfile will use the :doc:`binary packages <../Installation/Ubuntu-Install-Debians>` to install ROS 2 instead of building from source."
msgstr "按照`3. 准备sysroot`_中所述的方法生成和导出文件系统，但使用提供的``Dockerfile_ubuntu_arm64_prebuilt``。这些``_prebuilt`` Dockerfile将使用:doc:`二进制包 <../Installation/Ubuntu-Install-Debians>`来安装ROS 2，而不是从源代码构建。"


#: ../../source/How-To-Guides/Cross-compilation.rst:277
msgid "Modify the environment variable ``ROS2_INSTALL_PATH`` to point to the installation directory:"
msgstr "修改环境变量``ROS2_INSTALL_PATH``，指向安装目录："


#: ../../source/How-To-Guides/Cross-compilation.rst:283
msgid "Source the ``setup.bash`` script on the target file-system:"
msgstr "在目标文件系统上调用``setup.bash``脚本："


#: ../../source/How-To-Guides/Cross-compilation.rst:289
msgid "Then, start a build with ``Colcon`` specifying the ``toolchain-file``:"
msgstr "然后，使用``Colcon``指定``toolchain-file``来开始构建："


#: ../../source/How-To-Guides/Cross-compilation.rst:301
msgid "Run on the target"
msgstr "在目标设备上运行"


#: ../../source/How-To-Guides/Cross-compilation.rst:303
msgid "Copy the file-system on your target or use the previously built docker image:"
msgstr "将文件系统复制到目标设备上或使用先前构建的 Docker 镜像："


#: ../../source/How-To-Guides/Cross-compilation.rst:309
msgid "Source the environment:"
msgstr "加载环境："


#: ../../source/How-To-Guides/Cross-compilation.rst:315
msgid "Run some of the C++ or python examples:"
msgstr "运行一些C++或Python示例："


#: ../../source/How-To-Guides/DDS-tuning.rst:7
msgid "DDS tuning information"
msgstr "DDS调优信息"


#: ../../source/How-To-Guides/DDS-tuning.rst:9
msgid "This page provides some guidance on parameter tunings that were found to address issues faced while using various DDS implementations on Linux in real-world situations. It is possible that the issues we identified on Linux or while using one vendor may occur for other platforms and vendors not documented here."
msgstr "本页面提供了一些参数调优的指导，这些调优参数被发现可以解决在真实环境中使用Linux上的各种DDS实现时遇到的问题。我们在Linux或使用某个供应商时发现的问题可能也会出现在其他平台和未在此处记录的供应商上。"


#: ../../source/How-To-Guides/DDS-tuning.rst:12
msgid "The recommendations below are starting points for tuning; they worked for specific systems and environments, but the tuning may vary depending on a number of factors. You may need to increase or decrease values while debugging relative to factors like message size, network topology, etc."
msgstr "以下建议是调优的起点；它们适用于特定的系统和环境，但调优可能会根据多个因素而有所不同。在调试过程中，您可能需要根据消息大小、网络拓扑等因素增加或减少值。"


#: ../../source/How-To-Guides/DDS-tuning.rst:15
msgid "It is important to recognize that tuning parameters can come at a cost to resources, and may affect parts of your system beyond the scope of the desired improvements. The benefits of improving reliability should be weighed against any detriments for each individual case."
msgstr "重要的是要认识到调整参数可能会占用资源，并且可能会影响系统中超出预期改进范围的部分。改善可靠性的好处应该与每个个案的不利因素相权衡。"


#: ../../source/How-To-Guides/DDS-tuning.rst:21
msgid "Cross-vendor tuning"
msgstr "跨供应商调优"


#: ../../source/How-To-Guides/DDS-tuning.rst:23
msgid "**Issue:** Sending data over lossy (usually WiFi) connections becomes problematic when some IP fragments are dropped, possibly causing the kernel buffer on the receiving side to become full."
msgstr "**问题：**在一些 IP 片段丢失的情况下，通过有丢包的（通常是 WiFi）连接发送数据会变得困难，可能导致接收端的内核缓冲区变满。"


#: ../../source/How-To-Guides/DDS-tuning.rst:25
msgid "When a UDP packet is missing at least one IP fragment, the rest of the received fragments fill up the kernel buffer. By default, the Linux kernel will time out after 30s of trying to recombine packet fragments. Since the kernel buffer is full at this point (default size is 256KB), no new fragments can come in, and so the connection will seemingly \"hang\" for long periods of time."
msgstr "当一个 UDP 包丢失至少一个 IP 片段时，其余的接收到的片段会填满内核缓冲区。默认情况下，Linux 内核将在尝试重新组合包片段后的30秒超时。由于此时内核缓冲区已满（默认大小为256KB），无法接收新的片段，因此连接似乎会长时间“挂起”。"


#: ../../source/How-To-Guides/DDS-tuning.rst:29
msgid "This issue is generic across all DDS vendors, so the solutions involve adjusting kernel parameters."
msgstr "这个问题是DDS供应商都普遍存在的，因此解决方案涉及调整内核参数。"


#: ../../source/How-To-Guides/DDS-tuning.rst:31
msgid "**Solution:** Use best-effort QoS settings instead of reliable."
msgstr "**解决方案：**使用最佳努力的QoS设置，而不是可靠的设置。"


#: ../../source/How-To-Guides/DDS-tuning.rst:33
msgid "Best-effort settings reduce the amount of network traffic since the DDS implementation does not have to incur the overhead of reliable communications, where publishers require acknowledgements for messages sent to subscribers and must resend samples that have not been properly received."
msgstr "最佳努力的设置可以减少网络流量，因为DDS实现不需要承担可靠通信的开销。在可靠通信中，发布者需要对发送给订阅者的消息进行确认，并且必须重新发送未正确接收的样本。"


#: ../../source/How-To-Guides/DDS-tuning.rst:35
msgid "If the kernel buffer for IP fragments gets full, though, the symptom is still the same (blocking for 30s). This solution should improve the issue somewhat without having to adjust parameters."
msgstr "但是，如果IP分片的内核缓冲区变满，症状仍然相同（阻塞30秒）。这个解决方案应该能在不调整参数的情况下在一定程度上改善问题。"


#: ../../source/How-To-Guides/DDS-tuning.rst:38
msgid "**Solution:** Reduce the value of the ``ipfrag_time`` parameter."
msgstr "**解决方案：** 减小``ipfrag_time``参数的值。"


#: ../../source/How-To-Guides/DDS-tuning.rst:40
msgid "``net.ipv4.ipfrag_time / /proc/sys/net/ipv4/ipfrag_time`` (default 30s) : Time in seconds to keep an IP fragment in memory."
msgstr "``net.ipv4.ipfrag_time / /proc/sys/net/ipv4/ipfrag_time``（默认值为30秒）：保留IP片段在内存中的时间（以秒为单位）。"


#: ../../source/How-To-Guides/DDS-tuning.rst:43
msgid "Reduce the value, for example, to 3s, by running:"
msgstr "通过运行以下命令将该值减小到3秒，例如："


#: ../../source/How-To-Guides/DDS-tuning.rst:49
msgid "Reducing this parameter’s value also reduces the window of time where no fragments are received. The parameter is global for all incoming fragments, so the feasibility of reducing its value needs to be considered for every environment."
msgstr "减小此参数的值也会减少未接收到片段的时间窗口。该参数对所有传入的片段是全局的，因此需要考虑在每个环境中减小其值的可行性。"


#: ../../source/How-To-Guides/DDS-tuning.rst:52
msgid "**Solution:** Increase the value of the ``ipfrag_high_thresh`` parameter."
msgstr "**解决方案:** 增加``ipfrag_high_thresh``参数的值。"


#: ../../source/How-To-Guides/DDS-tuning.rst:54
msgid "``net.ipv4.ipfrag_high_thresh / /proc/sys/net/ipv4/ipfrag_high_thresh`` (default: 262144 bytes): Maximum memory used to reassemble IP fragments."
msgstr "``net.ipv4.ipfrag_high_thresh / /proc/sys/net/ipv4/ipfrag_high_thresh``（默认值：262144字节）：用于重新组装IP片段的最大内存使用量。"


#: ../../source/How-To-Guides/DDS-tuning.rst:57
msgid "Increase the value, for example, to 128MB, by running:"
msgstr "通过运行以下命令，将值增加到128MB："


#: ../../source/How-To-Guides/DDS-tuning.rst:63
msgid "Significantly increasing this parameter’s value is an attempt to ensure that the buffer never becomes completely full. However, the value would likely have to be significantly high to hold all data received during the time window of ``ipfrag_time``, assuming every UDP packet lacks one fragment."
msgstr "显著增加此参数的值是为了确保缓冲区永远不会完全填满。然而，假设每个UDP数据包都缺少一个片段，在``ipfrag_time``时间窗口内接收到的所有数据可能需要相当高的值来保存。"


#: ../../source/How-To-Guides/DDS-tuning.rst:66
msgid "**Issue:** Sending custom messages with large variable-sized arrays of non-primitive types causes high serialization/deserialization overhead and CPU load. This can lead to stalling of the publisher due to excessive time spent in ``publish()`` and tools like ``ros2 topic hz`` under reporting the actual frequency of messages being received. Note that for example ``builtin_interfaces/Time`` is also considered a non-primitive type and will incur higher serialization overhead. Because of the increased serialization overhead, severe performance degradation can be observed when naively transitioning custom message types from ROS 1 to ROS 2."
msgstr "**问题：** 使用大型变量大小的非原始类型数组发送自定义消息会导致高度的序列化/反序列化开销和CPU负载。这可能导致发布者由于在“publish()”中花费过多时间而停滞，并且像“ros2 topic hz”这样的工具会低估接收到的消息实际频率。请注意，例如“builtin_interfaces/Time”也被视为非原始类型，并且将产生更高的序列化开销。由于增加的序列化开销，当从ROS 1天真地转换自定义消息类型到ROS 2时，可能会观察到严重的性能下降。"


#: ../../source/How-To-Guides/DDS-tuning.rst:71
msgid "**Workaround:** Use multiple arrays of primitives instead of a single array of custom types, or pack into byte array as done e.g. in ``PointCloud2`` messages. For example, instead of defining a ``FooArray`` message as:"
msgstr "**解决方法：** 使用原始类型的多个数组代替单个自定义类型的数组，或者像“PointCloud2”消息中所做的那样打包成字节数组。例如，不要定义一个名为“FooArray”的消息，例如："


#: ../../source/How-To-Guides/DDS-tuning.rst:78
msgid "with ``Foo`` is defined as:"
msgstr "其中“Foo”被定义为："


#: ../../source/How-To-Guides/DDS-tuning.rst:85
msgid "Instead, define ``FooArray`` as:"
msgstr "相反，将“FooArray”定义为："


#: ../../source/How-To-Guides/DDS-tuning.rst:93
msgid "Fast RTPS tuning"
msgstr "快速RTPS调优"


#: ../../source/How-To-Guides/DDS-tuning.rst:95
msgid "**Issue:** Fast RTPS floods the network with large pieces of data or fast-published data when operating over WiFi."
msgstr "**问题：** 当在WiFi上操作时，快速RTPS会通过网络发送大块数据或快速发布数据，导致网络拥塞。"


#: ../../source/How-To-Guides/DDS-tuning.rst:97
msgid "See the solutions under :ref:`Cross-vendor tuning <cross-vendor-tuning>`."
msgstr "请参考 :ref:`跨供应商调优 <cross-vendor-tuning>` 中的解决方案。"


#: ../../source/How-To-Guides/DDS-tuning.rst:100
msgid "Cyclone DDS tuning"
msgstr "Cyclone DDS调优"


#: ../../source/How-To-Guides/DDS-tuning.rst:102
msgid "**Issue:** Cyclone DDS is not delivering large messages reliably, despite using reliable settings and transferring over a wired network."
msgstr "**问题：**尽管使用可靠的设置并通过有线网络传输，Cyclone DDS无法可靠地传递大消息。"


#: ../../source/How-To-Guides/DDS-tuning.rst:104
msgid "This issue should be `addressed soon <https://github.com/eclipse-cyclonedds/cyclonedds/issues/484>`_. Until then, we’ve come up with the following solution (debugged using `this test program <https://github.com/jacobperron/pc_pipe>`_):"
msgstr "这个问题应该会很快得到解决。在那之前，我们提出了以下解决方案（使用`此测试程序 <https://github.com/jacobperron/pc_pipe>`_ 进行了调试）："


#: ../../source/How-To-Guides/DDS-tuning.rst:107
msgid "**Solution:** Increase the maximum Linux kernel receive buffer size and the minimum socket receive buffer size that Cyclone uses."
msgstr "**解决方案：**增加Cyclone使用的Linux内核最大接收缓冲区大小和最小套接字接收缓冲区大小。"


#: ../../source/How-To-Guides/DDS-tuning.rst:109
msgid "*Adjustments to solve for a 9MB message:*"
msgstr "*调整以解决9MB消息的问题：*"


#: ../../source/How-To-Guides/DDS-tuning.rst:111 ../../source/How-To-Guides/DDS-tuning.rst:150
msgid "Set the maximum receive buffer size, ``rmem_max``, by running:"
msgstr "通过运行以下命令来设置最大接收缓冲区大小 `rmem_max`："


#: ../../source/How-To-Guides/DDS-tuning.rst:117
msgid "Or permanently set it by editing the ``/etc/sysctl.d/10-cyclone-max.conf`` file to contain:"
msgstr "或者通过编辑 `/etc/sysctl.d/10-cyclone-max.conf` 文件并包含以下内容来永久设置："


#: ../../source/How-To-Guides/DDS-tuning.rst:123
msgid "Next, to set the minimum socket receive buffer size that Cyclone requests, write out a configuration file for Cyclone to use while starting, like so:"
msgstr "然后，为了设置 Cyclone 请求的最小套接字接收缓冲区大小，请创建一个用于 Cyclone 启动时使用的配置文件，如下所示："


#: ../../source/How-To-Guides/DDS-tuning.rst:137
msgid "Then, whenever you are going to run a node, set the following environment variable:"
msgstr "然后，每当您要运行一个节点时，请设置以下环境变量："


#: ../../source/How-To-Guides/DDS-tuning.rst:144
msgid "RTI Connext tuning"
msgstr "RTI Connext调优"


#: ../../source/How-To-Guides/DDS-tuning.rst:146
msgid "**Issue:** Connext is not delivering large messages reliably, despite using reliable settings and transferring over a wired network."
msgstr "**问题：**尽管使用可靠设置并通过有线网络传输，Connext无法可靠地传递大消息。"


#: ../../source/How-To-Guides/DDS-tuning.rst:148
msgid "**Solution:** This `Connext QoS profile <https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_, along with increasing the ``rmem_max`` parameter."
msgstr "**解决方案：** 使用此 `Connext QoS配置文件<https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_ ，同时增加 ``rmem_max`` 参数。"


#: ../../source/How-To-Guides/DDS-tuning.rst:156
msgid "By tuning ``net.core.rmem_max`` to 4MB in the Linux kernel, the QoS profile can produce truly reliable behavior."
msgstr "通过将Linux内核中的 ``net.core.rmem_max`` 调整为4MB，QoS配置文件可以产生真正可靠的行为。"


#: ../../source/How-To-Guides/DDS-tuning.rst:158
msgid "This configuration has been proven to reliably deliver messages via SHMEM|UDPv4, and with just UDPv4 on a single machine. A multi-machine configuration was also tested with ``rmem_max`` at 4MB and at 20MB (two machines connected with 1Gbps ethernet), with no dropped messages and average message delivery times of 700ms and 371ms, respectively."
msgstr "这个配置经过验证，可靠地通过SHMEM|UDPv4传递消息，并且在单台机器上仅使用UDPv4。还进行了多机器配置的测试，``rmem_max``设置为4MB和20MB（两台机器通过1Gbps以太网连接），没有丢失消息，并且平均消息传递时间分别为700ms和371ms。"


#: ../../source/How-To-Guides/DDS-tuning.rst:161
msgid "Without configuring the kernel’s ``rmem_max``, the same Connext QoS profile took up to 12 seconds for the data to be delivered. However, it always at least managed to complete the delivery."
msgstr "在没有配置内核的``rmem_max``的情况下，相同的Connext QoS配置需要长达12秒才能传递数据。然而，它至少始终成功完成传递。"


#: ../../source/How-To-Guides/DDS-tuning.rst:164
msgid "**Solution:** Use the `Connext QoS profile <https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_ *without* adjusting ``rmem_max``."
msgstr "**解决方案：** 使用`Connext QoS配置文件<https://github.com/jacobperron/pc_pipe/blob/master/etc/ROS2TEST_QOS_PROFILES.xml>`_，*不*调整``rmem_max``。"


#: ../../source/How-To-Guides/DDS-tuning.rst:166
msgid "The ROS2TEST_QOS_PROFILES.xml file was configured using RTI’s documentation on `configuring flow controllers <https://community.rti.com/forum-topic/transfering-large-data-over-dds>`_. It has slow, medium and fast flow controllers (seen in the Connext QoS profile link)."
msgstr "ROS2TEST_QOS_PROFILES.xml文件是使用RTI的文档`配置流控制器<https://community.rti.com/forum-topic/transfering-large-data-over-dds>`_进行配置的。它包含了慢速、中速和快速的流控制器（在Connext QoS配置文件链接中可见）。"


#: ../../source/How-To-Guides/DDS-tuning.rst:168
msgid "The medium flow controller produced the best results for our case. However, the controllers will still need to be tuned for the particular machine/network/environment they are operating in. The Connext flow controllers can be used to tune bandwidth and its aggressiveness for sending out data, though once the bandwidth of a particular setup is passed, performance will start to drop."
msgstr "中等流量控制器在我们的案例中产生了最好的结果。然而，控制器仍然需要根据它们所操作的特定机器/网络/环境进行调整。Connext流量控制器可以用来调整带宽及其发送数据的攻击性，尽管一旦超过特定设置的带宽，性能就会开始下降。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:8
msgid "Developing a ROS 2 package"
msgstr "开发ROS 2软件包"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:14
msgid "This tutorial will teach you how to create your first ROS 2 application. It is intended for developers who want to learn how to create custom packages in ROS 2, not for people who want to use ROS 2 with its existing packages."
msgstr "本教程将教你如何创建你的第一个ROS 2应用程序。它适用于希望学习如何在ROS 2中创建自定义软件包的开发人员，而不适用于希望使用ROS 2及其现有软件包的用户。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:20
msgid ":doc:`Install ROS <../../Installation>`"
msgstr ":doc:`安装ROS <../../Installation>`"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:22
msgid "`Install colcon <https://colcon.readthedocs.io/en/released/user/installation.html>`__"
msgstr "`安装 colcon <https://colcon.readthedocs.io/en/released/user/installation.html>`__"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:24
msgid "Setup your workspace by sourcing your ROS 2 installation."
msgstr "通过将您的 ROS 2 安装路径设置为源，设置您的工作空间。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:27
msgid "Creating a package"
msgstr "创建软件包"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:29
msgid "All ROS 2 packages begin by running the command"
msgstr "所有 ROS 2 软件包都需要运行以下命令开始"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:35
msgid "in your workspace (usually ``~/ros2_ws/src``)."
msgstr "在您的工作空间中（通常为 ``~/ros2_ws/src``）。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:37
msgid "To create a package for a specific client library:"
msgstr "要为特定的客户端库创建软件包："


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:41 ../../source/How-To-Guides/Using-callback-groups.rst:49 ../../source/How-To-Guides/Using-callback-groups.rst:196 ../../source/How-To-Guides/Using-callback-groups.rst:282 ../../source/How-To-Guides/Using-callback-groups.rst:448 ../../source/How-To-Guides/Using-callback-groups.rst:502 ../../source/How-To-Guides/Using-callback-groups.rst:525
msgid "C++"
msgstr "C++"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:47 ../../source/How-To-Guides/Launch-file-different-formats.rst:30 ../../source/How-To-Guides/Launching-composable-nodes.rst:32 ../../source/How-To-Guides/Launching-composable-nodes.rst:148 ../../source/How-To-Guides/Using-callback-groups.rst:61 ../../source/How-To-Guides/Using-callback-groups.rst:248 ../../source/How-To-Guides/Using-callback-groups.rst:347 ../../source/How-To-Guides/Using-callback-groups.rst:455 ../../source/How-To-Guides/Using-callback-groups.rst:509 ../../source/How-To-Guides/Using-callback-groups.rst:553
msgid "Python"
msgstr "Python"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:53
msgid "You can then update the ``package.xml`` with your package info such as dependencies, descriptions, and authorship."
msgstr "然后，您可以使用您的软件包信息（例如依赖项、描述和作者信息）更新``package.xml``文件。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:56
msgid "C++ Packages"
msgstr "C++软件包"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:58
msgid "You will mostly use the ``add_executable()`` CMake macro along with"
msgstr "您将主要使用``add_executable()`` CMake宏，以及"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:64
msgid "to create executable nodes and link dependencies."
msgstr "创建可执行节点并链接依赖项。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:66
msgid "To install your launch files and nodes, you can use the ``install()`` macro placed towards the end of the file but before the ``ament_package()`` macro."
msgstr "要安装启动文件和节点，您可以使用位于文件末尾但在``ament_package()``宏之前的``install()``宏。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:68
msgid "An example for launch files and nodes:"
msgstr "启动文件和节点示例："


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:85
msgid "Python Packages"
msgstr "Python包"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:87
msgid "ROS 2 follows Python's standard module distribution process that uses ``setuptools``. For Python packages, the ``setup.py`` file complements a C++ package's ``CMakeLists.txt``. More details on distribution can be found in the `official documentation <https://docs.python.org/3/distributing/index.html#distributing-index>`_."
msgstr "ROS 2遵循Python的标准模块分发过程，使用``setuptools``。对于Python包，``setup.py``文件与C++包的``CMakeLists.txt``相辅相成。有关分发的更多详细信息，请参阅`官方文档 <https://docs.python.org/3/distributing/index.html#distributing-index>`_。"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:91
msgid "In your ROS 2 package, you should have a ``setup.cfg`` file which looks like:"
msgstr "在你的ROS 2包中，你应该有一个看起来像这样的``setup.cfg``文件："


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:100
msgid "and a ``setup.py`` file that looks like:"
msgstr "还有一个看起来像这样的``setup.py``文件："


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:151
msgid "Combined C++ and Python Packages"
msgstr "结合C++和Python包"


#: ../../source/How-To-Guides/Developing-a-ROS-2-Package.rst:153
msgid "When writing a package with both C++ and Python code, the ``setup.py`` file and ``setup.cfg`` file are not used. Instead, use :doc:`ament_cmake_python <./Ament-CMake-Python-Documentation>`."
msgstr "当编写既包含C++代码又包含Python代码的包时，不使用``setup.py``文件和``setup.cfg``文件。而是使用 :doc:`ament_cmake_python <./Ament-CMake-Python-Documentation>`。"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:4
msgid "Disabling Zero Copy Loaned Messages"
msgstr "禁用零拷贝借用消息"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:8 ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:16 ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:8 ../../source/How-To-Guides/Sync-Vs-Async.rst:18 ../../source/How-To-Guides/Topics-Services-Actions.rst:8 ../../source/How-To-Guides/Using-Python-Packages.rst:15
msgid "Contents"
msgstr "内容"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:10
msgid "See the `Loaned Messages <https://design.ros2.org/articles/zero_copy.html>`__ article for details on how loaned messages work."
msgstr "有关借用消息工作原理的详细信息，请参阅`借用消息<https://design.ros2.org/articles/zero_copy.html>`__文章。"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:13
msgid "How to disable Loaned Messages"
msgstr "如何禁用借用消息"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:15
msgid "By default, *Loaned Messages* will try to borrow the memory from underlying middleware if it supports *Loaned Messages*. The ``ROS_DISABLE_LOANED_MESSAGES`` environment variable can be used to disable *Loaned Messages*, and fallback to normal publisher and subscription behavior, without any code changes or middleware configuration. You can set the environment variable with the following command:"
msgstr "默认情况下，*借用消息* 将尝试从底层中间件借用内存，如果它支持*借用消息*。可以使用 ``ROS_DISABLE_LOANED_MESSAGES`` 环境变量来禁用*借用消息*，并回退到正常的发布者和订阅者行为，无需进行任何代码更改或中间件配置。您可以使用以下命令设置环境变量："


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:21 ../../source/How-To-Guides/Installation-Troubleshooting.rst:74 ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:36
msgid "Linux"
msgstr "Linux"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:27 ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:39
msgid "To maintain this setting between shell sessions, you can add the command to your shell startup script:"
msgstr "要在不同的 shell 会话之间保持此设置，您可以将该命令添加到您的 shell 启动脚本中："


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:33 ../../source/How-To-Guides/Installation-Troubleshooting.rst:109 ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:45
msgid "macOS"
msgstr "macOS"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:45 ../../source/How-To-Guides/Installation-Troubleshooting.rst:262 ../../source/How-To-Guides/RQt-Source-Install.rst:100 ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:54
msgid "Windows"
msgstr "Windows"


#: ../../source/How-To-Guides/Disabling-ZeroCopy-loaned-messages.rst:51
msgid "If you want to make this permanent between shell sessions, also run:"
msgstr "如果您希望在不同的 shell 会话之间保持此设置，请执行以下操作："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:7
msgid "Installation troubleshooting"
msgstr "安装故障排除"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:9
msgid "Troubleshooting techniques for installation are sorted by the platforms they apply to."
msgstr "安装故障排除技巧根据适用的平台进行了分类。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:13
msgid "Platforms"
msgstr "平台"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:16
msgid "General"
msgstr "通用"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:18
msgid "General troubleshooting techniques apply to all platforms."
msgstr "通用故障排除技巧适用于所有平台。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:21
msgid "Enable multicast"
msgstr "启用多播"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:23
msgid "In order to communicate successfully via DDS, the used network interface has to be multicast enabled. We've seen in past experiences that this might not necessarily be enabled by default (on Ubuntu or OSX) when using the loopback adapter. See the `original issue <https://github.com/ros2/ros2/issues/552>`__ or a `conversation on ros-answers <https://answers.ros.org/question/300370/ros2-talker-cannot-communicate-with-listener/>`__. You can verify that your current setup allows multicast with the ROS 2 tool:"
msgstr "为了通过DDS成功通信，使用的网络接口必须启用组播功能。在过去的经验中，我们发现当使用环回适配器（在Ubuntu或OSX上）时，默认情况下可能未启用组播功能。请参阅 `原始问题 <https://github.com/ros2/ros2/issues/552>`__ 或 `ros-answers 上的讨论 <https://answers.ros.org/question/300370/ros2-talker-cannot-communicate-with-listener/>`__。您可以使用ROS 2工具验证您当前的设置是否允许组播："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:28
msgid "In Terminal 1:"
msgstr "在终端1中："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:34
msgid "In Terminal 2:"
msgstr "在终端2中："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:40
msgid "If the first command did not return a response similar to:"
msgstr "如果第一个命令没有返回类似以下内容的响应"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:46
msgid "then you will need to update your firewall configuration to allow multicast using `ufw <https://help.ubuntu.com/community/UFW>`__."
msgstr "如果需要使用多播，您需要更新防火墙配置以允许多播，使用 `ufw <https://help.ubuntu.com/community/UFW>`__ 命令。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:54
msgid "You can check if the multicast flag is enabled for your network interface using the :code:`ifconfig` tool and looking for :code:`MULITCAST` in the flags section:"
msgstr "您可以使用 :code:`ifconfig` 工具检查您的网络接口是否启用了多播标志，在 flags 部分查找 :code:`MULTICAST`："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:62
msgid "Import failing without library present on the system"
msgstr "导入失败，因为系统上没有找到所需的库。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:64
msgid "Sometimes ``rclpy`` fails to be imported because the expected C extension libraries are not found. If so, compare the libraries present in the directory with the one mentioned in the error message. Assuming a file with a similar name exists (same prefix like ``_rclpy.`` and same suffix like ``.so`` but a different Python version / architecture) you are using a different Python interpreter than which was used to build the C extension. Be sure to use the same Python interpreter as the one used to build the binary."
msgstr "有时候，``rclpy`` 导入失败是因为找不到预期的 C 扩展库。如果是这样，请将目录中存在的库与错误消息中提到的库进行比较。假设存在一个类似的文件（具有相同的前缀，例如 ``_rclpy.``，和相同的后缀，例如 ``.so``，但使用的是不同的 Python 版本/架构），则表示您正在使用与用于构建 C 扩展的 Python 解释器不同的 Python 解释器。请确保使用与构建二进制文件时相同的 Python 解释器。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:69
msgid "For example, such a mismatch can crop up after an update of the OS. Then, rebuilding the workspace may fix the issue."
msgstr "例如，在操作系统更新后可能会出现这样的不匹配问题。然后，重建工作区可能会解决这个问题。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:77
msgid "Internal compiler error"
msgstr "内部编译器错误"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:79
msgid "If you experience an ICE when trying to compile on a memory constrained platform like a Raspberry PI you might want to build single threaded (prefix the build invocation with ``MAKEFLAGS=-j1``)."
msgstr "如果在像树莓派这样的内存受限平台上尝试编译时遇到内部编译器错误（ICE），您可能希望使用单线程构建（在构建命令前加上 ``MAKEFLAGS=-j1``）。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:82
msgid "Out of memory"
msgstr "内存不足"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:84
msgid "The ``ros1_bridge`` in its current form requires 4Gb of free RAM to compile. If you don't have that amount of RAM available it's suggested to use ``COLCON_IGNORE`` in that folder and skip its compilation."
msgstr "目前的 ``ros1_bridge`` 需要4GB的可用内存进行编译。如果您没有足够的可用内存，建议在该文件夹中使用 ``COLCON_IGNORE`` 跳过编译过程。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:88
msgid "Multiple host interference"
msgstr "多个主机干扰"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:90
msgid "If you're running multiple instances on the same network you may get interference. To avoid this you can set the environment variable ``ROS_DOMAIN_ID`` to a different integer, the default is zero. This will define the DDS domain id for your system."
msgstr "如果您在同一网络上运行多个实例，可能会发生干扰。为了避免这种情况，您可以将环境变量 ``ROS_DOMAIN_ID`` 设置为不同的整数值，默认值为零。这将为您的系统定义DDS域ID。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:95
msgid "Exception sourcing setup.bash"
msgstr "加载 setup.bash 异常"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:99
msgid "If you encounter exceptions when trying to source the environment after building from source, try to upgrade ``colcon`` related packages using"
msgstr "如果在构建源码后尝试引用环境时遇到异常，请尝试使用以下命令升级相关的``colcon``软件包"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:112
msgid "Segmentation fault when using ``pyenv``"
msgstr "使用``pyenv``时出现分段错误"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:114
msgid "``pyenv`` seems to default to building Python with ``.a`` files, but that causes issues with ``rclpy``, so it's recommended to build Python with Frameworks enabled on macOS when using ``pyenv``:"
msgstr "``pyenv``似乎默认使用``.a``文件构建Python，但这会导致``rclpy``出现问题，因此建议在使用``pyenv``时在macOS上启用Frameworks构建Python："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:116
msgid "https://github.com/pyenv/pyenv/wiki#how-to-build-cpython-with-framework-support-on-os-x"
msgstr "https://github.com/pyenv/pyenv/wiki#how-to-build-cpython-with-framework-support-on-os-x"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:119
msgid "Library not loaded; image not found"
msgstr "无法加载库文件；找不到图像"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:121
msgid "If you are seeing library loading issues at runtime (either running tests or running nodes), such as the following:"
msgstr "如果您在运行时（无论是运行测试还是运行节点）遇到库加载问题，例如以下情况："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:129
msgid "Then you probably have System Integrity Protection enabled. Follow `these instructions <https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html>`__ to disable System Integrity Protection (SIP)."
msgstr "那么您可能已启用系统完整性保护（System Integrity Protection）。按照 `这些说明 <https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/ConfiguringSystemIntegrityProtection/ConfiguringSystemIntegrityProtection.html>`__ 禁用系统完整性保护（SIP）。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:133
msgid "Qt build error: ``unknown type name 'Q_ENUM'``"
msgstr "Qt构建错误：``unknown type name 'Q_ENUM'``"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:135
msgid "If you see build errors related to Qt, e.g.:"
msgstr "如果您遇到与Qt相关的构建错误，例如："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:145
msgid "you may be using qt4 instead of qt5: see https://github.com/ros2/ros2/issues/441"
msgstr "可能是因为您正在使用Qt4而不是Qt5，请参考https://github.com/ros2/ros2/issues/441"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:148
msgid "Missing symbol when opencv (and therefore libjpeg, libtiff, and libpng) are installed with Homebrew"
msgstr "当使用Homebrew安装opencv（因此也安装了libjpeg、libtiff和libpng）时出现缺少符号的情况"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:150
msgid "If you have opencv installed you might get this:"
msgstr "如果您已安装opencv，可能会出现以下情况："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:160
msgid "If so, to build you'll have to do this:"
msgstr "如果是这样，要构建，你需要执行以下步骤："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:166
msgid "But this will break opencv, so you'll also need to update it to continue working:"
msgstr "但这将会破坏OpenCV，所以你还需要更新它以继续工作："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:175
msgid "The first command is necessary to avoid things built against the system libjpeg (etc.) from getting the version in /usr/local/lib. The others are updating things built by Homebrew so that they can find the version of libjpeg (etc.) without having them in /usr/local/lib."
msgstr "第一个命令是为了避免使用系统libjpeg（等等）构建的内容获取到/usr/local/lib中的版本。其他命令是为了更新由Homebrew构建的内容，使其能够找到libjpeg（等等）的版本，而不必将它们放在/usr/local/lib中。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:179
msgid "Xcode-select error: tool ``xcodebuild`` requires Xcode, but active developer directory is a command line instance"
msgstr "Xcode-select错误：工具``xcodebuild``需要Xcode，但活动开发人员目录是一个命令行实例"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:183
msgid "If you recently installed Xcode, you may encounter this error:"
msgstr "如果您最近安装了Xcode，可能会遇到此错误："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:190
msgid "To resolve this error, you will need to:"
msgstr "要解决此错误，您需要执行以下操作："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:192
msgid "Double check that you have the command line tool installed:"
msgstr "请仔细检查是否安装了命令行工具："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:198
msgid "Accept the terms and conditions of Xcode by typing in terminal:"
msgstr "在终端中输入以下命令接受Xcode的条款和条件："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:204
msgid "Ensure Xcode app is in the ``/Applications`` directory (NOT ``/Users/{user}/Applications``)"
msgstr "确保 Xcode 应用程序位于 ``/Applications`` 目录下（而不是 ``/Users/{user}/Applications``）"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:206
msgid "Point ``xcode-select`` to the Xcode app Developer directory using the following command:"
msgstr "使用以下命令将 ``xcode-select`` 指向 Xcode 应用程序的开发者目录："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:213
msgid "qt_gui_cpp error: SIP binding generator NOT available"
msgstr "qt_gui_cpp 错误：SIP 绑定生成器不可用"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:217
msgid "When building qt_gui_cpp there may be errors look like the following:"
msgstr "构建 qt_gui_cpp 时可能会出现以下类似的错误："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:229
msgid "To fix this issue, follow :doc:`these steps <RQt-Source-Install-MacOS>` to install dependencies for RQt."
msgstr "要解决此问题，请按照 :doc:`这些步骤 <RQt-Source-Install-MacOS>` 安装 RQt 的依赖项。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:232
msgid "rosdep install error ``homebrew: Failed to detect successful installation of [qt5]``"
msgstr "rosdep 安装错误 ``homebrew: Failed to detect successful installation of [qt5]``"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:233
msgid "While following the :doc:`Creating a workspace <../Tutorials/Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` tutorial, you might encounter the following error stating that ``rosdep`` failes to install Qt5."
msgstr "在遵循 :doc:`创建工作空间 <../Tutorials/Beginner-Client-Libraries/Creating-A-Workspace/Creating-A-Workspace>` 教程时，您可能会遇到以下错误，指出 ``rosdep`` 无法安装 Qt5。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:244
msgid "This error seems to stem from a `linking issue <https://github.com/ros-infrastructure/rosdep/issues/490#issuecomment-334959426>`__ and can be resolved by running the following command."
msgstr "此错误似乎源于 `链接问题 <https://github.com/ros-infrastructure/rosdep/issues/490#issuecomment-334959426>`__，可以通过运行以下命令来解决。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:251
msgid "Running the ``rosdep`` command should now execute normally:"
msgstr "现在执行 ``rosdep`` 命令应该正常运行："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:265
msgid "Import failing even with library present on the system"
msgstr "即使系统中存在该库，导入仍然失败"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:267
msgid "Sometimes ``rclpy`` fails to be imported because of some missing DLLs on your system. If so, make sure to install all the dependencies listed in the \"Installing prerequisites\" sections of the :ref:`installation instructions <windows-install-binary-installing-prerequisites>`)."
msgstr "有时候由于系统上缺少某些 DLL 文件，导致无法导入 ``rclpy``。如果出现这种情况，请确保安装了 :ref:`安装指南 <windows-install-binary-installing-prerequisites>` 中“安装先决条件”部分列出的所有依赖项。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:270
msgid "If you are installing from binaries, you may need to update your dependencies: they must be the same version as those used to build the binaries."
msgstr "如果您正在使用二进制文件进行安装，则可能需要更新您的依赖项：它们必须与用于构建二进制文件的版本相同。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:272
msgid "If you are still having issues, you can use the `Dependencies <https://github.com/lucasg/Dependencies>`_ tool to determine which dependencies are missing on your system. Use the tool to load the corresponding ``.pyd`` file, and it should report unavailable ``DLL`` modules. Be sure that the current workspace is sourced before you execute the tool, otherwise there will be unresolved ROS DLL files. Use this information to install additional dependencies or adjust your path as necessary."
msgstr "如果您仍然遇到问题，您可以使用 `Dependencies <https://github.com/lucasg/Dependencies>`_ 工具来确定您的系统缺少哪些依赖项。使用该工具加载相应的 ``.pyd`` 文件，它将报告不可用的 ``DLL`` 模块。在执行工具之前，请确保当前的工作空间已被激活，否则将出现未解决的 ROS DLL 文件。根据这些信息安装额外的依赖项或根据需要调整您的路径。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:278
msgid "CMake error setting modification time"
msgstr "CMake 错误设置修改时间"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:280
msgid "If you run into the CMake error ``file INSTALL cannot set modification time on ...`` when installing files it is likely that an anti virus software or Windows Defender are interfering with the build. E.g. for Windows Defender you can list the workspace location to be excluded to prevent it from scanning those files."
msgstr "如果在安装文件时遇到 CMake 错误 ``file INSTALL cannot set modification time on ...``，很可能是由于杀毒软件或 Windows Defender 干扰了构建过程。例如，对于 Windows Defender，您可以将工作空间位置列入排除列表，以防止其扫描这些文件。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:283
msgid "260 character path limit"
msgstr "260 字符路径限制"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:290
msgid "Depending on your directory hierarchy, you may see path length limit errors when building ROS 2 from source or your own libraries."
msgstr "根据您的目录层次结构，在从源代码构建ROS 2或您自己的库时，可能会出现路径长度限制错误。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:292
msgid "To allow deeper path lengths:"
msgstr "要允许更深的路径长度："


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:294
msgid "Run ``regedit.exe``, navigate to ``Computer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem``, and set ``LongPathsEnabled`` to 0x00000001 (1)."
msgstr "运行 ``regedit.exe``，导航至 ``Computer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem``，并将 ``LongPathsEnabled`` 设置为 0x00000001（1）。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:296
msgid "Hit the windows key and type ``Edit Group Policy``. Navigate to Local Computer Policy > Computer Configuration > Administrative Templates > System > Filesystem. Right click ``Enable Win32 long paths``, click Edit. In the dialog, select Enabled and click OK."
msgstr "按下 Windows 键并输入 ``Edit Group Policy``。导航至 Local Computer Policy > Computer Configuration > Administrative Templates > System > Filesystem。右键单击 ``Enable Win32 long paths``，点击编辑。在对话框中，选择已启用并点击确定。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:301
msgid "Close and open your terminal to reset the environment and try building again."
msgstr "关闭并重新打开终端以重置环境，并尝试重新构建。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:304
msgid "CMake packages unable to find asio, tinyxml2, tinyxml, or eigen"
msgstr "CMake软件包无法找到asio、tinyxml2、tinyxml或eigen。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:306
msgid "We've seen that sometimes the chocolatey packages for ``asio``, ``tinyxml2``, etc. do not add important registry entries and CMake will be unable to find them when building ROS 2. We've not yet been able to identify the root cause, but uninstalling the chocolatey packages (with ``-n`` if the uninstall fails the first time), and then reinstalling them will fix the issue."
msgstr "我们发现有时候``asio``、``tinyxml2``等的chocolatey软件包没有添加重要的注册表项，导致在构建ROS 2时CMake无法找到它们。我们还没有找到根本原因，但是卸载chocolatey软件包（如果首次卸载失败，则使用``-n``参数），然后重新安装它们可以解决这个问题。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:310
msgid "patch.exe opens a new command window and asks for administrator"
msgstr "patch.exe会打开一个新的命令窗口并要求管理员权限。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:312
msgid "This will also cause the build of packages which need to use patch to fail, even you allow it to use administrator rights."
msgstr "即使您允许使用管理员权限，这也会导致需要使用补丁的软件包构建失败。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:314
msgid "``choco uninstall patch; colcon build --cmake-clean-cache`` - This is a bug in the `GNU Patch For Windows package <https://chocolatey.org/packages/patch>`_. If this package is not installed, the build process will instead use the version of Patch distributed with git."
msgstr "``choco uninstall patch; colcon build --cmake-clean-cache`` - 这是 `GNU Patch For Windows package <https://chocolatey.org/packages/patch>`_ 中的一个错误。如果未安装此软件包，构建过程将使用与 git 分发的 Patch 版本。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:317
msgid "Failed to load Fast RTPS shared library"
msgstr "无法加载 Fast RTPS 共享库"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:321
msgid "Fast RTPS requires ``msvcr20.dll``, which is part of the ``Visual C++ Redistributable Packages for Visual Studio 2013``. Although it is usually installed by default in Windows 10, we know that some Windows 10-like versions don't have it installed by default (e.g.: Windows Server 2019). In case you don't have it installed, you can download it from `here <https://www.microsoft.com/en-us/download/details.aspx?id=40784>`_."
msgstr "Fast RTPS 需要 ``msvcr20.dll``，它是 ``Visual C++ Redistributable Packages for Visual Studio 201"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:326
msgid "Binary installation specific"
msgstr "二进制安装特定"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:328
msgid "If your example does not start because of missing DLLs, please verify that all libraries from external dependencies such as OpenCV are located inside your ``PATH`` variable."
msgstr "如果由于缺少 DLL 文件而无法启动示例，请验证所有外部依赖库（如 OpenCV）是否位于您的 ``PATH`` 变量中。"


#: ../../source/How-To-Guides/Installation-Troubleshooting.rst:329
msgid "If you forget to call the ``local_setup.bat`` file from your terminal, the demo programs will most likely crash immediately."
msgstr "如果您忘记从终端调用 ``local_setup.bat`` 文件，演示程序很可能会立即崩溃。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:2
msgid "ROS 2 on Raspberry Pi"
msgstr "在 Raspberry Pi 上的 ROS 2"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:4
msgid "ROS 2 is supported on both 32 bit (arm32) and 64 bit (arm64) ARM processors. However, you can see `here <https://www.ros.org/reps/rep-2000.html>`__ that arm64 receives Tier 1 support, while arm32 is Tier 3. Tier 1 support means distribution specific packages and binary archives are available, while Tier 3 requires the user to compile ROS 2 from source."
msgstr "ROS 2支持32位（arm32）和64位（arm64）ARM处理器。然而，您可以在`这里 <https://www.ros.org/reps/rep-2000.html>`__ 看到arm64是一级支持，而arm32是三级支持。一级支持意味着有特定发行版的软件包和二进制存档可用，而三级支持需要用户从源代码编译ROS 2。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:8
msgid "The fastest and simplest way to use ROS 2 is to use a Tier 1 supported configuration."
msgstr "使用一级支持的配置是使用ROS 2的最快和最简单的方法。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:10
msgid "This would mean either installing 64 bit Ubuntu on to the Raspberry Pi, or using the 64 bit version of Raspberry Pi OS and running ROS 2 in Docker."
msgstr "这意味着要在树莓派上安装64位Ubuntu，或者使用64位版本的树莓派操作系统并在Docker中运行ROS 2。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:13
msgid "Ubuntu Linux on Raspberry Pi with binary ROS 2 install"
msgstr "在树莓派上使用二进制安装的Ubuntu Linux和ROS 2"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:15
msgid "Ubuntu for Raspberry Pi is available `here <https://ubuntu.com/download/raspberry-pi>`__."
msgstr "Ubuntu for Raspberry Pi is available 在这里 <https://ubuntu.com/download/raspberry-pi>。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:17
msgid "Make sure to confirm that you have selected the correct version as described in `REP-2000 <https://www.ros.org/reps/rep-2000.html>`__."
msgstr "请确认您已经选择了正确的版本，如 `REP-2000 <https://www.ros.org/reps/rep-2000.html>`__ 中所述。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:19
msgid "You can now install ROS 2 using the normal binary installation instructions for Ubuntu Linux."
msgstr "您现在可以按照 Ubuntu Linux 的常规二进制安装说明来安装 ROS 2。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:22
msgid "Raspberry Pi OS with ROS 2 in docker"
msgstr "在 Docker 中使用 ROS 2 的 Raspberry Pi OS"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:24
msgid "Raspberry Pi OS 64 bit version is `available here <https://www.raspberrypi.com/software/operating-systems/>`__."
msgstr "Raspberry Pi OS 64位版本可以在此处获得: `https://www.raspberrypi.com/software/operating-systems/ <https://www.raspberrypi.com/software/operating-systems/>`__."


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:26
msgid "Raspberry Pi OS is based on Debian which receives Tier 3 support, but it can run Ubuntu docker containers for Tier 1 support."
msgstr "Raspberry Pi OS基于Debian，Debian获得第三级支持，但可以运行Ubuntu Docker容器以获得第一级支持."


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:28
msgid "After flashing the OS, `install Docker <https://docs.docker.com/engine/install/debian/#install-using-the-convenience-script>`__."
msgstr "刷写操作系统后，请使用此链接 `https://docs.docker.com/engine/install/debian/#install-using-the-convenience-script <https://docs.docker.com/engine/install/debian/#install-using-the-convenience-script>`__ 安装Docker."


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:30
msgid "The official OSRF ROS 2 Docker container definitions can be found `here <https://github.com/osrf/docker_images/>`__."
msgstr "官方OSRF ROS 2 Docker容器定义可以在此处找到: `https://github.com/osrf/docker_images/ <https://github.com/osrf/docker_images/>`__."


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:32
msgid "You may choose from ros-core, ros-base, or ros-desktop. See `here <https://www.ros.org/reps/rep-2001.html>`__ for more information on these variants."
msgstr "您可以选择使用ros-core、ros-base或ros-desktop。有关这些变体的更多信息，请参阅 `这里 <https://www.ros.org/reps/rep-2001.html>`__。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:34
msgid "Clone the `docker_images git repo <https://github.com/osrf/docker_images>`__ onto the Raspberry Pi, change in to the directory linked above, then to the directory with your preferred variant."
msgstr "克隆 `docker_images git仓库 <https://github.com/osrf/docker_images>`__ 到Raspberry Pi上，切换到上述链接的目录，然后进入您首选的变体所在的目录。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:36
msgid "Inside of the directory, build the container with:"
msgstr "在该目录中，使用以下命令构建容器："


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:42
msgid "On a supported system it will only take a minute or two to build the docker containers, as the source code is already built in to binaries."
msgstr "在支持的系统上，构建docker容器只需要一两分钟，因为源代码已经构建成二进制文件。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:45
msgid "Pre-built Docker container"
msgstr "预构建的 Docker 容器"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:47
msgid "A pre-built container for the desktop variant is available as well, which only requires a docker pull command."
msgstr "还提供了预构建的桌面变体容器，只需执行 docker pull 命令即可。"


#: ../../source/How-To-Guides/Installing-on-Raspberry-Pi.rst:49
msgid "See :doc:`this page <Run-2-nodes-in-single-or-separate-docker-containers>` for more information."
msgstr "有关更多信息，请参阅 :doc:`此页面 <Run-2-nodes-in-single-or-separate-docker-containers>`。"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:6
msgid "Using Python, XML, and YAML for ROS 2 Launch Files"
msgstr "使用 Python、XML 和 YAML 编写 ROS 2 启动文件"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:12
msgid "ROS 2 launch files can be written in Python, XML, and YAML. This guide shows how to use these different formats to accomplish the same task, as well as has some discussion on when to use each format."
msgstr "ROS 2启动文件可以使用Python、XML和YAML编写。本指南展示了如何使用这些不同格式来完成相同的任务，并讨论了何时使用每种格式。"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:16 ../../source/How-To-Guides/Launching-composable-nodes.rst:22
msgid "Launch file examples"
msgstr "启动文件示例"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:18
msgid "Below is a launch file implemented in Python, XML, and YAML. Each launch file performs the following actions:"
msgstr "下面是用Python、XML和YAML实现的启动文件。每个启动文件执行以下操作："


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:21
msgid "Setup command line arguments with defaults"
msgstr "设置带有默认值的命令行参数"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:22
msgid "Include another launch file"
msgstr "包含另一个启动文件"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:23
msgid "Include another launch file in another namespace"
msgstr "在另一个命名空间中包含另一个启动文件"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:24
msgid "Start a node and setting its namespace"
msgstr "启动一个节点并设置其命名空间"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:25
msgid "Start a node, setting its namespace, and setting parameters in that node (using the args)"
msgstr "启动一个节点，设置其命名空间，并在该节点中设置参数（使用 args 参数）"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:26
msgid "Create a node to remap messages from one topic to another"
msgstr "创建一个节点，将消息从一个话题重新映射到另一个话题"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:133 ../../source/How-To-Guides/Launching-composable-nodes.rst:69 ../../source/How-To-Guides/Launching-composable-nodes.rst:188
msgid "XML"
msgstr "XML"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:172 ../../source/How-To-Guides/Launching-composable-nodes.rst:91 ../../source/How-To-Guides/Launching-composable-nodes.rst:212
msgid "YAML"
msgstr "YAML"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:244
msgid "Using the Launch files from the command line"
msgstr "通过命令行使用启动文件"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:247
msgid "Launching"
msgstr "启动中"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:249
msgid "Any of the launch files above can be run with ``ros2 launch``. To try them locally, you can either create a new package and use"
msgstr "上述任意一个启动文件都可以使用``ros2 launch``命令来运行。如果要在本地尝试它们，您可以创建一个新的软件包并使用"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:256
msgid "or run the file directly by specifying the path to the launch file"
msgstr "或者直接通过指定启动文件的路径来运行该文件"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:263
msgid "Setting arguments"
msgstr "设置参数"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:265
msgid "To set the arguments that are passed to the launch file, you should use ``key:=value`` syntax. For example, you can set the value of ``background_r`` in the following way:"
msgstr "要设置传递给启动文件的参数，应该使用 ``key:=value`` 语法。例如，可以按照以下方式设置 ``background_r`` 的值："


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:272 ../../source/How-To-Guides/Using-callback-groups.rst:532 ../../source/How-To-Guides/Using-callback-groups.rst:539 ../../source/How-To-Guides/Using-callback-groups.rst:546 ../../source/How-To-Guides/Using-callback-groups.rst:560 ../../source/How-To-Guides/Using-callback-groups.rst:567 ../../source/How-To-Guides/Using-callback-groups.rst:574
msgid "or"
msgstr "或"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:279
msgid "Controlling the turtles"
msgstr "控制海龟"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:281
msgid "To test that the remapping is working, you can control the turtles by running the following command in another terminal:"
msgstr "为了测试重映射是否起作用，可以在另一个终端中运行以下命令来控制海龟："


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:289 ../../source/How-To-Guides/Launching-composable-nodes.rst:275
msgid "Python, XML, or YAML: Which should I use?"
msgstr "Python、XML 或 YAML：我应该使用哪个？"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:293
msgid "Launch files in ROS 1 were written in XML, so XML may be the most familiar to people coming from ROS 1. To see what's changed, you can visit :doc:`Launch-files-migration-guide`."
msgstr "在 ROS 1 中，启动文件是用 XML 编写的，所以对于来自 ROS 1 的人来说，XML 可能更为熟悉。要了解发生了什么变化，您可以访问 :doc:`Launch-files-migration-guide`。"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:296
msgid "For most applications the choice of which ROS 2 launch format comes down to developer preference. However, if your launch file requires flexibility that you cannot achieve with XML or YAML, you can use Python to write your launch file. Using Python for ROS 2 launch is more flexible because of following two reasons:"
msgstr "对于大多数应用程序而言，选择使用哪种 ROS 2 启动文件格式取决于开发人员的偏好。然而，如果您的启动文件需要 XML 或 YAML 无法实现的灵活性，您可以使用 Python 来编写启动文件。使用 Python 进行 ROS 2 启动更加灵活，原因如下："


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:300
msgid "Python is a scripting language, and thus you can leverage the language and its libraries in your launch files."
msgstr "Python 是一种脚本语言，因此您可以在启动文件中利用该语言及其库。"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:301
msgid "`ros2/launch <https://github.com/ros2/launch>`_ (general launch features) and `ros2/launch_ros <https://github.com/ros2/launch_ros>`_ (ROS 2 specific launch features) are written in Python and thus you have lower level access to launch features that may not be exposed by XML and YAML."
msgstr "`ros2/launch <https://github.com/ros2/launch>`_（通用的启动功能）和`ros2/launch_ros <https://github.com/ros2/launch_ros>`_（ROS 2特定的启动功能）都是用Python编写的，因此您可以以较低级别访问启动功能，这些功能可能不会通过XML和YAML暴露出来。"


#: ../../source/How-To-Guides/Launch-file-different-formats.rst:303
msgid "That being said, a launch file written in Python may be more complex and verbose than one in XML or YAML."
msgstr "话虽如此，用Python编写的启动文件可能比XML或YAML中的启动文件更复杂且冗长。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:9
msgid "Migrating launch files from ROS 1 to ROS 2"
msgstr "将启动文件从ROS 1迁移到ROS 2"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:15
msgid "This guide describes how to write XML launch files for an easy migration from ROS 1."
msgstr "本指南描述了如何编写XML启动文件以便轻松从ROS 1迁移到ROS 2。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:18 ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:19
msgid "Background"
msgstr "背景"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:20
msgid "A description of the ROS 2 launch system and its Python API can be found in :doc:`Launch System tutorial <../Tutorials/Intermediate/Launch/Launch-system>`."
msgstr "关于ROS 2启动系统及其Python API的描述可以在 :doc:`启动系统教程 <../Tutorials/Intermediate/Launch/Launch-system>` 中找到。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:24
msgid "Migrating tags from ROS 1 to ROS 2"
msgstr "从ROS 1迁移到ROS 2的标签"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:27
msgid "launch"
msgstr "启动"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:29
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/launch>`__."
msgstr "`在ROS 1中可用 <https://wiki.ros.org/roslaunch/XML/launch>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:30
msgid "``launch`` is the root element of any ROS 2 launch XML file."
msgstr "``launch`` 是任何ROS 2启动XML文件的根元素。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:33
msgid "node"
msgstr "节点"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:35
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/node>`__."
msgstr "`在ROS 1中可用 <https://wiki.ros.org/roslaunch/XML/node>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:36
msgid "Launches a new node."
msgstr "启动一个新的节点。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:37 ../../source/How-To-Guides/Launch-files-migration-guide.rst:176 ../../source/How-To-Guides/Launch-files-migration-guide.rst:198 ../../source/How-To-Guides/Launch-files-migration-guide.rst:271
msgid "Differences from ROS 1:"
msgstr "与ROS 1的不同之处："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:39
msgid "``type`` attribute is now ``exec``."
msgstr "``type`` 属性现在为 ``exec``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:40
msgid "``ns`` attribute is now ``namespace``."
msgstr "``ns`` 属性现在为 ``namespace``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:41
msgid "The following attributes aren't available: ``machine``, ``respawn_delay``, ``clear_params``."
msgstr "以下属性不可用：``machine``，``respawn_delay``，``clear_params``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:44 ../../source/How-To-Guides/Launch-files-migration-guide.rst:63 ../../source/How-To-Guides/Launch-files-migration-guide.rst:142 ../../source/How-To-Guides/Launch-files-migration-guide.rst:158 ../../source/How-To-Guides/Launch-files-migration-guide.rst:206 ../../source/How-To-Guides/Launch-files-migration-guide.rst:247 ../../source/How-To-Guides/Launch-files-migration-guide.rst:281 ../../source/How-To-Guides/Launch-files-migration-guide.rst:354 ../../source/How-To-Guides/Node-arguments.rst:40 ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:68
msgid "Example"
msgstr "示例"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:54
msgid "param"
msgstr "param"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:56
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/param>`__."
msgstr "`在 ROS 1 中可用 <https://wiki.ros.org/roslaunch/XML/param>`__."


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:57
msgid "Used for passing a parameter to a node."
msgstr "用于将参数传递给节点。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:58
msgid "There's no global parameter concept in ROS 2. For that reason, it can only be used nested in a ``node`` tag. Some attributes aren't supported in ROS 2: ``type``, ``textfile``, ``binfile``, ``executable``, ``command``."
msgstr "在ROS 2中没有全局参数的概念。因此，它只能嵌套在``node``标记中使用。在ROS 2中不支持某些属性: ``type``、``textfile``、``binfile``、``executable``、``command``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:74 ../../source/How-To-Guides/Launch-files-migration-guide.rst:406
msgid "Type inference rules"
msgstr "类型推断规则"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:76
msgid "Here are some examples of how to write parameters:"
msgstr "以下是一些编写参数的示例:"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:104
msgid "Parameter grouping"
msgstr "参数分组"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:106
msgid "In ROS 2, ``param`` tags are allowed to be nested. For example:"
msgstr "在ROS 2中，允许嵌套``param``标签。例如："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:120
msgid "That will create two parameters:"
msgstr "这将创建两个参数："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:122
msgid "A ``group1.group2.my_param`` of value ``1``, hosted by node ``/an_absolute_ns/my_node``."
msgstr "一个值为``1``的``group1.group2.my_param``，由节点``/an_absolute_ns/my_node``托管。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:123
msgid "A ``group1.another_param`` of value ``2`` hosted by node ``/an_absolute_ns/my_node``."
msgstr "节点 ``/an_absolute_ns/my_node`` 托管的 ``group1.another_param`` 的值为 ``2``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:125
msgid "It's also possible to use full parameter names:"
msgstr "也可以使用完整的参数名称："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:135
msgid "rosparam"
msgstr "rosparam"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:137
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/rosparam>`__."
msgstr "在 ROS 1 中可用 <https://wiki.ros.org/roslaunch/XML/rosparam>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:138
msgid "Loads parameters from a yaml file."
msgstr "从yaml文件中加载参数。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:139
msgid "It has been replaced with a ``from`` attribute in ``param`` tags."
msgstr "已被``param``标签中的``from``属性替代。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:151
msgid "remap"
msgstr "remap"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:153
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/remap>`__."
msgstr "`在ROS 1中可用<https://wiki.ros.org/roslaunch/XML/remap>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:154
msgid "Used to pass remapping rules to a node."
msgstr "用于将重新映射规则传递给节点。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:155
msgid "It can only be used within ``node`` tags."
msgstr "它只能在``node``标签内使用。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:172
msgid "include"
msgstr "包括"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:174
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/include>`__."
msgstr "`在ROS 1中可用 <https://wiki.ros.org/roslaunch/XML/include>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:175
msgid "Allows including another launch file."
msgstr "允许包含另一个启动文件。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:178
msgid "Available in ROS 1, included content was scoped. In ROS 2, it's not. Nest includes in ``group`` tags to scope them."
msgstr "在ROS 1中可用，所包含的内容是有作用域的。在ROS 2中，它没有作用域。使用``group``标签来嵌套包含文件以进行作用域控制。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:181
msgid "``ns`` attribute is not supported. See example of ``push_ros_namespace`` tag for a workaround."
msgstr "不支持``ns``属性。参考``push_ros_namespace``标签的示例以获取解决方法。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:183
msgid "``arg`` tags nested in an ``include`` tag don't support conditionals (``if`` or ``unless``)."
msgstr "嵌套在``include``标签中的``arg``标签不支持条件语句（``if``或``unless``）。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:184
msgid "There is no support for nested ``env`` tags. ``set_env`` and ``unset_env`` can be used instead."
msgstr "不支持嵌套``env``标签。可以使用``set_env``和``unset_env``代替。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:186
msgid "Both ``clear_params`` and ``pass_all_args`` attributes aren't supported."
msgstr "不支持``clear_params``和``pass_all_args``属性。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:189 ../../source/How-To-Guides/Using-callback-groups.rst:183
msgid "Examples"
msgstr "示例"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:191
msgid "See `Replacing an include tag`_."
msgstr "请参阅`替换 include 标签`_。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:194
msgid "arg"
msgstr "arg"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:196
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/arg>`__."
msgstr "`在ROS 1中可用 <https://wiki.ros.org/roslaunch/XML/arg>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:197
msgid "``arg`` is used for declaring a launch argument, or to pass an argument when using ``include`` tags."
msgstr "``arg`` 用于声明一个启动参数，或者在使用 ``include`` 标签时传递参数。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:200
msgid "``value`` attribute is not allowed. Use ``let`` tag for this."
msgstr "不允许使用 ``value`` 属性。请使用 ``let`` 标签代替。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:202
msgid "``doc`` is now ``description``."
msgstr "现在，``doc`` 变为 ``description``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:203
msgid "When nested within an ``include`` tag, ``if`` and ``unless`` attributes aren't allowed."
msgstr "当嵌套在 ``include`` 标签内时，不允许使用 ``if`` 和 ``unless`` 属性。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:221
msgid "Passing an argument to the launch file"
msgstr "向启动文件传递参数"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:223
msgid "In the XML launch file above, the ``topic_name`` defaults to the name ``chatter``, but can be configured on the command-line. Assuming the above launch configuration is in a file named ``mylaunch.xml``, a different topic name can be used by launching it with the following:"
msgstr "在上述 XML 启动文件中，``topic_name`` 默认为 ``chatter``，但可以通过命令行进行配置。假设上述启动配置保存在名为 ``mylaunch.xml`` 的文件中，可以通过以下命令启动并使用不同的主题名称："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:230
msgid "There is some additional information about passing command-line arguments in :doc:`Using Substitutions <../Tutorials/Intermediate/Launch/Using-Substitutions>`."
msgstr "关于在 :doc:`使用替换 <../Tutorials/Intermediate/Launch/Using-Substitutions>` 中传递命令行参数，有一些额外的信息。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:233
msgid "env"
msgstr "env"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:235
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/env>`__."
msgstr "`在 ROS 1 中可用 <https://wiki.ros.org/roslaunch/XML/env>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:236
msgid "Sets an environment variable."
msgstr "设置环境变量。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:237
msgid "It has been replaced with ``env``, ``set_env`` and ``unset_env``:"
msgstr "已被替换为 ``env``、``set_env`` 和 ``unset_env``："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:239
msgid "``env`` can only be used nested in a ``node`` or ``executable`` tag. ``if`` and ``unless`` tags aren't supported."
msgstr "``env`` 只能嵌套在 ``node`` 或 ``executable`` 标签中。不支持 ``if`` 和 ``unless`` 标签。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:241
msgid "``set_env`` can be nested within the root tag ``launch`` or in ``group`` tags. It accepts the same attributes as ``env``, and also ``if`` and ``unless`` tags."
msgstr "``set_env`` 可以嵌套在根标签 ``launch`` 或 ``group`` 标签中。它接受与 ``env`` 相同的属性，还支持 ``if`` 和 ``unless`` 标签。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:243
msgid "``unset_env`` unsets an environment variable. It accepts a ``name`` attribute and conditionals."
msgstr "``unset_env`` 取消设置环境变量。它接受一个 ``name`` 属性和条件语句。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:266
msgid "group"
msgstr "组"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:268
msgid "`Available in ROS 1 <https://wiki.ros.org/roslaunch/XML/group>`__."
msgstr "`在ROS 1中可用 <https://wiki.ros.org/roslaunch/XML/group>`__。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:269
msgid "Allows limiting the scope of launch configurations. Usually used together with ``let``, ``include`` and ``push_ros_namespace`` tags."
msgstr "允许限制启动配置的范围。通常与``let``、``include``和``push_ros_namespace``标签一起使用。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:273
msgid "There is no ``ns`` attribute. See the new ``push_ros_namespace`` tag as a workaround."
msgstr "没有``ns``属性。可以使用新的``push_ros_namespace``标签作为解决方法。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:275
msgid "``clear_params`` attribute isn't available."
msgstr "``clear_params`` 属性不可用。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:276
msgid "It doesn't accept ``remap`` nor ``param`` tags as children."
msgstr "它不接受 ``remap`` 和 ``param`` 标签作为子节点。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:283
msgid "``launch-prefix`` configuration affects both ``executable`` and ``node`` tags' actions. This example will use ``time`` as a prefix if ``use_time_prefix_in_talker`` argument is ``1``, only for the talker."
msgstr "``launch-prefix`` 配置会影响 ``executable`` 和 ``node`` 标签的操作。如果 ``use_time_prefix_in_talker`` 参数为 ``1``，此示例将使用 ``time`` 作为前缀，仅适用于 talker。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:298
msgid "machine"
msgstr "machine"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:300 ../../source/How-To-Guides/Launch-files-migration-guide.rst:305
msgid "It is not supported at the moment."
msgstr "目前不支持。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:303
msgid "test"
msgstr "测试"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:308
msgid "New tags in ROS 2"
msgstr "ROS 2中的新标签"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:311
msgid "set_env and unset_env"
msgstr "set_env和unset_env"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:313
msgid "See `env`_ tag decription."
msgstr "查看 `env`_ 标签说明。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:316
msgid "push_ros_namespace"
msgstr "push_ros_namespace"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:318
msgid "``include`` and ``group`` tags don't accept an ``ns`` attribute. This action can be used as a workaround:"
msgstr "``include`` 和 ``group`` 标签不接受 ``ns`` 属性。可以使用以下操作作为解决方法："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:340
msgid "let"
msgstr "let"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:342
msgid "It's a replacement of ``arg`` tag with a value attribute."
msgstr "使用`value`属性替代了``arg``标签。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:349
msgid "executable"
msgstr "可执行文件"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:351
msgid "It allows running any executable."
msgstr "允许运行任何可执行文件。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:363
msgid "Replacing an include tag"
msgstr "替换了`include`标签"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:365
msgid "In order to include a launch file under a **namespace** as in ROS 1 then the ``include`` tags must be nested in a ``group`` tag."
msgstr "为了在ROS 1中像**命名空间**一样包含启动文件，则必须将``include``标签嵌套在``group``标签中。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:373
msgid "Then, instead of using the ``ns`` attribute, add the ``push_ros_namespace`` action tag to specify the namespace:"
msgstr "然后，不再使用``ns``属性，而是添加``push_ros_namespace``操作标签来指定命名空间："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:382
msgid "Nesting ``include`` tags under a ``group`` tag is only required when specifying a namespace"
msgstr "只有在指定命名空间时才需要将``include``标签嵌套在``group``标签下。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:385
msgid "Substitutions"
msgstr "替换"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:387
msgid "Documentation about ROS 1's substitutions can be found in `roslaunch XML wiki <https://wiki.ros.org/roslaunch/XML>`__. Substitutions syntax hasn't changed, i.e. it still follows the ``$(substitution-name arg1 arg2 ...)`` pattern. There are, however, some changes w.r.t. ROS 1:"
msgstr "关于ROS 1的替代方案的文档可以在 `roslaunch XML wiki <https://wiki.ros.org/roslaunch/XML>`__ 中找到。替代语法没有改变，仍然遵循 ``$(substitution-name arg1 arg2 ...)`` 的模式。然而，与ROS 1相比，有一些变化："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:391
msgid "``env`` and ``optenv`` tags have been replaced by the ``env`` tag. ``$(env <NAME>)`` will fail if the environment variable doesn't exist. ``$(env <NAME> '')`` does the same as ROS 1's ``$(optenv <NAME>)``. ``$(env <NAME> <DEFAULT>)`` does the same as ROS 1's ``$(env <NAME> <DEFAULT>)`` or ``$(optenv <NAME> <DEFAULT>)``."
msgstr "``env`` 和 ``optenv`` 标签已被 ``env`` 标签替代。如果环境变量不存在，``$(env <NAME>)`` 将失败。``$(env <NAME> '')`` 与ROS 1的 ``$(optenv <NAME>)`` 功能相同。``$(env <NAME> <DEFAULT>)`` 与ROS 1的 ``$(env <NAME> <DEFAULT>)`` 或 ``$(optenv <NAME> <DEFAULT>)`` 功能相同。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:395
msgid "``find`` has been replaced with ``find-pkg-share`` (substituting the share directory of an installed package). Alternatively ``find-pkg-prefix`` will return the root of an installed package."
msgstr "``find`` 被 ``find-pkg-share`` 替代（用于替代已安装包的共享目录）。或者，``find-pkg-prefix`` 将返回已安装包的根目录。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:397
msgid "There is a new ``exec-in-pkg`` substitution. e.g.: ``$(exec-in-pkg <package_name> <exec_name>)``."
msgstr "新增了一个 ``exec-in-pkg`` 替代。例如：``$(exec-in-pkg <package_name> <exec_name>)``。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:399
msgid "There is a new ``find-exec`` substitution."
msgstr "有一个新的 ``find-exec`` 替代方式。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:400
msgid "``arg`` has been replaced with ``var``. It looks at configurations defined either with ``arg`` or ``let`` tag."
msgstr "``arg`` 已被替换为 ``var``。它查看使用 ``arg`` 或 ``let`` 标签定义的配置。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:402
msgid "``eval`` and ``dirname`` substitutions haven't changed."
msgstr "``eval`` 和 ``dirname`` 替代方式没有改变。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:403
msgid "``anon`` substitution is not supported."
msgstr "不支持 ``anon`` 替代方式。"


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:408
msgid "The rules that were shown in ``Type inference rules`` subsection of ``param`` tag applies to any attribute. For example:"
msgstr "在``param``标签的``Type inference rules``子节中显示的规则适用于任何属性。例如："


#: ../../source/How-To-Guides/Launch-files-migration-guide.rst:426
msgid "Some attributes accept more than a single type, for example ``value`` attribute of ``param`` tag. It's usual that parameters that are of type ``int`` (or ``float``) also accept an ``str``, that will be later substituted and tried to convert to an ``int`` (or ``float``) by the action."
msgstr "有些属性接受多个类型，例如``param``标签的``value``属性。通常情况下，类型为``int``（或``float``）的参数也可以接受``str``，后者将在后续进行替换，并尝试转换为``int``（或``float）``。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:2
msgid "Using ROS 2 launch to launch composable nodes"
msgstr "使用ROS 2 launch启动可组合节点"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:8
msgid "In the :doc:`Composition tutorial <../Tutorials/Intermediate/Composition>`, you learned about composable nodes and how to use them from the command-line. In the :doc:`Launch tutorials <../Tutorials/Intermediate/Launch/Launch-Main>`, you learned about launch files and how to use them to manage multiple nodes."
msgstr "在:doc:`组合教程<../Tutorials/Intermediate/Composition>`中，您了解了可组合节点以及如何从命令行中使用它们。在:doc:`启动教程<../Tutorials/Intermediate/Launch/Launch-Main>`中，您了解了启动文件以及如何使用它们来管理多个节点。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:11
msgid "This guide will combine the above two topics and teach you how to write launch files for composable nodes."
msgstr "本指南将结合上述两个主题，教您如何为可组合节点编写启动文件。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:14
msgid "Setup"
msgstr "设置"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:16
msgid "See the :doc:`installation instructions <../Installation>` for details on installing ROS 2."
msgstr "有关在安装ROS 2上的详细信息，请参阅:doc:`安装说明 <../Installation>`。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:18
msgid "If you've installed ROS 2 from packages, ensure that you have ``ros-humble-image-tools`` installed. If you downloaded the archive or built ROS 2 from source, it will already be part of the installation."
msgstr "如果您从软件包安装了ROS 2，请确保已安装``ros-humble-image-tools``。如果您下载了存档文件或从源代码构建了ROS 2，它已经是安装的一部分。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:24
msgid "Below is a launch file that launches composable nodes in Python, XML, and YAML. The launch files all do the following:"
msgstr "下面是一个启动文件，用于在Python、XML和YAML中启动可组合节点。所有的启动文件都执行以下操作："


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:27
msgid "Instantiate a cam2image composable node with remappings, custom parameters, and extra arguments"
msgstr "实例化一个带有重新映射、自定义参数和额外参数的cam2image可组合节点"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:28
msgid "Instantiate a showimage composable node with remappings, custom parameters, and extra arguments"
msgstr "实例化一个带有重新映射、自定义参数和额外参数的showimage可组合节点"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:139
msgid "Loading composable nodes into an existing container"
msgstr "将可组合节点加载到现有容器中"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:141
msgid "Containers can sometimes be launched by other launch files or from a commandline. In that case, you need to add your components to an existing container. For this, you may use ``LoadComposableNodes`` to load components into a given container. The below example launches the same nodes as above."
msgstr "有时候容器可以由其他启动文件或命令行启动。在这种情况下，您需要将您的组件添加到现有容器中。为此，您可以使用``LoadComposableNodes``将组件加载到给定的容器中。下面的示例启动与上述相同的节点。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:259
msgid "Using the Launch files from the command-line"
msgstr "从命令行使用启动文件"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:261
msgid "Any of the launch files above can be run with ``ros2 launch``. Copy the data into a local file, and then run:"
msgstr "上述任何一个启动文件都可以使用``ros2 launch``命令来运行。将数据复制到一个本地文件中，然后运行："


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:269
msgid "Intra-process communications"
msgstr "进程内通信"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:271
msgid "All of the above examples use an extra argument to setup intra-process communication between the nodes. For more information on what intra-process communications are, see the :doc:`intra-process comms tutorial <../Tutorials/Demos/Intra-Process-Communication>`."
msgstr "上述所有示例都使用了额外的参数来设置节点之间的进程内通信。有关进程内通信的更多信息，请参阅:doc:`进程内通信教程<../Tutorials/Demos/Intra-Process-Communication>`。"


#: ../../source/How-To-Guides/Launching-composable-nodes.rst:277
msgid "See the discussion in :doc:`Launch-file-different-formats` for more information."
msgstr "有关更多信息，请参阅:doc:`启动文件不同格式的讨论<Launch-file-different-formats>`。"


#: ../../source/How-To-Guides/Node-arguments.rst:8
msgid "Passing ROS arguments to nodes via the command-line"
msgstr "通过命令行向节点传递ROS参数"


#: ../../source/How-To-Guides/Node-arguments.rst:15
msgid "All ROS nodes take a set of arguments that allow various properties to be reconfigured. Examples include configuring the name/namespace of the node, topic/service names used, and parameters on the node. All ROS-specific arguments have to be specified after a ``--ros-args`` flag:"
msgstr "所有ROS节点都接受一组参数，允许重新配置各种属性。例如，配置节点的名称/命名空间、使用的话题/服务名称和节点上的参数。所有ROS特定的参数都必须在``--ros-args``标志之后指定："


#: ../../source/How-To-Guides/Node-arguments.rst:25
msgid "For more details, see `this design doc <https://design.ros2.org/articles/ros_command_line_arguments.html>`__."
msgstr "更多详细信息，请参阅`这个设计文档 <https://design.ros2.org/articles/ros_command_line_arguments.html>`__。"


#: ../../source/How-To-Guides/Node-arguments.rst:28
msgid "Name remapping"
msgstr "名称重映射"


#: ../../source/How-To-Guides/Node-arguments.rst:30
msgid "Names within a node (e.g. topics/services) can be remapped using the syntax ``-r <old name>:=<new name>``. The name/namespace of the node itself can be remapped using ``-r __node:=<new node name>`` and ``-r __ns:=<new node namespace>``."
msgstr "可以使用语法``-r <旧名称>:=<新名称>``对节点内的名称（例如：topics/services）进行重映射。节点本身的名称/命名空间可以使用``-r __node:=<新节点名称>``和``-r __ns:=<新节点命名空间>``进行重映射。"


#: ../../source/How-To-Guides/Node-arguments.rst:34
msgid "Note that these remappings are \"static\" remappings, in that they apply for the lifetime of the node. \"Dynamic\" remapping of names after nodes have been started is not yet supported."
msgstr "请注意，这些重映射是\"静态\"重映射，即它们在节点的生命周期内生效。目前尚不支持在节点启动后动态重映射名称。"


#: ../../source/How-To-Guides/Node-arguments.rst:37
msgid "See `this design doc <https://design.ros2.org/articles/static_remapping.html>`__ for more details on remapping arguments (not all functionality is available yet)."
msgstr "请参考 `此设计文档 <https://design.ros2.org/articles/static_remapping.html>`__，了解有关重新映射参数的详细信息（并非所有功能都可用）"


#: ../../source/How-To-Guides/Node-arguments.rst:42
msgid "The following invocation will cause the ``talker`` node to be started under the node name ``my_talker``, publishing on the topic named ``my_topic`` instead of the default of ``chatter``. The namespace, which must start with a forward slash, is set to ``/demo``, which means that topics are created in that namespace (``/demo/my_topic``), as opposed to globally (``/my_topic``)."
msgstr "以下调用将使``talker``节点以节点名称``my_talker``启动，发布到名为``my_topic``的主题，而不是默认的``chatter``。命名空间必须以正斜杠开头，设置为``/demo``，这意味着主题在该命名空间中创建（``/demo/my_topic``），而不是全局（``/my_topic``）"


#: ../../source/How-To-Guides/Node-arguments.rst:50
msgid "Passing remapping arguments to specific nodes"
msgstr "向特定节点传递重新映射参数"


#: ../../source/How-To-Guides/Node-arguments.rst:52
msgid "If multiple nodes are being run within a single process (e.g. using :doc:`Composition <../Concepts/About-Composition>`), remapping arguments can be passed to a specific node using its name as a prefix. For example, the following will pass the remapping arguments to the specified nodes:"
msgstr "如果在单个进程中运行多个节点（例如使用：doc：`Composition <../Concepts/About-Composition>`），可以使用节点名称作为前缀将重新映射参数传递给特定节点。例如，以下内容将重新映射参数传递给指定的节点："


#: ../../source/How-To-Guides/Node-arguments.rst:60
msgid "The following example will both change the node name and remap a topic (node and namespace changes are always applied *before* topic remapping):"
msgstr "下面的示例将同时更改节点名称和重新映射一个主题（节点和命名空间的更改总是在主题重新映射之前应用）："


#: ../../source/How-To-Guides/Node-arguments.rst:68
msgid "Logger configuration"
msgstr "日志记录器配置"


#: ../../source/How-To-Guides/Node-arguments.rst:70
msgid "See ``--log-level`` argument usage in :doc:`the logging page <../Tutorials/Demos/Logging-and-logger-configuration>`."
msgstr "请参阅 :doc:`日志记录页面中的--log-level参数用法 <../Tutorials/Demos/Logging-and-logger-configuration>`。"


#: ../../source/How-To-Guides/Node-arguments.rst:73
msgid "Parameters"
msgstr "参数"


#: ../../source/How-To-Guides/Node-arguments.rst:78
msgid "Setting parameters directly from the command line"
msgstr "直接从命令行设置参数"


#: ../../source/How-To-Guides/Node-arguments.rst:80
msgid "You can set parameters directly from the command line using the following syntax:"
msgstr "您可以使用以下语法直接从命令行设置参数:"


#: ../../source/How-To-Guides/Node-arguments.rst:86
msgid "As an example, you can run:"
msgstr "例如，您可以运行:"


#: ../../source/How-To-Guides/Node-arguments.rst:92 ../../source/How-To-Guides/Node-arguments.rst:135
msgid "Other nodes will be able to retrieve the parameter values, e.g.:"
msgstr "其他节点将能够检索参数值，例如:"


#: ../../source/How-To-Guides/Node-arguments.rst:108
msgid "Setting parameters from YAML files"
msgstr "从YAML文件中设置参数"


#: ../../source/How-To-Guides/Node-arguments.rst:110
msgid "Parameters can be set from the command-line in the form of yaml files."
msgstr "参数可以以yaml文件的形式通过命令行设置。"


#: ../../source/How-To-Guides/Node-arguments.rst:112
msgid "`See here <https://github.com/ros2/rcl/tree/humble/rcl_yaml_param_parser>`__ for examples of the yaml file syntax."
msgstr "有关yaml文件语法的示例，请参阅此处 <https://github.com/ros2/rcl/tree/humble/rcl_yaml_param_parser>。"


#: ../../source/How-To-Guides/Node-arguments.rst:114
msgid "As an example, save the following as ``demo_params.yaml``:"
msgstr "例如，将以下内容保存为 ``demo_params.yaml`` 文件："


#: ../../source/How-To-Guides/Node-arguments.rst:126
msgid "Then either declare the parameters within your node with ``declare_parameter``  or ``declare_parameters`` (see `documentation <https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1Node.html#a095ea977b26e7464d9371efea5f36c42>`__ for function signatures), or `set the node to automatically declare parameters <https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1NodeOptions.html#a094ceb7af7c9b358ec007a4b8e14d40d>`__ if they were passed in via a command line override."
msgstr "然后，您可以在节点内使用 ``declare_parameter`` 或 ``declare_parameters``（请参阅 `文档 <https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1Node.html#a095ea977b26e7464d9371efea5f36c42>`__ 了解函数签名）声明参数，或者如果通过命令行覆盖传递了参数，则可以 `设置节点自动声明参数 <https://docs.ros2.org/foxy/api/rclcpp/classrclcpp_1_1NodeOptions.html#a094ceb7af7c9b358ec007a4b8e14d40d>`__。"


#: ../../source/How-To-Guides/Node-arguments.rst:128
msgid "Then run the following:"
msgstr "然后运行以下命令："


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:9
msgid "rosbag2: Overriding QoS Policies"
msgstr "rosbag2：覆盖 QoS 策略"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:11
msgid "**Goal:** Override Ros2Bag QoS profile settings for recording and playback."
msgstr "**目标：**为录制和播放覆盖 Ros2Bag 的 QoS 配置文件设置。"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:21
msgid "With the introduction of DDS in ROS 2, Quality of Service (QoS) compatibility for publisher/subscriber nodes needs to be considered when recording and playing back data. More detail on how QoS works can be found :doc:`here <../Concepts/About-Quality-of-Service-Settings>`. For the purposes of this guide, it is sufficient to know that only the reliability and durability policies affect whether publishers/subscribers are compatible and can receive data from one other."
msgstr "随着DDS在ROS 2中的引入，在记录和回放数据时需要考虑发布者/订阅者节点的服务质量（QoS）兼容性。有关QoS工作原理的更多细节可以在此处找到：doc:`这里 <../Concepts/About-Quality-of-Service-Settings>`。对于本指南而言，只需知道可靠性和持久性策略会影响发布者/订阅者是否兼容并能够接收彼此的数据即可。"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:25
msgid "Ros2Bag adapts its requested/offered QoS profile when recording/playing data from a topic to prevent dropped messages. During playback, Ros2bag also attempts to preserve the policy originally offered by the topic. Certain situations may require specifying explicit QoS profile settings so Ros2Bag can record/playback topics. These QoS profile overrides can be specified via the CLI using the ``--qos-profile-overrides-path`` flag."
msgstr "Ros2Bag在记录/播放主题数据时会根据需要调整其请求/提供的QoS配置文件，以防止丢失消息。在回放过程中，Ros2bag还会尝试保持主题最初提供的策略。在某些情况下，可能需要指定显式的QoS配置文件设置，以便Ros2Bag能够记录/播放主题。可以通过使用``--qos-profile-overrides-path``标志在CLI中指定这些QoS配置文件覆盖。"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:31
msgid "Using QoS Overrides"
msgstr "使用QoS配置文件覆盖"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:33
msgid "The YAML schema for the profile overrides is a dictionary of topic names with key/value pairs for each QoS policy:"
msgstr "配置文件覆盖的YAML模式是一个包含主题名称的字典，每个QoS策略都有键值对："


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:44
msgid "If a policy value is not specified, the value will fallback to the default used by Ros2Bag. If you specify a Duration based policy such as ``deadline`` or ``lifespan``, you will need to specify both seconds and nanoseconds. Policy values are determined by the policy’s short keys which can be found using ``ros2topic`` verbs such as ``ros2 topic pub --help``. All values are replicated below for reference."
msgstr "如果未指定策略值，该值将回退到Ros2Bag使用的默认值。如果您指定了基于持续时间的策略，例如``deadline``或``lifespan``，则需要同时指定秒和纳秒。策略值由策略的短键确定，可以使用``ros2topic``命令的动词（如``ros2 topic pub --help``）找到。下面列出了所有值以供参考。"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:70
msgid "Consider a topic ``/talker`` offering a ``transient_local`` Durability policy. ROS 2 publishers by default request ``volatile`` Durability."
msgstr "考虑一个提供``transient_local``持续性策略的主题``/talker``。ROS 2发布者默认情况下请求``volatile``持续性。"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:77
msgid "In order for Ros2Bag to record the data, we would want to override the recording policy for that specific topic like so:"
msgstr "为了让Ros2Bag记录数据，我们需要覆盖该特定主题的记录策略，操作如下："


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:86 ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:101
msgid "And call it from the CLI:"
msgstr "然后从命令行调用它："


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:92
msgid "If we want to playback the bag file but with a different Reliability policy, we can specify one as such;"
msgstr "如果我们想使用不同的可靠性策略回放bag文件，我们可以这样指定；"


#: ../../source/How-To-Guides/Overriding-QoS-Policies-For-Recording-And-Playback.rst:107
msgid "We can see the results with ``ros2 topic``"
msgstr "我们可以使用``ros2 topic``查看结果"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:6
msgid "ROS 2 Package Maintainer Guide"
msgstr "ROS 2软件包维护人员指南"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:8
msgid "Each package in the ROS 2 core has one or more maintainers that are responsibile for the general health of the package. This guide gives some information about the responsibilities of a ROS 2 core package maintainer."
msgstr "ROS 2核心中的每个软件包都有一个或多个维护人员，负责维护软件包的整体健康状况。本指南介绍了ROS 2核心软件包维护人员的责任和一些信息。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:15
msgid "Reviews"
msgstr "评论"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:17
msgid "All incoming code to ROS 2 core repositories must be reviewed. The review is looking for:"
msgstr "所有提交到ROS 2核心仓库的代码都必须进行审核。审核会关注以下方面："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:20
msgid "Suitability in the package"
msgstr "适用于该包的合适性"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:21
msgid "Correct code"
msgstr "正确的代码"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:22
msgid "Conforms to developer guidelines:"
msgstr "符合开发者指南要求："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:24
msgid ":doc:`Developer Guide <../The-ROS2-Project/Contributing/Developer-Guide>`"
msgstr ":doc:`开发者指南 <../The-ROS2-Project/Contributing/Developer-Guide>`"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:25
msgid ":doc:`Code Style Guide <../The-ROS2-Project/Contributing/Code-Style-Language-Versions>`"
msgstr ":doc:`代码风格指南 <../The-ROS2-Project/Contributing/Code-Style-Language-Versions>`"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:27
msgid "Adds tests for the bug/feature"
msgstr "为错误/功能添加测试"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:28
msgid "Adds documentation for new features"
msgstr "增加新功能的文档"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:29
msgid "Clean Continuous Integration run"
msgstr "清理持续集成运行"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:30
msgid "Targets default branch (usually \"rolling\")"
msgstr "目标是默认分支（通常是“rolling”）"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:31
msgid "Has at least one approval from a maintainer that is not the author"
msgstr "至少有一位维护者（非作者）的批准"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:34
msgid "Continuous Integration"
msgstr "持续集成"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:36
msgid "All incoming code to ROS 2 core repositories must be run through Continuous Integration. ROS 2 currently has two separate CI systems, and it is required that PRs pass both of them before merging."
msgstr "所有提交到ROS 2核心仓库的代码都必须通过持续集成进行运行。目前ROS 2有两个独立的持续集成系统，要求在合并之前必须通过这两个系统的PR（拉取请求）。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:40
msgid "PR builds (https://build.ros2.org/view/Rpr)"
msgstr "PR构建（https://build.ros2.org/view/Rpr）"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:42
msgid "ROS 2 PR (Pull Request) builds run automatically every time a pull request is opened. These builds run a build and test of this package, and this package only. This means that it does not build any dependencies, and it also does not build any packages that depend upon this package. These builds are good for quick feedback to see if the change passes linters, unit tests, etc. There are two major problems with them:"
msgstr "ROS 2的PR（拉取请求）构建在每次打开拉取请求时会自动运行。这些构建只会构建和测试该软件包本身，不会构建任何依赖项，也不会构建依赖于该软件包的任何其他软件包。这些构建适用于快速反馈，以查看更改是否通过了代码检查、单元测试等。然而，它们存在两个主要问题："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:48
msgid "These builds do not work across multiple repositories (so won't work for adding or changing an API, etc)"
msgstr "这些构建不适用于多个代码库（因此不能用于添加或更改 API 等）"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:49
msgid "These tests only run on Linux (they won't run on macOS or Windows)"
msgstr "这些测试只在 Linux 上运行（它们无法在 macOS 或 Windows 上运行）"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:51
msgid "To address these two problems, there is also the CI builds."
msgstr "为了解决这两个问题，还有 CI 构建。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:54
msgid "CI builds (https://ci.ros2.org)"
msgstr "CI 构建（https://ci.ros2.org）"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:56
msgid "CI builds do not run automatically when a pull request is opened. One of the maintainers of the package must manually request that a CI build is done by going to https://ci.ros2.org/job/ci_launcher/ ."
msgstr "当打开拉取请求时，CI构建不会自动运行。软件包的维护人员之一必须手动请求执行CI构建，方法是访问https://ci.ros2.org/job/ci_launcher/。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:59
msgid "By default, running a job in this way will build and run tests for all packages (> 300 currently) on all platforms (Linux, macOS, and Windows). As a full run can take many hours and tie up the CI machines, it is recommended that all runs here restrict the number of packages that are built and tested. This can be accomplished by using the colcon arguments ``--packages-up-to``, ``--packages-select``, ``--packages-above-and-dependencies``, ``--packages-above``, amongst others. See the `colcon documentation <https://colcon.readthedocs.io/en/released/user/how-to.html#build-only-a-single-package-or-selected-packages>`__ for more examples on the flags that can be used. Further documentation on how to use the CI machinery is available at https://github.com/ros2/ci/blob/master/CI_BUILDERS.md."
msgstr "默认情况下，以这种方式运行作业将在所有平台（Linux、macOS和Windows）上构建和运行所有软件包（>300个当前版本）的测试。由于完整运行可能需要很多小时并占用CI机器的资源，建议在此处的所有运行中限制构建和测试的软件包数量。可以使用colcon参数``--packages-up-to``、``--packages-select``、``--packages-above-and-dependencies``、``--packages-above``等来实现。有关可用标志的更多示例，请参阅`colcon文档<https://colcon.readthedocs.io/en/released/user/how-to.html#build-only-a-single-package-or-selected-packages>`__。有关如何使用CI工具的更多文档，请访问https://github.com/ros2/ci/blob/master/CI_BUILDERS.md。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:66
msgid "Merging Pull Requests"
msgstr "合并拉取请求"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:68
msgid "A pull request can be merged if all of the following are true:"
msgstr "只有满足以下所有条件时，才可以合并拉取请求："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:70
msgid "The DCO bot reports a passing result"
msgstr "DCO 机器人报告通过的结果"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:71
msgid "The PR build reports a passing result"
msgstr "PR 构建报告通过的结果"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:72
msgid "The CI build reports a passing result on all platforms"
msgstr "CI 构建在所有平台上报告通过的结果"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:73
msgid "The code has been reviewed and approved by at least one maintainer"
msgstr "代码已被至少一名维护者审查并批准"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:75
msgid "After a PR is merged, it will automatically get built with the next `nightlies <https://ci.ros2.org/view/nightly>`__. It is highly recommended to check the nightlies after merging pull requests to ensure no regressions have occurred."
msgstr "合并了 PR 后，它将自动与下一个 `夜间构建版本 <https://ci.ros2.org/view/nightly>`__ 一起构建。强烈建议在合并拉取请求后检查夜间构建版本，以确保没有发生回归。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:79
msgid "Keeping CI green"
msgstr "保持 CI 绿色"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:81
msgid "The nightly jobs that run tests are typically much more comprehensive than what is done for individual pull requests. For this reason, there can be regressions that occur in the nightlies that were not seen in the CI jobs. It is a package maintainers responsibility to check for regressions in their packages at the following locations:"
msgstr "运行测试的夜间任务通常比为单个拉取请求执行的任务要全面得多。因此，在夜间构建版本中可能会发生在 CI 任务中未出现的回归。包维护者有责任在以下位置检查其包是否存在回归："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:85
msgid "https://ci.ros2.org/view/nightly"
msgstr "https://ci.ros2.org/view/nightly"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:86
msgid "https://ci.ros2.org/view/packaging"
msgstr "https://ci.ros2.org/view/packaging"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:87
msgid "https://build.ros2.org/view/Rci"
msgstr "https://build.ros2.org/view/Rci"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:88
msgid "https://build.ros2.org/view/Rdev"
msgstr "https://build.ros2.org/view/Rdev"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:90
msgid "For any problems that are found, new issues and/or pull requests on the relevant repositories should be opened."
msgstr "如发现任何问题，请在相关仓库上开启新的问题(issue)和/或拉取请求(pull requests)。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:93
msgid "Making releases"
msgstr "发布版本"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:95
msgid "In order to get new features and bugfixes out to end users, the package maintainers must periodically do a release of the package (a release may also be requested on-demand from other maintainers)."
msgstr "为了将新功能和错误修复传递给最终用户，软件包维护人员必须定期发布软件包（也可以根据其他维护人员的要求按需发布）。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:97
msgid "As outlined in the :ref:`developer guide <semver>`, ROS 2 packages follow semver for version numbers."
msgstr "如在开发人员指南的 :ref:`版本号规范 <semver>` 中所述，ROS 2 软件包遵循语义化版本号规范。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:99
msgid "A release in ROS terms consists of two distinct steps: making a source release, and then making a binary release."
msgstr "在ROS术语中，发布分为两个不同的步骤：制作源代码版本和制作二进制版本。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:102
msgid "Source release"
msgstr "源代码发布"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:104
msgid "A source release creates a changelog and a tag in the relevant repository."
msgstr "源代码发布会在相关的代码库中创建一个变更日志和一个标签。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:106
msgid "The process starts by generating or updating CHANGELOG.rst files with the following command:"
msgstr "该过程从使用以下命令生成或更新 CHANGELOG.rst 文件开始："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:112
msgid "If one or more packages in the repository don't have contain CHANGELOG.rst, add the ``--all`` option to populate all of the previous commits for each package. The ``catkin_generate_changelog`` command will simply populate the files with the commit logs from the repository. Since those commit logs aren't always appropriate for a changelog, it is recommended to edit CHANGELOG.rst and edit it to make it more readable. Once editing is done, it is important to commit the updated CHANGELOG.rst file to the repository."
msgstr "如果代码库中的一个或多个软件包不包含 CHANGELOG.rst 文件，则需要添加 ``--all`` 选项，以便为每个软件包填充所有先前的提交。``catkin_generate_changelog`` 命令将简单地使用代码库中的提交日志填充这些文件。由于这些提交日志并不总是适合用作变更日志，建议编辑 CHANGELOG.rst 并将其编辑为更易读的格式。编辑完成后，重要的是将更新的 CHANGELOG.rst 文件提交到代码库中。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:117
msgid "The next step is to bump the version in the package.xml and the changelog files with the following command:"
msgstr "下一步是使用以下命令在package.xml和changelog文件中增加版本号："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:123
msgid "This command will find all of the packages in the repository, check that the changelogs exist, check that there are no uncommitted local changes, increment the version in the package.xml files, and commit/tag the changes with a bloom-compatible tag. Using this command is the best way to ensure the release versions are consistent and compatible with bloom. By default, ``catkin_prepare_release`` will bump the patch version of the packages, e.g. 0.1.1 -> 0.1.2 . However, it can also bump the minor or major number, or even have an exact version set. See the help output from ``catkin_prepare_release`` for more information."
msgstr "该命令将查找存储库中的所有软件包，检查changelog是否存在，检查是否有未提交的本地更改，增加package.xml文件中的版本号，并使用与bloom兼容的标签提交/标记更改。使用此命令是确保发布版本与bloom一致且兼容的最佳方式。默认情况下，`catkin_prepare_release`会增加软件包的修补版本，例如 0.1.1 -> 0.1.2。然而，它也可以增加次要版本号或主要版本号，甚至可以设置一个精确的版本号。有关更多信息，请参阅`catkin_prepare_release`的帮助输出。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:129
msgid "Assuming the above was successful, a source release has been made."
msgstr "假设上述步骤成功，已经进行了源代码的发布。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:132
msgid "Binary release"
msgstr "二进制发布"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:134
msgid "The next step is to use the ``bloom-release`` command to create a binary release. For full instructions on how to use bloom, please see http://wiki.ros.org/bloom. To do a binary release of a package, run:"
msgstr "下一步是使用 ``bloom-release`` 命令创建二进制发布。有关如何使用 bloom 的完整说明，请参阅 http://wiki.ros.org/bloom。要对软件包进行二进制发布，请运行以下命令："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:142
msgid "For instance, to release the ``rclcpp`` repository to the Humble distribution, the command would be:"
msgstr "例如，要将 ``rclcpp`` 软件库发布到 Humble 发行版，命令如下："


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:148
msgid "This command will fetch the release repository, make the necessary changes to make the release, push the changes to the release repository, and finally open a pull request to https://github.com/ros/rosdistro ."
msgstr "此命令将获取发布软件库，进行必要的更改以进行发布，将更改推送到发布软件库，最后会向 https://github.com/ros/rosdistro 发送一个拉取请求。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:151
msgid "Backporting to released distributions"
msgstr "向已发布的发行版进行回溯"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:153
msgid "All incoming changes should first land on the development branch. Once a change has been merged onto the development branch, it can be considered for backporting to released distributions. However, any backported code must not break `API <https://en.wikipedia.org/wiki/API>`__ or `ABI <https://en.wikipedia.org/wiki/Application_binary_interface>`__ in a released distribution. If a change can be backported without breaking API or ABI, then a new pull request targeting the appropriate branch should be created. The new pull request should be added to the appropriate distributions project board at https://github.com/orgs/ros2/projects. The new pull request should have all of the steps run as before, but making sure to target the distribution in question for CI, etc."
msgstr "所有传入的更改应首先落在开发分支上。一旦将更改合并到开发分支上，可以考虑将其回溯到发布的发行版中。然而，任何回溯的代码都不能在发布的发行版中破坏`API <https://en.wikipedia.org/wiki/API>`__或`ABI <https://en.wikipedia.org/wiki/Application_binary_interface>`__。如果可以在不破坏API或ABI的情况下回溯更改，那么应创建一个针对相应分支的新拉取请求。新的拉取请求应添加到 https://github.com/orgs/ros2/projects 上的相应发行版项目板中。新的拉取请求应按照之前的步骤运行，但要确保针对CI等问题的目标分发。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:161
msgid "Responding to issues"
msgstr "回应问题"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:163
msgid "Package maintainers should also look at incoming issues on the repository and triage the problems that users are having."
msgstr "软件包维护者还应查看存储库上的问题，并对用户遇到的问题进行分类。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:165
msgid "For issues that look like questions, the issue should be closed and the user redirected to https://answers.ros.org."
msgstr "对于看起来像问题的问题，应关闭问题并将用户重定向到 https://answers.ros.org。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:167
msgid "If an issue looks like a problem, but is not relevant to this particular repository, it should be moved to the appropriate repository with the GitHub \"Transfer issue\" button."
msgstr "如果某个问题看起来像是一个问题，但与该特定存储库无关，则应使用GitHub的“转移问题”按钮将其移至相应的存储库中。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:169
msgid "If the reporter has not provided enough information to determine the cause of the problem, more information should be requested from the reporter."
msgstr "如果报告者没有提供足够的信息来确定问题的原因，则应向报告者请求更多信息。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:171
msgid "If this is a new feature, tag the issue with \"help-wanted\"."
msgstr "如果这是一个新功能，请使用“help-wanted”标记该问题。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:173
msgid "Any remaining issues should be reproduced, and determined if they are truly a bug. If it is a bug, fixes are highly appreciated."
msgstr "应重现任何剩余的问题，并确定它们是否真的是一个错误。如果是错误，请高度欢迎修复。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:177
msgid "Getting help"
msgstr "获取帮助"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:179
msgid "While doing maintenance on a package, questions about general procedures or individual issues may come up."
msgstr "在对软件包进行维护时，可能会遇到关于常规流程或个别问题的疑问。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:181
msgid "For general questions, please follow the :doc:`contributing guidelines <../The-ROS2-Project/Contributing>`."
msgstr "如有常规问题，请遵循 :doc:`贡献指南 <../The-ROS2-Project/Contributing>`。"


#: ../../source/How-To-Guides/Package-maintainer-guide.rst:183
msgid "For questions on individual issues, please tag the ROS 2 GitHub team (@ros/team), and someone on the team will take a look."
msgstr "如有个别问题，请标记ROS 2 GitHub团队（@ros/team），团队中的成员将会查看。"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:9
msgid "Migrating YAML parameter files from ROS 1 to ROS 2"
msgstr "将YAML参数文件从ROS 1迁移到ROS 2"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:11
msgid "This guide describes how to adapt ROS 1 parameters files for ROS 2."
msgstr "本指南介绍如何调整ROS 1参数文件以适应ROS 2。"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:14
msgid "YAML file example"
msgstr "YAML文件示例"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:16
msgid "YAML is used to write parameters files in both ROS 1 and ROS 2. The main difference in ROS 2 is that node names must be used to address parameters. In addition to the fully qualified node name, we use the key \"ros__parameters\" to signal the start of parameters for the node."
msgstr "在ROS 1和ROS 2中都使用YAML编写参数文件。在ROS 2中的主要区别是必须使用节点名称来引用参数。除了完全限定的节点名称外，我们还使用键“ros__parameters”来表示节点参数的起始。"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:21
msgid "For example, here is a parameters file in ROS 1:"
msgstr "例如，这是一个在ROS 1中的参数文件示例："


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:30
msgid "Let's assume that the first two parameters are for a node named ``/lidar_ns/lidar_node_name``, the next parameter is for a node named ``/imu``, and the last parameter we want to set on both nodes."
msgstr "假设前两个参数是给名为 ``/lidar_ns/lidar_node_name`` 的节点使用的，下一个参数是给名为 ``/imu`` 的节点使用的，最后一个参数我们想要在这两个节点上设置。"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:32
msgid "We would construct our ROS 2 parameters file as follows:"
msgstr "我们将按照以下方式构建我们的ROS 2参数文件："


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:48
msgid "Note the use of wildcards (``/**``) to indicate that the parameter ``debug`` should be set on any node in any namespace."
msgstr "注意使用通配符（``/**``）来表示参数 ``debug`` 应该在任何命名空间中的任何节点上设置。"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:51
msgid "Feature parity"
msgstr "功能对等"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:53
msgid "Some features of ROS 1 parameters files do not exist in ROS 2:"
msgstr "ROS 1参数文件的一些功能在ROS 2中不存在:"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:55
msgid "Mixed types in a list is not supported yet (`related issue <https://github.com/ros2/rcl/issues/463>`_)"
msgstr "列表中的混合类型尚不支持 (`相关问题 <https://github.com/ros2/rcl/issues/463>`_)"


#: ../../source/How-To-Guides/Parameters-YAML-files-migration-guide.rst:56
msgid "``deg`` and ``rad`` substitutions are not supported"
msgstr "不支持``deg``和``rad``的替换"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:8
msgid "Porting RQt plugins to Windows"
msgstr "将RQt插件移植到Windows"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:15
msgid "RQt Porting examples"
msgstr "RQt移植示例"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:17
msgid "Here is the ROS 2 port of `qt_gui_core <https://github.com/ros-visualization/qt_gui_core/commit/6fb9624033a849f56d1bc1aad0e40d252bf99c2b>`_."
msgstr "这里是`qt_gui_core <https://github.com/ros-visualization/qt_gui_core/commit/6fb9624033a849f56d1bc1aad0e40d252bf99c2b>`_的ROS 2移植版本。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:19
msgid "Here is the ROS 2 port of `python_qt_binding <https://github.com/ros-visualization/python_qt_binding/pull/56>`__."
msgstr "这里是`python_qt_binding <https://github.com/ros-visualization/python_qt_binding/pull/56>`__的ROS 2移植版本。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:22
msgid "Considerations for Windows 10"
msgstr "Windows 10 的注意事项"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:25
msgid "Troubles with TinyXML version 1"
msgstr "TinyXML 版本 1 的问题"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:27
msgid "I could not successfully use TinyXML. I upgraded to TinyXML-2 where needed. It’s a pretty straight forward change."
msgstr "我无法成功使用 TinyXML。在必要时我升级到 TinyXML-2。这是一个相当简单的变更。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:31
msgid "Checkout `this PR <https://github.com/ros-visualization/qt_gui_core/pull/147>`__ for an example of porting to TinyXML-2."
msgstr "查看 `此 PR <https://github.com/ros-visualization/qt_gui_core/pull/147>`__ 以获取将代码迁移到 TinyXML-2 的示例。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:34
msgid "Code that uses ``__cplusplus`` and code that requires pluginlib"
msgstr "使用``__cplusplus``的代码和需要pluginlib的代码"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:36
msgid "In some places, notably in the ROS 2 port of pluginlib, there is use of the ``__cplusplus`` flag. Unfortunately on Windows Visual Studio does not set this flag correctly regardless of the C++ standard that is actually being used. See `this page <https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=vs-2017>`__ for more information."
msgstr "在某些地方，尤其是在pluginlib的ROS 2端口中，使用了``__cplusplus``标志。不幸的是，在Windows Visual Studio上，无论实际使用的C++标准是什么，都无法正确设置该标志。有关更多信息，请参阅`此页面<https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=vs-2017>`__。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:40
msgid "To set it, you need to add the compile option ``/Zc:__cplusplus``."
msgstr "要设置它，您需要添加编译选项``/Zc:__cplusplus``。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:42
msgid "For example, in CMake you could do something like this:"
msgstr "例如，在CMake中，您可以这样做："


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:49
msgid "Locations of build artifacts (before install)"
msgstr "构建产物的位置（安装前）"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:51
msgid "This only came up during when building ``qt_gui_cpp``. In that package, a custom command depends on a target library in another part of the package. However, that library isn’t installed until build is complete. Windows builds in a ${configuration} directory. For example:"
msgstr "这个问题只在构建 ``qt_gui_cpp`` 时出现。在这个软件包中，自定义命令依赖于软件包的另一个部分中的目标库。然而，在构建完成之前，该库不会被安装。Windows 构建位于 ${configuration} 目录中。例如："


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:56
msgid "On Linux, ``qt_gui_cpp.a`` would be built in: <ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/"
msgstr "在 Linux 上，``qt_gui_cpp.a`` 将会构建在：<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:59
msgid "But on Windows ``qt_gui_cpp.lib`` is built in <ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/Release"
msgstr "但是在 Windows 上，``qt_gui_cpp.lib`` 将会构建在：<ros2_ws>/build/qt_gui_cpp/src/qt_gui_cpp/Release"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:62
msgid "For compatibility across platforms in this situation, use `CMake generator expressions <https://cmake.org/cmake/help/v3.5/manual/cmake-generator-expressions.7.html>`__. However, when you need a library to link against be sure to use ``$<TARGET_LINKER_FILE:_target>`` instead of ``$<TARGET_FILE:_target>``. The latter will find ``.dll`` files, which cannot be linked against on Windows. See an `example here <https://github.com/ros-visualization/qt_gui_core/pull/162/files>`__."
msgstr "为了在这种情况下实现跨平台兼容性，请使用 `CMake 生成器表达式 <https://cmake.org/cmake/help/v3.5/manual/cmake-generator-expressions.7.html>`__。然而，在需要链接库时，请确保使用 ``$<TARGET_LINKER_FILE:_target>`` 而不是 ``$<TARGET_FILE:_target>``。后者会找到 ``.dll`` 文件，在Windows上无法链接。参见 `此处的示例 <https://github.com/ros-visualization/qt_gui_core/pull/162/files>`__。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:68
msgid "Compiler and linker flags"
msgstr "编译器和链接器标志"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:70
msgid "In general when porting to Windows, many packages might make use of additional compiler flags. You can find the Windows compiler flags on `Microsoft's documentation <https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=vs-2017>`__. The C++ compiler is called ``cl.exe``."
msgstr "通常在移植到Windows时，许多软件包可能会使用额外的编译器标志。您可以在 `Microsoft 的文档 <https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category?view=vs-2017>`__ 中找到Windows编译器标志。C++编译器称为 ``cl.exe``。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:74
msgid "For linker flags see `Microsoft's documentation <https://docs.microsoft.com/en-us/cpp/build/reference/linker-options?view=vs-2017>`__. The linker program is called ``link.exe``."
msgstr "有关链接器标志，请参阅 `Microsoft 的文档 <https://docs.microsoft.com/en-us/cpp/build/reference/linker-options?view=vs-2017>`__。链接器程序称为 ``link.exe``。"


#: ../../source/How-To-Guides/RQt-Port-Plugin-Windows.rst:77
msgid "However, CMake actually provides many of these options in variables. This `StackOverflow page <https://stackoverflow.com/questions/9298278/cmake-print-out-all-accessible-variables-in-a-script>`__ contains a good example of how to see all the CMake variables available in a script."
msgstr "然而，CMake实际上在变量中提供了许多这些选项。这个`StackOverflow页面<https://stackoverflow.com/questions/9298278/cmake-print-out-all-accessible-variables-in-a-script>`__提供了一个很好的示例，可以查看脚本中所有可用的CMake变量。"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:7
msgid "Building RQt from source"
msgstr "从源代码构建 RQt"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:9
msgid "We've provided our development setup here to aid future users in easily extending RQt by creating their own plugins. We encourage you to contribute those plugins back to the ``ros-visualization`` GitHub repository!"
msgstr "我们在这里提供了我们的开发设置，以帮助未来的用户通过创建自己的插件来轻松扩展 RQt。我们鼓励您将这些插件贡献回``ros-visualization``的GitHub存储库！"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:13 ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:15 ../../source/How-To-Guides/RQt-Source-Install.rst:13
msgid "System Requirements"
msgstr "系统要求"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:15
msgid "These instructions are written for the target platforms for Crystal Clemmys (see `REP <https://www.ros.org/reps/rep-2000.html>`__)."
msgstr "这些指令是针对 Crystal Clemmys 的目标平台编写的（请参阅 `REP <https://www.ros.org/reps/rep-2000.html>`__）。"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:17
msgid "Ubuntu Bionic Beaver 18.04 64-bit"
msgstr "Ubuntu Bionic Beaver 18.04 64 位"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:18
msgid "Mac OSX Sierra 10.12.x"
msgstr "Mac OSX Sierra 10.12.x"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:19
msgid "Windows 10 with Visual Studio 2017"
msgstr "Windows 10 with Visual Studio 2017"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:22
msgid "Other Requirements"
msgstr "其他要求"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:24
msgid "In ROS 2 Crystal the minimum Qt version is ``Qt5``"
msgstr "在ROS 2 Crystal中，最低的Qt版本是``Qt5``"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:27
msgid "Building From Source"
msgstr "从源代码构建"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:29
msgid "In order to build RQt from source, first create a ROS 2 workspace at ``~/ros2_ws/``. This is step is already covered in :doc:`building ROS 2 from source instructions <../Installation>`, so we skip it here."
msgstr "为了从源代码构建RQt，首先在``~/ros2_ws/``下创建一个ROS 2工作空间。这一步在 :doc:`从源代码构建ROS 2的说明 <../Installation>`中已经介绍过了，所以我们在这里跳过它。"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:33
msgid "Download RQt Repositories"
msgstr "下载 RQt 仓库"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:40
msgid "As an alternative to the hosted ``.repos`` file you can use ``rosinstall_generator`` to generate a custom one:"
msgstr "作为托管的 ``.repos`` 文件的替代，您可以使用 ``rosinstall_generator`` 生成一个自定义的文件："


#: ../../source/How-To-Guides/RQt-Source-Install.rst:48
msgid "Install Dependencies"
msgstr "安装依赖项"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:56
msgid "For non-Linux platforms, see the :doc:`macOS RQt source install page <RQt-Source-Install-MacOS>` or the :doc:`Windows 10 RQt source install page <RQt-Source-Install-Windows10>` before continuing here."
msgstr "对于非 Linux 平台，请参阅 :doc:`macOS RQt 源码安装页面 <RQt-Source-Install-MacOS>` 或 :doc:`Windows 10 RQt 源码安装页面 <RQt-Source-Install-Windows10>`，然后再继续本页。"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:63
msgid "Build The Workspace"
msgstr "构建工作区"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:65
msgid "Generally building a workspace is as simple as:"
msgstr "通常构建工作区很简单："


#: ../../source/How-To-Guides/RQt-Source-Install.rst:71
msgid "For Windows, it is recommended to use the ``--merge-install`` option."
msgstr "对于Windows系统，建议使用 ``--merge-install`` 选项。"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:77
msgid "Advanced Colcon usages:"
msgstr "高级Colcon用法："


#: ../../source/How-To-Guides/RQt-Source-Install.rst:79
msgid "Show verbose output on the console:"
msgstr "在控制台上显示详细输出："


#: ../../source/How-To-Guides/RQt-Source-Install.rst:85
msgid "Only build one package and its dependencies:"
msgstr "仅构建一个软件包及其依赖项："


#: ../../source/How-To-Guides/RQt-Source-Install.rst:92
msgid "Source your environment"
msgstr "源激活您的环境"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:94
msgid "Linux or macOS"
msgstr "适用于 Linux 或 macOS"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:108
msgid "Using RQt"
msgstr "使用 RQt"


#: ../../source/How-To-Guides/RQt-Source-Install.rst:110
msgid "See :doc:`Overview of RQt <../Concepts/About-RQt>`."
msgstr "参见：:doc:`RQt 概述 <../Concepts/About-RQt>`。"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:7
msgid "Building RQt from source on macOS"
msgstr "在 macOS 上从源代码构建 RQt"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:9
msgid "This page provides specific information to building RQt from source on macOS. Follow these instructions before proceeding with :doc:`RQt Source Install <RQt-Source-Install>` page."
msgstr "本页提供了在 macOS 上从源代码构建 RQt 的具体信息。在继续查看 :doc:`RQt 源码安装 <RQt-Source-Install>` 页面之前，请按照这些说明进行操作。"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:15
msgid "RQt is supported on macOS 10.12, but 10.13 also seems to work."
msgstr "RQt 在 macOS 10.12 上受支持，但似乎在 10.13 上也可以工作。"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:18 ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:25
msgid "Dependencies"
msgstr "依赖项"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:20
msgid "The primary dependencies of the RQt package are sip and PyQt5. PySide2 may be supported in the future."
msgstr "RQt 包的主要依赖项是 sip 和 PyQt5。将来可能支持 PySide2。"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:33
msgid "This is the quickest solution but may cause issues when upgrading Qt or if other packages are expecting Qt 4. Another option is to update your ``PATH`` and ``CMAKE_PREFIX_PATH`` to include the Qt install location:"
msgstr "这是最快的解决方案，但在升级 Qt 或其他包需要 Qt 4 的情况下可能会出现问题。另一种选择是更新您的 ``PATH`` 和 ``CMAKE_PREFIX_PATH``，将 Qt 安装位置包括在内："


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:42 ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:92
msgid "Install RQt by source"
msgstr "通过源代码安装 RQt"


#: ../../source/How-To-Guides/RQt-Source-Install-MacOS.rst:44 ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:94
msgid "Continue with the :doc:`RQt source install page <RQt-Source-Install>`."
msgstr "继续查看 :doc:`RQt 源代码安装页面 <RQt-Source-Install>`。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:7
msgid "Building RQt from source on Windows 10"
msgstr "在 Windows 10 上从源代码构建 RQt"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:9
msgid "This page provides specific information to building RQt from source on Windows. Follow these instructions before proceeding with the :doc:`RQt Source Install <RQt-Source-Install>` page."
msgstr "本页面提供了在 Windows 上从源代码构建 RQt 的特定信息。在继续查看 :doc:`RQt 源代码安装页面 <RQt-Source-Install>` 之前，请按照这些说明进行操作。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:12
msgid "If you have not done so, follow the :doc:`ROS 2 Windows Development Setup guide <../Installation/Alternatives/Windows-Development-Setup>` before continuing."
msgstr "如果您还没有这样做，请在继续之前按照 :doc:`ROS 2 Windows Development Setup guide <../Installation/Alternatives/Windows-Development-Setup>` 进行设置。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:17
msgid "Windows 10"
msgstr "Windows 10"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:18
msgid "Visual Studio 15.7.6"
msgstr "Visual Studio 15.7.6"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:20
msgid "Currently Visual Studio 15.8 fails to build ROS 2 (`see issue <https://github.com/osrf/osrf_testing_tools_cpp/issues/15>`__). Older versions of VS can be found `here <https://docs.microsoft.com/en-us/visualstudio/productinfo/installing-an-earlier-release-of-vs2017>`__."
msgstr "当前的 Visual Studio 15.8 无法构建 ROS 2（`请参阅问题 <https://github.com/osrf/osrf_testing_tools_cpp/issues/15>`__）。可以在 `这里找到 <https://docs.microsoft.com/en-us/visualstudio/productinfo/installing-an-earlier-release-of-vs2017>`__ 较旧版本的 VS。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:27
msgid "The primary dependencies of the RQt package are sip and PyQt5. PySide2 may be supported in the future. Even though they are provided through PyPI and chocolatey, you must install them by source to get compatible versions."
msgstr "RQt软件包的主要依赖项是sip和PyQt5。PySide2可能在将来得到支持。尽管它们通过PyPI和chocolatey提供，但您必须通过源代码安装它们以获得兼容的版本。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:32
msgid "Install sip by source"
msgstr "通过源代码安装sip"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:34
msgid "Download from https://www.riverbankcomputing.com/software/sip/download"
msgstr "从https://www.riverbankcomputing.com/software/sip/download下载"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:36
msgid "Run the x64 Native Tools Command Prompt as Administrator, and ``cd`` to the uncompressed source directory."
msgstr "以管理员身份运行x64本机工具命令提示符，并``cd``到未压缩的源目录。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:38
msgid "Run:"
msgstr "运行："


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:46
msgid "If ``python3`` is installed on your system as ``python``, be sure to use that program name instead."
msgstr "如果您的系统上安装的是 ``python3``，请确保使用该程序名称。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:49
msgid "Install PyQt5 by source"
msgstr "通过源码安装 PyQt5"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:51
msgid "Download from https://www.riverbankcomputing.com/software/pyqt/download5"
msgstr "从 https://www.riverbankcomputing.com/software/pyqt/download5 下载"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:53
msgid "Run the x64 Native Tools Command Prompt as Administrator, and ``cd`` to the uncompressed source directory. I ran into trouble with Qt 5.11.3 and PyQt5 compiling QtNfc, but it can be easily disabled."
msgstr "以管理员身份运行 x64 本机工具命令提示符，并``cd``到未压缩的源目录。我在编译 QtNfc 时遇到了 Qt 5.11.3 和 PyQt5 的问题，但可以很容易地禁用它。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:63
msgid "Test that it works"
msgstr "测试它是否正常工作"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:65
msgid "If install occurred without failure, try the commands below. They should run without issue and you should see 4.19.13 as your ``sip.exe`` version."
msgstr "如果安装没有出现错误，请尝试以下命令。它们应该能够正常运行，您应该看到您的``sip.exe``版本为 4.19.13。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:75
msgid "Other dependencies"
msgstr "其他依赖项"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:77
msgid "Install GraphViz from https://graphviz.gitlab.io/_pages/Download/Download_windows.html."
msgstr "从 https://graphviz.gitlab.io/_pages/Download/Download_windows.html 安装 GraphViz。"


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:79
msgid "Install ``pydot`` and ``pyparsing``:"
msgstr "安装 ``pydot`` 和 ``pyparsing``："


#: ../../source/How-To-Guides/RQt-Source-Install-Windows10.rst:86
msgid "PyGraphViz is a test dependency of ``qt_dotgraph``, but it is currently unsupported on Windows and building by source is not straight forward. Manually merging this patch is the currently recommended solution (not verified): `pygraphviz patch <https://github.com/Kagami/pygraphviz/commit/fe442dc16accb629c3feaf157af75f67ccabbd6e>`__"
msgstr "PyGraphViz 是 ``qt_dotgraph`` 的一个测试依赖项，但它目前不支持在 Windows 上构建，且通过源代码构建并不直接。手动合并此补丁是当前推荐的解决方案（未经验证）：`pygraphviz 补丁 <https://github.com/Kagami/pygraphviz/commit/fe442dc16accb629c3feaf157af75f67ccabbd6e>`__"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:2
msgid "First Time Release"
msgstr "首次发布"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:4
msgid "This guide explains how to release ROS 2 packages that you have not released before. Due to numerous options available when releasing ROS packages, this guide intends to cover the most common scenario and does not cover every corner-case."
msgstr "本指南解释了如何发布尚未发布的ROS 2软件包。由于在发布ROS软件包时有许多选项可用，本指南旨在涵盖最常见的情况，不涵盖每个特例。"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:12
msgid "Be part of a release team"
msgstr "成为发布团队的一员"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:14
msgid "You must be part of a :ref:`release team <what-is-a-release-team>`. If you are not part of a release team yet, follow either:"
msgstr "您必须是一个:ref:`发布团队 <what-is-a-release-team>`的成员。如果您还不是发布团队的一员，请按照以下方式之一进行操作："


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:17
msgid ":ref:`Join a release team <join-a-release-team>`"
msgstr ":ref:`加入发布团队 <join-a-release-team>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:18
msgid ":ref:`Start a new release team <start-a-new-release-team>`"
msgstr "：ref:`启动一个新的发布团队 <start-a-new-release-team>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:21 ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:62
msgid "Create a new release repository"
msgstr "创建一个新的发布仓库"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:23
msgid "You need a :ref:`release repository <what-is-a-release-repository>` to release a package. Follow :ref:`Create a new release repository <create-a-new-release-repository>`."
msgstr "你需要一个：ref:`发布仓库 <what-is-a-release-repository>`来发布一个软件包。请按照：ref:`创建一个新的发布仓库 <create-a-new-release-repository>`进行操作。"


#: ../../source/How-To-Guides/Releasing/_Install-Dependencies.rst:1
msgid "Install tools that you will use in the upcoming steps according to your platform:"
msgstr "根据你的平台安装你将在接下来的步骤中使用的工具："


#: ../../source/How-To-Guides/Releasing/_Install-Dependencies.rst:5
msgid "Debian (eg. Ubuntu)"
msgstr "Debian（例如 Ubuntu）"


#: ../../source/How-To-Guides/Releasing/_Install-Dependencies.rst:11
msgid "RPM (eg. RHEL)"
msgstr "RPM（例如 RHEL）"


#: ../../source/How-To-Guides/Releasing/_Install-Dependencies.rst:17
msgid "Other"
msgstr "其他"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:32
msgid "Set Up a Personal Access Token"
msgstr "设置个人访问令牌"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:3
msgid "If the file ``~/.config/bloom`` exists on your computer, it is likely that you have done this before so you should skip this section."
msgstr "如果您的计算机上存在文件 ``~/.config/bloom``，那么您很可能之前已经进行过这个操作，所以您应该跳过此部分。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:5
msgid "During the release process, multiple HTTPS Git operations will be performed that require password authentication. To avoid being repeatedly asked for a password, a `Personal Access Token (PAT) <https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token>`_ will be set up. If you have multi-factor authentication setup on your GitHub account, you **must** setup a Personal Access Token."
msgstr "在发布过程中，将执行多个需要密码验证的 HTTPS Git 操作。为了避免反复询问密码，将设置一个 `个人访问令牌 (PAT) <https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token>`_。如果您的 GitHub 帐户已设置了多因素身份验证，**必须** 设置一个个人访问令牌。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:9
msgid "Create a Personal Access Token by:"
msgstr "按照以下步骤创建个人访问令牌："


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:11
msgid "Log in to GitHub and go to `Personal access tokens <https://github.com/settings/tokens>`_."
msgstr "登录 GitHub 并转到 `个人访问令牌 <https://github.com/settings/tokens>`_。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:12
msgid "Click the **Generate new token** button."
msgstr "点击 **生成新令牌** 按钮。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:13
msgid "Set **Note** to something like ``Bloom token``."
msgstr "将 **Note** 设置为类似于 ``Bloom token`` 的内容。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:14
msgid "Set **Expiration** to **No expiration**."
msgstr "将 **Expiration** 设置为 **无过期时间**。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:15
msgid "Tick the ``public_repo`` and ``workflow`` checkboxes."
msgstr "选中 ``public_repo`` 和 ``workflow`` 复选框。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:16
msgid "Click the **Generate token** button."
msgstr "点击 **生成令牌** 按钮。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:18
msgid "After you have created the token, you will end up back at the *Personal access tokens* page. **Copy the alphanumeric token** that is highlighted in green."
msgstr "创建令牌后，您将返回到*个人访问令牌*页面。**复制突出显示的绿色字母数字令牌**。"


#: ../../source/How-To-Guides/Releasing/_Personal-Access-Token.rst:21
msgid "Save your GitHub username and PAT to a new file called ``~/.config/bloom``, with the format below:"
msgstr "将您的GitHub用户名和PAT保存到名为``~/.config/bloom``的新文件中，格式如下："


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:37 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:26
msgid "Ensure repositories are up-to-date"
msgstr "确保存储库是最新的。"


#: ../../source/How-To-Guides/Releasing/_Ensure-Repositories-Are-Up-To-Date.rst:1
msgid "Make sure that:"
msgstr "请确保："


#: ../../source/How-To-Guides/Releasing/_Ensure-Repositories-Are-Up-To-Date.rst:3
msgid "Your repository is hosted on a remote such as GitHub."
msgstr "您的代码仓库已托管在诸如GitHub之类的远程服务器上。"


#: ../../source/How-To-Guides/Releasing/_Ensure-Repositories-Are-Up-To-Date.rst:4
msgid "You have a clone of the repository on your computer and are on the right branch."
msgstr "您在计算机上克隆了该代码仓库，并且处于正确的分支上。"


#: ../../source/How-To-Guides/Releasing/_Ensure-Repositories-Are-Up-To-Date.rst:5
msgid "Both the remote repository and your clone are up-to-date."
msgstr "远程代码仓库和您的克隆版本都是最新的。"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:42
msgid "Generate Changelog"
msgstr "生成变更日志"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:44
msgid "Generate a ``CHANGELOG.rst`` file per package in your repo using the following command:"
msgstr "使用以下命令为您的仓库中的每个软件包生成一个 ``CHANGELOG.rst`` 文件："


#: ../../source/How-To-Guides/Releasing/_Clean-Up-Changelog.rst:1
msgid "Open all ``CHANGELOG.rst`` files in an editor. You will see that ``catkin_generate_changelog`` has auto-generated a forthcoming section with notes from commit messages:"
msgstr "在编辑器中打开所有的 ``CHANGELOG.rst`` 文件。您会看到 ``catkin_generate_changelog`` 自动生成了一个即将发布的部分，其中包含了提交信息的注释："


#: ../../source/How-To-Guides/Releasing/_Clean-Up-Changelog.rst:15
msgid "Clean up the list of commit messages to concisely convey the notable changes that have been made to the packages since the last release, and **commit all the CHANGELOG.rst files.** Do not modify the ``Forthcoming`` header."
msgstr "整理提交信息列表，以简明扼要地传达自上次发布以来软件包所做的重要更改，并**提交所有的 CHANGELOG.rst 文件。**不要修改 ``Forthcoming`` 标题。"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:53 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:42
msgid "Bump the package version"
msgstr "提升软件包版本"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:1
msgid "Every release of the package must have a unique version number higher than the previous release. Run:"
msgstr "每个软件包的发布版本必须具有比上一个发布版本更高的唯一版本号。运行："


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:8
msgid "which performs the following:"
msgstr "执行以下操作："


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:10
msgid "increases the package version in ``package.xml``"
msgstr "在``package.xml``中增加软件包版本"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:11
msgid "replaces the heading ``Forthcoming`` with ``version (date)`` (eg. ``0.0.1 (2022-01-08)``) in ``CHANGELOG.rst``"
msgstr "在``CHANGELOG.rst``文件中用``版本（日期）``（例如``0.0.1（2022-01-08）``）替换``即将发布``标题"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:12
msgid "commits those changes"
msgstr "提交这些更改"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:13
msgid "creates a tag (eg. ``0.0.1``)"
msgstr "创建一个标签（例如``0.0.1``）"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:14
msgid "pushes the changes and the tag to your remote repository"
msgstr "将更改和标签推送到您的远程存储库"


#: ../../source/How-To-Guides/Releasing/_Bump-Package-Version.rst:18
msgid "By default the patch version of the package is incremented, such as from ``0.0.0`` to ``0.0.1``. To increment the minor or major version instead, run ``catkin_prepare_release --bump minor`` or ``catkin_prepare_release --bump major``. For more details, see ``catkin_prepare_release --help``."
msgstr "默认情况下，软件包的补丁版本会递增，例如从``0.0.0``增加到``0.0.1``。若要递增次要版本或主要版本，请运行``catkin_prepare_release --bump minor``或``catkin_prepare_release --bump major``命令。有关详细信息，请参阅``catkin_prepare_release --help``。"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:58 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:47
msgid "Bloom Release"
msgstr "Bloom发布"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:60
msgid "Run the following command, replacing ``my_repo`` with the name of your repository:"
msgstr "运行以下命令，将``my_repo``替换为您的仓库名称："


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:68
msgid "``--new-track`` tells bloom to create a new :ref:`track <what-is-a-track>` and configure it."
msgstr "``--new-track``指示bloom创建一个新的:ref:`轨道 <what-is-a-track>`并进行配置。"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:69
msgid "``--rosdistro humble`` indicates that this release is for the ``humble`` distro"
msgstr "``--rosdistro humble`` 表示这个版本适用于 ``humble`` 发行版"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:70
msgid "``--track humble`` indicates that you want the track name to be ``humble``"
msgstr "``--track humble`` 表示你想要将轨道名称设为 ``humble``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:73
msgid "You will be prompted to enter information to configure a new track. In a common scenario such as:"
msgstr "将提示你输入信息以配置一个新的轨道。在常见的场景中，比如："


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:76
msgid "Your packages are in a repository called ``my_repo``"
msgstr "你的软件包存储在一个名为 ``my_repo`` 的仓库中"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:77
msgid "You are releasing a branch called ``main``"
msgstr "你正在发布一个名为 ``main`` 的分支"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:78
msgid "The repository is hosted on GitHub at ``https://github.com/my_organization/my_repo.git``"
msgstr "该代码库托管在 GitHub 上，地址为 ``https://github.com/my_organization/my_repo.git``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:79
msgid "Your release repository is at ``https://github.com/ros2-gbp/my_repo-release.git``"
msgstr "你的发布代码库位于 ``https://github.com/ros2-gbp/my_repo-release.git``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:81
msgid "You should respond to the prompts as following:"
msgstr "你应按照以下提示进行回答："


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:87
msgid "Configuration"
msgstr "Configuration"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:88
msgid "Value"
msgstr "Value"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:89
msgid ":ref:`Release Repository url <release-repository-url>`"
msgstr ":ref:`Release Repository url <release-repository-url>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:90
msgid "``https://github.com/ros2-gbp/my_repo-release.git``"
msgstr "``https://github.com/ros2-gbp/my_repo-release.git``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:91
msgid ":ref:`Repository Name <repository-name>`"
msgstr ":ref:`Repository Name <repository-name>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:92
msgid "``my_repo``"
msgstr "``my_repo``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:93
msgid ":ref:`Upstream Repository URI <upstream-repository-uri>`"
msgstr ":ref:`Upstream Repository URI <upstream-repository-uri>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:94
msgid "``https://github.com/my_organization/my_repo.git``"
msgstr "``https://github.com/my_organization/my_repo.git``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:95
msgid ":ref:`Upstream VCS Type <upstream-vcs-type>`"
msgstr ":ref:`Upstream VCS Type <upstream-vcs-type>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:97
msgid ":ref:`Version <version>`"
msgstr ":ref:`Version <version>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:99
msgid ":ref:`Release Tag <release-tag>`"
msgstr ":ref:`Release Tag <release-tag>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:101
msgid ":ref:`Upstream Devel Branch <upstream-devel-branch>`"
msgstr ":ref:`Upstream Devel Branch <upstream-devel-branch>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:102
msgid "``main``"
msgstr "``main``"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:103
msgid ":ref:`ROS Distro <ros-distro>`"
msgstr ":ref:`ROS Distro <ros-distro>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:105
msgid ":ref:`Patches Directory <patches-directory>`"
msgstr ":ref:`Patches Directory <patches-directory>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:107
msgid ":ref:`Release Repository Push URL <release-repository-push-url>`"
msgstr ":ref:`Release Repository Push URL <release-repository-push-url>`"


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:112
msgid "An empty cell in the table indicates that the default value should be used. Simply respond to the prompt by pressing Enter."
msgstr "An empty cell in the table indicates that the default value should be used. Simply respond to the prompt by pressing Enter."


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:115 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:55
msgid "Bloom will automatically create a pull request for you against `rosdistro <https://github.com/ros/rosdistro>`_."
msgstr "Bloom will automatically create a pull request for you against `rosdistro <https://github.com/ros/rosdistro>`_."


#: ../../source/How-To-Guides/Releasing/First-Time-Release.rst:118 ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:58
msgid "Next Steps"
msgstr "Next Steps"


#: ../../source/How-To-Guides/Releasing/_Next-Steps.rst:1
msgid "Once your pull request has been submitted, usually within one or two days, one of the maintainers of rosdistro will review and merge your Pull Request. If your package build is successful, in 24-48 hours your packages will become available in the **ros-testing** repository, where you can :doc:`test your pre-release binaries <../../../Installation/Testing>`."
msgstr "Once your pull request has been submitted, usually within one or two days, one of the maintainers of rosdistro will review and merge your Pull Request. If your package build is successful, in 24-48 hours your packages will become available in the **ros-testing** repository, where you can :doc:`test your pre-release binaries <../../../Installation/Testing>`."


#: ../../source/How-To-Guides/Releasing/_Next-Steps.rst:4
msgid "Approximately every two to four weeks, the distribution's release manager manually synchronizes the contents of ros-testing into the main ROS repository. This is when your packages actually become available to the rest of the ROS community. To get updates on when the next synchronization (sync) is coming, subscribe to the `Packaging and Release Management Category on ROS Discourse <https://discourse.ros.org/c/release/16>`_."
msgstr "Approximately every two to four weeks, the distribution's release manager manually synchronizes the contents of ros-testing into the main ROS repository. This is when your packages actually become available to the rest of the ROS community. To get updates on when the next synchronization (sync) is coming, subscribe to the `Packaging and Release Management Category on ROS Discourse <https://discourse.ros.org/c/release/16>`_."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:2
msgid "Release Team / Repository"
msgstr "Release Team / Repository"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:8
msgid "This page explains the recommended method of hosting your release repositories on `ros2-gbp <https://github.com/ros2-gbp>`_."
msgstr "This page explains the recommended method of hosting your release repositories on `ros2-gbp <https://github.com/ros2-gbp>`_."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:11
msgid "What is ROS 2 GBP?"
msgstr "What is ROS 2 GBP?"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:13
msgid "`ros2-gbp <https://github.com/ros2-gbp>`_ is a GitHub organization that hosts the release repositories for ROS packages. It also maintains a list of release teams, the list of members per release team and the list of release repositories maintained by the release teams in https://github.com/ros2-gbp/ros2-gbp-github-org. Interactions with ros2-gbp-github-org are done through raising GitHub issues. It is recommended that you request to join a release team and set up a release repository early as it can take some time for the ros2-gbp maintainers to respond to your requests."
msgstr "`ros2-gbp <https://github.com/ros2-gbp>`_ is a GitHub organization that hosts the release repositories for ROS packages. It also maintains a list of release teams, the list of members per release team and the list of release repositories maintained by the release teams in https://github.com/ros2-gbp/ros2-gbp-github-org. Interactions with ros2-gbp-github-org are done through raising GitHub issues. It is recommended that you request to join a release team and set up a release repository early as it can take some time for the ros2-gbp maintainers to respond to your requests."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:21
msgid "What is a release team?"
msgstr "What is a release team?"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:23
msgid "A release team is a `GitHub team <https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams>`_ that consists of a group of people who are responsible for the release process of one or more repositories. Release teams are often made up of an organization, a working group, or even an individual, and are named after the team or group that they represent. The list of release teams and their associated release repositories are maintained at `ros2-gbp-github-org <https://github.com/ros2-gbp/ros2-gbp-github-org>`_."
msgstr "A release team is a `GitHub team <https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams>`_ that consists of a group of people who are responsible for the release process of one or more repositories. Release teams are often made up of an organization, a working group, or even an individual, and are named after the team or group that they represent. The list of release teams and their associated release repositories are maintained at `ros2-gbp-github-org <https://github.com/ros2-gbp/ros2-gbp-github-org>`_."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:27
msgid "**You must be a part of the release team that you are planning on releasing the project for.** If you intend to release the repository under an existing team, follow :ref:`Join a release team <join-a-release-team>`. If you intend to start a new team, follow :ref:`Start a new release team <start-a-new-release-team>`."
msgstr "**You must be a part of the release team that you are planning on releasing the project for.** If you intend to release the repository under an existing team, follow :ref:`Join a release team <join-a-release-team>`. If you intend to start a new team, follow :ref:`Start a new release team <start-a-new-release-team>`."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:34
msgid "Join a release team"
msgstr "Join a release team"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:36
msgid "Fill the `Update Release Team Membership issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=update_release_team_membership.md&title=Update+release+team+membership>`_ issue template if a release team already exists for your project but you are not part of it."
msgstr "Fill the `Update Release Team Membership issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=update_release_team_membership.md&title=Update+release+team+membership>`_ issue template if a release team already exists for your project but you are not part of it."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:42
msgid "Start a new release team"
msgstr "Start a new release team"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:44
msgid "Fill the `New Release Team issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_team.md&title=Add+release+team>`_ issue template if no release team exists for your project yet, request for a new release team to be created."
msgstr "Fill the `New Release Team issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_team.md&title=Add+release+team>`_ issue template if no release team exists for your project yet, request for a new release team to be created."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:50
msgid "What is a release repository?"
msgstr "What is a release repository?"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:52
msgid "A release repository is a repository that"
msgstr "A release repository is a repository that"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:54
msgid "stores files generated from the release process, for the ROS buildfarm to use"
msgstr "stores files generated from the release process, for the ROS buildfarm to use"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:55
msgid "caches configurations from the release process to simplify subsequent releases of the repository in the future"
msgstr "caches configurations from the release process to simplify subsequent releases of the repository in the future"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:57
msgid "Having a release repository separate from your source code repository is a requirement for making a release in ROS 2."
msgstr "Having a release repository separate from your source code repository is a requirement for making a release in ROS 2."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:64
msgid "If your repository is new to the ROS community, you should first open a pull request on `ros/rosdistro <https://github.com/ros/rosdistro>`_ adding a ``source`` entry for your repository. The review process for the rosdistro database will ensure your repository and packages conform to the `REP 144 package naming conventions <https://www.ros.org/reps/rep-0144.html>`_ and other requirements before release. Once your package name has been approved and merged, fill in the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_ issue template if you don't have a release repo for your project yet."
msgstr "If your repository is new to the ROS community, you should first open a pull request on `ros/rosdistro <https://github.com/ros/rosdistro>`_ adding a ``source`` entry for your repository. The review process for the rosdistro database will ensure your repository and packages conform to the `REP 144 package naming conventions <https://www.ros.org/reps/rep-0144.html>`_ and other requirements before release. Once your package name has been approved and merged, fill in the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_ issue template if you don't have a release repo for your project yet."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:70
msgid "What if my existing release repo isn't on ros2-gbp?"
msgstr "What if my existing release repo isn't on ros2-gbp?"


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:72
msgid "Packages released before ros2-gbp existed may have their release repositories hosted elsewhere. It is now strongly recommended for release repositories to live in this dedicated GitHub organization. If you are porting a ROS 1 package to ROS 2 and planning on releasing your packages into ROS 2 for the first time, follow standard procedure to request for a new release repository for your ROS 2 releases. If you have previously released your packages for ROS 2, when raising the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_, **specify your current release repository url**, and follow standard procedure for the rest."
msgstr "Packages released before ros2-gbp existed may have their release repositories hosted elsewhere. It is now strongly recommended for release repositories to live in this dedicated GitHub organization. If you are porting a ROS 1 package to ROS 2 and planning on releasing your packages into ROS 2 for the first time, follow standard procedure to request for a new release repository for your ROS 2 releases. If you have previously released your packages for ROS 2, when raising the `Add New Release Repositories issue <https://github.com/ros2-gbp/ros2-gbp-github-org/issues/new?assignees=&labels=&template=new_release_repository.md&title=Add+new+release+repositories>`_, **specify your current release repository url**, and follow standard procedure for the rest."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:79
msgid "Release repositories hosted elsewhere are still supported for stable distributions if you are not planning to release the repository into Rolling. Since stable distributions created from Rolling will start with release repositories in the ros2-gbp organization it is recommend that you use the ros2-gbp release repositories for all ROS 2 distributions to avoid fragmenting the release information."
msgstr "Release repositories hosted elsewhere are still supported for stable distributions if you are not planning to release the repository into Rolling. Since stable distributions created from Rolling will start with release repositories in the ros2-gbp organization it is recommend that you use the ros2-gbp release repositories for all ROS 2 distributions to avoid fragmenting the release information."


#: ../../source/How-To-Guides/Releasing/Release-Team-Repository.rst:82
msgid "A ros2-gbp release repository may become a hard requirement in the future and maintaining a single release repository for all ROS 2 distributions simplifies the maintenance of releases for both the Rolling distribution maintainers and package maintainers."
msgstr "A ros2-gbp release repository may become a hard requirement in the future and maintaining a single release repository for all ROS 2 distributions simplifies the maintenance of releases for both the Rolling distribution maintainers and package maintainers."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:2
msgid "Release Track"
msgstr "Release Track"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:11
msgid "What is a Track?"
msgstr "What is a Track?"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:13
msgid "Bloom requires the user to enter configuration information when releasing packages for the first time. It is beneficial to store such configurations in the release repository so we don't have to manually enter configurations that won't change for subsequent releases."
msgstr "Bloom requires the user to enter configuration information when releasing packages for the first time. It is beneficial to store such configurations in the release repository so we don't have to manually enter configurations that won't change for subsequent releases."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:16
msgid "Since some of the configurations will differ when releasing the package for different ROS distributions, bloom uses **release tracks to store the configurations for releasing** per distribution. By convention you should create tracks with the same name as the ROS distro you are releasing for."
msgstr "Since some of the configurations will differ when releasing the package for different ROS distributions, bloom uses **release tracks to store the configurations for releasing** per distribution. By convention you should create tracks with the same name as the ROS distro you are releasing for."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:19
msgid "All release track configurations are stored in ``tracks.yaml`` on the master branch of your release repository."
msgstr "All release track configurations are stored in ``tracks.yaml`` on the master branch of your release repository."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:22
msgid "Track Configurations"
msgstr "Track Configurations"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:24
msgid "Track configurations are explained in more detail along with the prompts from bloom."
msgstr "Track configurations are explained in more detail along with the prompts from bloom."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:29
msgid "Release Repository url"
msgstr "Release Repository url"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:31
msgid "This is the url of your release repository, and should be of form ``https://github.com/ros2-gbp/my_repo-release.git`` if your release repository is hosted on ros2-gbp."
msgstr "This is the url of your release repository, and should be of form ``https://github.com/ros2-gbp/my_repo-release.git`` if your release repository is hosted on ros2-gbp."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:38
msgid "Paste your release repository URL and press Enter."
msgstr "Paste your release repository URL and press Enter."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:40
msgid "Bloom may additionally ask you about initializing the new repository, as following:"
msgstr "Bloom may additionally ask you about initializing the new repository, as following:"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:48
msgid "Simply press Enter to accept the default of yes."
msgstr "Simply press Enter to accept the default of yes."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:53
msgid "Repository Name"
msgstr "Repository Name"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:55
msgid "The repository name is trivial, but it is recommended to set this to the name of your project."
msgstr "The repository name is trivial, but it is recommended to set this to the name of your project."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:66
msgid "Type the name of your project (eg. ``my_project``) and press Enter."
msgstr "Type the name of your project (eg. ``my_project``) and press Enter."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:71
msgid "Upstream Repository URI"
msgstr "Upstream Repository URI"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:73
msgid "The **upstream repository** is the repository where your source code is. This is most likely an https link to your project hosted on a git hosting service such as GitHub or GitLab."
msgstr "The **upstream repository** is the repository where your source code is. This is most likely an https link to your project hosted on a git hosting service such as GitHub or GitLab."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:85
msgid "Make sure you **use the https address** (eg. ``https://github.com/my_organization/my_repo.git``) and not the ssh address."
msgstr "Make sure you **use the https address** (eg. ``https://github.com/my_organization/my_repo.git``) and not the ssh address."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:90
msgid "Upstream VCS Type"
msgstr "Upstream VCS Type"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:92
msgid "This is the `Upstream Repository URI`_'s version control system (VCS) type. You must specify the type of vcs your repository is using, from  ``svn``, ``git``, ``hg`` or ``tar``."
msgstr "This is the `Upstream Repository URI`_'s version control system (VCS) type. You must specify the type of vcs your repository is using, from  ``svn``, ``git``, ``hg`` or ``tar``."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:108
msgid "Most repositories will be using git, but some legacy repositories might be using hg or svn."
msgstr "Most repositories will be using git, but some legacy repositories might be using hg or svn."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:113
msgid "Version"
msgstr "Version"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:115
msgid "This is the version of the package you are releasing. (eg. ``1.0.3``)"
msgstr "This is the version of the package you are releasing. (eg. ``1.0.3``)"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:132
msgid "Setting this to ``:{auto}`` (the default, and recommended setup) will automatically determine the version from the devel branch's package.xml."
msgstr "Setting this to ``:{auto}`` (the default, and recommended setup) will automatically determine the version from the devel branch's package.xml."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:134
msgid "Setting this to ``:{ask}`` will bring up a prompt asking for the version every time you run a release with bloom."
msgstr "Setting this to ``:{ask}`` will bring up a prompt asking for the version every time you run a release with bloom."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:139
msgid "Release Tag"
msgstr "Release Tag"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:141
msgid "The Release Tag refers to which tag or branch you want to import the code from."
msgstr "The Release Tag refers to which tag or branch you want to import the code from."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:162
msgid "Setting this to ``:{version}`` (the default, and recommended setup) will make the release tag match the version tag."
msgstr "Setting this to ``:{version}`` (the default, and recommended setup) will make the release tag match the version tag."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:164
msgid "A less common setup is to set this to a branch name to always pull in that branch at the time of release from the upstream project."
msgstr "A less common setup is to set this to a branch name to always pull in that branch at the time of release from the upstream project."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:166
msgid "Alternatively, if you want to be prompted to enter a different tag every time you do a release, enter ``:{ask}``. ``:{ask}`` is useful if the upstream project has frequent tagged releases and you want to refer to the new tag every time you're releasing."
msgstr "Alternatively, if you want to be prompted to enter a different tag every time you do a release, enter ``:{ask}``. ``:{ask}`` is useful if the upstream project has frequent tagged releases and you want to refer to the new tag every time you're releasing."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:172
msgid "Upstream Devel Branch"
msgstr "Upstream Devel Branch"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:174
msgid "The upstream devel branch is the name of the branch in your :ref:`upstream repository <upstream-repository-uri>`. If you use separate branches for each ROS distribution, this field would be different for each release track. It is used to determine the version of the package you are releasing when :ref:`Version` is set to ``:{auto}``."
msgstr "The upstream devel branch is the name of the branch in your :ref:`upstream repository <upstream-repository-uri>`. If you use separate branches for each ROS distribution, this field would be different for each release track. It is used to determine the version of the package you are releasing when :ref:`Version` is set to ``:{auto}``."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:186
msgid "To release from a branch called ``humble``, enter ``humble``. Leaving this as ``None`` would result in the version being determined from the default branch of your repository (this is not recommended)."
msgstr "To release from a branch called ``humble``, enter ``humble``. Leaving this as ``None`` would result in the version being determined from the default branch of your repository (this is not recommended)."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:192
msgid "ROS Distro"
msgstr "ROS Distro"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:194
msgid "This is the distribution you're planning on releasing the package into."
msgstr "This is the distribution you're planning on releasing the package into."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:203
msgid "If you plan on releasing into ROS humble, enter ``humble``."
msgstr "If you plan on releasing into ROS humble, enter ``humble``."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:208
msgid "Patches Directory"
msgstr "Patches Directory"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:210
msgid "This is the directory where any additional patches to the releases are."
msgstr "This is the directory where any additional patches to the releases are."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:225
msgid "Adding additional patches to a release is a rarely used feature. For almost all packages, this should be left as the default ``None``."
msgstr "Adding additional patches to a release is a rarely used feature. For almost all packages, this should be left as the default ``None``."


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:231
msgid "Release Repository Push URL"
msgstr "Release Repository Push URL"


#: ../../source/How-To-Guides/Releasing/Release-Track.rst:245
msgid "Can be left as the default in most cases."
msgstr "Can be left as the default in most cases."


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:9
msgid "Releasing a Package"
msgstr "Releasing a Package"


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:19
msgid "**Releasing a package makes your package available on the public ROS 2 buildfarm.** This will:"
msgstr "**Releasing a package makes your package available on the public ROS 2 buildfarm.** This will:"


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:22
msgid "Make your package available to be installed via package managers (eg. ``apt`` on Ubuntu) for all supported Linux platforms in a ROS distribution as described in `REP 2000 <https://ros.org/reps/rep-2000.html>`_."
msgstr "Make your package available to be installed via package managers (eg. ``apt`` on Ubuntu) for all supported Linux platforms in a ROS distribution as described in `REP 2000 <https://ros.org/reps/rep-2000.html>`_."


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:23
msgid "Allow your package to have API documentation automatically generated."
msgstr "Allow your package to have API documentation automatically generated."


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:24
msgid "Make your package part of the `ROS Index <https://index.ros.org>`_."
msgstr "Make your package part of the `ROS Index <https://index.ros.org>`_."


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:25
msgid "(Optionally) Allow you to have automatic CI run for pull requests in your repository."
msgstr "(Optionally) Allow you to have automatic CI run for pull requests in your repository."


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:27
msgid "**Follow one of the guides below to get your package released:**"
msgstr "**Follow one of the guides below to get your package released:**"


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:29
msgid ":doc:`First Time Release <First-Time-Release>` - if this is the first release for the package"
msgstr ":doc:`First Time Release <First-Time-Release>` - if this is the first release for the package"


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:30
msgid ":doc:`Subsequent Releases <Subsequent-Releases>` - if you are releasing a new version of a package that has already been released"
msgstr ":doc:`Subsequent Releases <Subsequent-Releases>` - if you are releasing a new version of a package that has already been released"


#: ../../source/How-To-Guides/Releasing/Releasing-a-Package.rst:32
msgid "After successfully following the instructions, your package will be released into the ROS ecosystem on the next distro synchronization!"
msgstr "After successfully following the instructions, your package will be released into the ROS ecosystem on the next distro synchronization!"


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:2
msgid "Subsequent Releases"
msgstr "Subsequent Releases"


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:4
msgid "This guide explains how to release new versions of ROS packages that have already been released before."
msgstr "This guide explains how to release new versions of ROS packages that have already been released before."


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:11
msgid "Be part of the release team"
msgstr "Be part of the release team"


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:13
msgid "If you are not part of the release team that has write access to the release repository, follow :ref:`Join a release team <join-a-release-team>`."
msgstr "If you are not part of the release team that has write access to the release repository, follow :ref:`Join a release team <join-a-release-team>`."


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:21
msgid "Set up a Personal Access Token"
msgstr "Set up a Personal Access Token"


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:31
msgid "Updating Changelog"
msgstr "Updating Changelog"


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:33
msgid "For your users and for the developers, keep the changelog concise and up to date."
msgstr "For your users and for the developers, keep the changelog concise and up to date."


#: ../../source/How-To-Guides/Releasing/Subsequent-Releases.rst:49
msgid "Run the following command, replacing ``my_repo`` with the name of your repository with the packages:"
msgstr "Run the following command, replacing ``my_repo`` with the name of your repository with the packages:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:8
msgid "Running ROS 2 nodes in Docker [community-contributed]"
msgstr "Running ROS 2 nodes in Docker [community-contributed]"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:11
msgid "Run two nodes in a single docker container"
msgstr "Run two nodes in a single docker container"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:13
msgid "Pull the ROS docker image with tag \"humble-desktop\"."
msgstr "Pull the ROS docker image with tag \"humble-desktop\"."


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:20
msgid "Run the image in a container in interactive mode."
msgstr "Run the image in a container in interactive mode."


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:28
msgid "Your best friend is the ``ros2`` command line help now."
msgstr "Your best friend is the ``ros2`` command line help now."


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:35
msgid "E.g. list all installed packages."
msgstr "E.g. list all installed packages."


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:43
msgid "E.g. list all executables:"
msgstr "E.g. list all executables:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:51
msgid "Run a minimal example of 2 C++ nodes (1 topic subscriber ``listener``, 1 topic publisher ``talker``) from the package ``demo_nodes_cpp`` in this container:"
msgstr "Run a minimal example of 2 C++ nodes (1 topic subscriber ``listener``, 1 topic publisher ``talker``) from the package ``demo_nodes_cpp`` in this container:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:59
msgid "Run two nodes in two separate docker containers"
msgstr "Run two nodes in two separate docker containers"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:61
msgid "Open a terminal. Run the image in a container in interactive mode and launch a topic publisher (executable ``talker`` from the package ``demo_nodes_cpp``) with ``ros2 run``:"
msgstr "Open a terminal. Run the image in a container in interactive mode and launch a topic publisher (executable ``talker`` from the package ``demo_nodes_cpp``) with ``ros2 run``:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:67
msgid "Open a second terminal. Run the image in a container in interactive mode and launch a topic subscriber (executable ``listener`` from the package ``demo_nodes_cpp``)  with ``ros2 run``:"
msgstr "Open a second terminal. Run the image in a container in interactive mode and launch a topic subscriber (executable ``listener`` from the package ``demo_nodes_cpp``)  with ``ros2 run``:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:73
msgid "As an alternative to the command line invocation, you can create a ``docker-compose.yml`` file (here version 2) with the following (minimal) content:"
msgstr "As an alternative to the command line invocation, you can create a ``docker-compose.yml`` file (here version 2) with the following (minimal) content:"


#: ../../source/How-To-Guides/Run-2-nodes-in-single-or-separate-docker-containers.rst:89
msgid "To run the containers call ``docker compose up`` in the same directory. You can close the containers with ``Ctrl+C``."
msgstr "To run the containers call ``docker compose up`` in the same directory. You can close the containers with ``Ctrl+C``."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:2
msgid "Setup ROS 2 with VSCode and Docker [community-contributed]"
msgstr "Setup ROS 2 with VSCode and Docker [community-contributed]"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:11
msgid "Install VS Code and Docker"
msgstr "Install VS Code and Docker"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:14
msgid "Using Visual Studio Code and Docker Containers will enable you to run your favorite ROS 2 Distribution without the necessity to change your operating system or use a virtual machine. With this tutorial you can set up a docker container, which can be used for your future ROS 2 projects."
msgstr "Using Visual Studio Code and Docker Containers will enable you to run your favorite ROS 2 Distribution without the necessity to change your operating system or use a virtual machine. With this tutorial you can set up a docker container, which can be used for your future ROS 2 projects."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:19
msgid "Install Docker"
msgstr "Install Docker"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:22
msgid "To install docker and set the correct user rights please use the following commands."
msgstr "To install docker and set the correct user rights please use the following commands."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:34
msgid "Now you can check if the installation was successful by running the following command:"
msgstr "Now you can check if the installation was successful by running the following command:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:40
msgid "You might need to start the Docker Daemon first, if you cannot run hello-world out of the box:"
msgstr "You might need to start the Docker Daemon first, if you cannot run hello-world out of the box:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:47
msgid "Install VS Code"
msgstr "Install VS Code"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:49
msgid "To install VS Code please use the following commands:"
msgstr "To install VS Code please use the following commands:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:60
msgid "You can run VS Code by typing ``code`` in a terminal."
msgstr "You can run VS Code by typing ``code`` in a terminal."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:64
msgid "Install Remote Development Extension"
msgstr "Install Remote Development Extension"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:67
msgid "Within VS Code search in Extensions (CTRL+SHIFT+X) for the \"Remote Development\" Extension and install it."
msgstr "Within VS Code search in Extensions (CTRL+SHIFT+X) for the \"Remote Development\" Extension and install it."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:71
msgid "Configure workspace in Docker and VS Code"
msgstr "Configure workspace in Docker and VS Code"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:74
msgid "Add your ROS 2 workspace"
msgstr "Add your ROS 2 workspace"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:77
msgid "Add a workspace in order to build and open them in a container, e.g.:"
msgstr "Add a workspace in order to build and open them in a container, e.g.:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:86
msgid "Now create a .devcontainer folder in the root of your workspace and add a devcontainer.json and Dockerfile to this .devcontainer folder. Additionally, you need to create a cache folder in which you can cache the build and install folders for different ROS 2 distros. The workspace structure should look like this:"
msgstr "Now create a .devcontainer folder in the root of your workspace and add a devcontainer.json and Dockerfile to this .devcontainer folder. Additionally, you need to create a cache folder in which you can cache the build and install folders for different ROS 2 distros. The workspace structure should look like this:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:108
msgid "With ``File->Open Folder...`` or ``Ctrl+K Ctrl+O``, open the ``src`` folder of your workspace in VS Code."
msgstr "With ``File->Open Folder...`` or ``Ctrl+K Ctrl+O``, open the ``src`` folder of your workspace in VS Code."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:111
msgid "Edit devcontainer.json for your environment"
msgstr "Edit devcontainer.json for your environment"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:113
msgid "For the Dev Container to function properly, we have to build it with the correct user. Therefore add the following to ``.devcontainer/devcontainer.json``:"
msgstr "For the Dev Container to function properly, we have to build it with the correct user. Therefore add the following to ``.devcontainer/devcontainer.json``:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:163
msgid "Use ``Ctrl+F`` to open the search and replace menu. Search for ``USERNAME`` and replace it with your ``Linux username``. If you do not know your username, you can find it by running ``echo $USERNAME`` in the terminal. Also replace ``ROS_DISTRO``, with the ROS 2 distribution that you want to use and added to the cache previously, for example, \"humble\" or \"foxy\"."
msgstr "Use ``Ctrl+F`` to open the search and replace menu. Search for ``USERNAME`` and replace it with your ``Linux username``. If you do not know your username, you can find it by running ``echo $USERNAME`` in the terminal. Also replace ``ROS_DISTRO``, with the ROS 2 distribution that you want to use and added to the cache previously, for example, \"humble\" or \"foxy\"."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:171
msgid "Edit Dockerfile"
msgstr "Edit Dockerfile"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:173
msgid "Open the Dockerfile and add the following contents:"
msgstr "Open the Dockerfile and add the following contents:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:204
msgid "Search here also for the ``USERNAME`` and replace it with your ``Linux username`` and the ``ROS_DISTRO`` with the ROS 2 distribution you wish to use and added to the cache previously."
msgstr "Search here also for the ``USERNAME`` and replace it with your ``Linux username`` and the ``ROS_DISTRO`` with the ROS 2 distribution you wish to use and added to the cache previously."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:208
msgid "Open and Build Development Container"
msgstr "Open and Build Development Container"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:210
msgid "Use ``View->Command Palette...`` or ``Ctrl+Shift+P`` to open the command palette. Search for the command ``Dev Containers: (Re-)build and Reopen in Container`` and execute it. This will build your development docker container for your. It will take a while - sit back or go for a coffee."
msgstr "Use ``View->Command Palette...`` or ``Ctrl+Shift+P`` to open the command palette. Search for the command ``Dev Containers: (Re-)build and Reopen in Container`` and execute it. This will build your development docker container for your. It will take a while - sit back or go for a coffee."


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:216
msgid "Test Container"
msgstr "Test Container"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:218
msgid "To test if everything worked correctly, open a terminal in the container using ``View->Terminal`` or ``Ctrl+Shift+``` and ``New Terminal`` in VS Code. Inside the terminal do the following:"
msgstr "To test if everything worked correctly, open a terminal in the container using ``View->Terminal`` or ``Ctrl+Shift+``` and ``New Terminal`` in VS Code. Inside the terminal do the following:"


#: ../../source/How-To-Guides/Setup-ROS-2-with-VSCode-and-Docker-Container.rst:227
msgid "There might be a problem with displaying RVIZ. If no window pops up, then check the value of ``echo $DISPLAY`` - if the output is 1, you can fix this problem with ``echo \"export DISPLAY=unix:1\" >> /etc/bash.bashrc`` and then test it again. You can also change the DISPLAY value in the devcontainer.json and rebuild it."
msgstr "There might be a problem with displaying RVIZ. If no window pops up, then check the value of ``echo $DISPLAY`` - if the output is 1, you can fix this problem with ``echo \"export DISPLAY=unix:1\" >> /etc/bash.bashrc`` and then test it again. You can also change the DISPLAY value in the devcontainer.json and rebuild it."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:9
msgid "Synchronous vs. asynchronous service clients"
msgstr "Synchronous vs. asynchronous service clients"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:11
msgid "**Level:** Intermediate"
msgstr "**Level:** Intermediate"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:13
msgid "**Time:** 10 minutes"
msgstr "**Time:** 10 minutes"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:21
msgid "Introduction"
msgstr "Introduction"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:23
msgid "This guide is intended to warn users of the risks associated with the Python synchronous service client ``call()`` API. It is very easy to mistakenly cause deadlock when calling services synchronously, so we do not recommend using ``call()``."
msgstr "This guide is intended to warn users of the risks associated with the Python synchronous service client ``call()`` API. It is very easy to mistakenly cause deadlock when calling services synchronously, so we do not recommend using ``call()``."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:26
msgid "We provide an example on how to use ``call()`` correctly for experienced users who wish to use synchronous calls and are aware of the pitfalls. We also highlight possible scenarios for deadlock that accompany it."
msgstr "We provide an example on how to use ``call()`` correctly for experienced users who wish to use synchronous calls and are aware of the pitfalls. We also highlight possible scenarios for deadlock that accompany it."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:29
msgid "Because we recommend avoiding sync calls, this guide will also address the features and usage of the recommended alternative, async calls (``call_async()``)."
msgstr "Because we recommend avoiding sync calls, this guide will also address the features and usage of the recommended alternative, async calls (``call_async()``)."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:31
msgid "The C++ service call API is only available in async, so the comparisons and examples in this guide pertain to Python services and clients. The definition of async given here generally applies to C++, with some exceptions."
msgstr "The C++ service call API is only available in async, so the comparisons and examples in this guide pertain to Python services and clients. The definition of async given here generally applies to C++, with some exceptions."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:35
msgid "1 Synchronous calls"
msgstr "1 Synchronous calls"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:37
msgid "A synchronous client will block the calling thread when sending a request to a service until a response has been received; nothing else can happen on that thread during the call. The call can take arbitrary amounts of time to complete. Once complete, the response returns directly to the client."
msgstr "A synchronous client will block the calling thread when sending a request to a service until a response has been received; nothing else can happen on that thread during the call. The call can take arbitrary amounts of time to complete. Once complete, the response returns directly to the client."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:41
msgid "The following is an example of how to correctly execute a synchronous service call from a client node, similar to the async node in the :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial."
msgstr "The following is an example of how to correctly execute a synchronous service call from a client node, similar to the async node in the :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:88
msgid "Note inside ``main()`` that the client calls ``rclpy.spin`` in a separate thread. Both ``send_request`` and ``rclpy.spin`` are blocking, so they need to be on separate threads."
msgstr "Note inside ``main()`` that the client calls ``rclpy.spin`` in a separate thread. Both ``send_request`` and ``rclpy.spin`` are blocking, so they need to be on separate threads."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:92
msgid "1.1 Sync deadlock"
msgstr "1.1 Sync deadlock"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:94
msgid "There are several ways that the synchronous ``call()`` API can cause deadlock."
msgstr "There are several ways that the synchronous ``call()`` API can cause deadlock."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:96
msgid "As mentioned in the comments of the example above, failing to create a separate thread to spin ``rclpy`` is one cause of deadlock. When a client is blocking a thread waiting for a response, but the response can only be returned on that same thread, the client will never stop waiting, and nothing else can happen."
msgstr "As mentioned in the comments of the example above, failing to create a separate thread to spin ``rclpy`` is one cause of deadlock. When a client is blocking a thread waiting for a response, but the response can only be returned on that same thread, the client will never stop waiting, and nothing else can happen."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:99
msgid "Another cause of deadlock is blocking ``rclpy.spin`` by calling a service synchronously in a subscription, timer callback or service callback. For example, if the synchronous client's ``send_request`` is placed in a callback:"
msgstr "Another cause of deadlock is blocking ``rclpy.spin`` by calling a service synchronously in a subscription, timer callback or service callback. For example, if the synchronous client's ``send_request`` is placed in a callback:"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:113
msgid "Deadlock occurs because ``rclpy.spin`` will not preempt the callback with the ``send_request`` call. In general, callbacks should only perform light and fast operations."
msgstr "Deadlock occurs because ``rclpy.spin`` will not preempt the callback with the ``send_request`` call. In general, callbacks should only perform light and fast operations."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:118
msgid "When deadlock occurs, you will not receive any indication that the service is blocked. There will be no warning or exception thrown, no indication in the stack trace, and the call will not fail."
msgstr "When deadlock occurs, you will not receive any indication that the service is blocked. There will be no warning or exception thrown, no indication in the stack trace, and the call will not fail."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:122
msgid "2 Asynchronous calls"
msgstr "2 Asynchronous calls"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:124
msgid "Async calls in ``rclpy`` are entirely safe and the recommended method of calling services. They can be made from anywhere without running the risk of blocking other ROS and non-ROS processes, unlike sync calls."
msgstr "Async calls in ``rclpy`` are entirely safe and the recommended method of calling services. They can be made from anywhere without running the risk of blocking other ROS and non-ROS processes, unlike sync calls."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:127
msgid "An asynchronous client will immediately return ``future``, a value that indicates whether the call and response is finished (not the value of the response itself), after sending a request to a service. The returned ``future`` may be queried for a response at any time."
msgstr "An asynchronous client will immediately return ``future``, a value that indicates whether the call and response is finished (not the value of the response itself), after sending a request to a service. The returned ``future`` may be queried for a response at any time."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:130
msgid "Since sending a request doesn’t block anything, a loop can be used to both spin ``rclpy`` and check ``future`` in the same thread, for example:"
msgstr "Since sending a request doesn’t block anything, a loop can be used to both spin ``rclpy`` and check ``future`` in the same thread, for example:"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:139
msgid "The :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial for Python illustrates how to perform an async service call and retrieve the ``future`` using a loop."
msgstr "The :doc:`Simple Service and Client <../Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client>` tutorial for Python illustrates how to perform an async service call and retrieve the ``future`` using a loop."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:141
msgid "The ``future`` can also be retrieved using a timer or callback, like in `this example <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py>`_, a dedicated thread, or by another method. It is up to you, as the caller, to decide how to store ``future``, check on its status, and retrieve your response."
msgstr "The ``future`` can also be retrieved using a timer or callback, like in `this example <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client_async_callback.py>`_, a dedicated thread, or by another method. It is up to you, as the caller, to decide how to store ``future``, check on its status, and retrieve your response."


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:145
msgid "Summary"
msgstr "Summary"


#: ../../source/How-To-Guides/Sync-Vs-Async.rst:147
msgid "It is not recommended to implement a synchronous service client. They are susceptible to deadlock, but will not provide any indication of issue when deadlock occurs. If you must use synchronous calls, the example in section `1 Synchronous calls`_ is a safe method of doing so. You should also be aware of the conditions that cause deadlock outlined in section `1.1 Sync deadlock`_. We recommend using async service clients instead."
msgstr "It is not recommended to implement a synchronous service client. They are susceptible to deadlock, but will not provide any indication of issue when deadlock occurs. If you must use synchronous calls, the example in section `1 Synchronous calls`_ is a safe method of doing so. You should also be aware of the conditions that cause deadlock outlined in section `1.1 Sync deadlock`_. We recommend using async service clients instead."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:4
msgid "Topics vs Services vs Actions"
msgstr "Topics vs Services vs Actions"


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:10
msgid "When designing a system there are three primary styles of interfaces. The specifications for the content is in the :doc:`Interfaces Overview <../Concepts/About-ROS-Interfaces>`. This is written to provide the reader with guidelines about when to use each type of interface."
msgstr "When designing a system there are three primary styles of interfaces. The specifications for the content is in the :doc:`Interfaces Overview <../Concepts/About-ROS-Interfaces>`. This is written to provide the reader with guidelines about when to use each type of interface."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:15
msgid "Topics"
msgstr "Topics"


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:17
msgid "Should be used for continuous data streams (sensor data, robot state, ...)."
msgstr "Should be used for continuous data streams (sensor data, robot state, ...)."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:18
msgid "Are for continuous data flow. Data might be published and subscribed at any time independent of any senders/receivers. Many to many connection. Callbacks receive data once it is available. The publisher decides when data is sent."
msgstr "Are for continuous data flow. Data might be published and subscribed at any time independent of any senders/receivers. Many to many connection. Callbacks receive data once it is available. The publisher decides when data is sent."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:21
msgid "Services"
msgstr "Services"


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:23
msgid "Should be used for remote procedure calls that terminate quickly, e.g. for querying the state of a node or doing a quick calculation such as IK. They should never be used for longer running processes, in particular processes that might be required to preempt if exceptional situations occur and they should never change or depend on state to avoid unwanted side effects for other nodes."
msgstr "Should be used for remote procedure calls that terminate quickly, e.g. for querying the state of a node or doing a quick calculation such as IK. They should never be used for longer running processes, in particular processes that might be required to preempt if exceptional situations occur and they should never change or depend on state to avoid unwanted side effects for other nodes."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:24
msgid "Simple blocking call. Mostly used for comparably fast tasks as requesting specific data. Semantically for processing requests."
msgstr "Simple blocking call. Mostly used for comparably fast tasks as requesting specific data. Semantically for processing requests."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:27
msgid "Actions"
msgstr "Actions"


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:29
msgid "Should be used for any discrete behavior that moves a robot or that runs for a longer time but provides feedback during execution."
msgstr "Should be used for any discrete behavior that moves a robot or that runs for a longer time but provides feedback during execution."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:30
msgid "The most important property of actions is that they can be preempted and preemption should always be implemented cleanly by action servers."
msgstr "The most important property of actions is that they can be preempted and preemption should always be implemented cleanly by action servers."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:31
msgid "Actions can keep state for the lifetime of a goal, i.e. if executing two action goals in parallel on the same server, for each client a separate state instance can be kept since the goal is uniquely identified by its id."
msgstr "Actions can keep state for the lifetime of a goal, i.e. if executing two action goals in parallel on the same server, for each client a separate state instance can be kept since the goal is uniquely identified by its id."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:32
msgid "Slow perception routines which take several seconds to terminate or initiating a lower-level control mode are good use cases for actions."
msgstr "Slow perception routines which take several seconds to terminate or initiating a lower-level control mode are good use cases for actions."


#: ../../source/How-To-Guides/Topics-Services-Actions.rst:33
msgid "More complex non-blocking background processing. Used for longer tasks like execution of robot actions. Semantically for real-world actions."
msgstr "More complex non-blocking background processing. Used for longer tasks like execution of robot actions. Semantically for real-world actions."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:9
msgid "Using Python Packages with ROS 2"
msgstr "Using Python Packages with ROS 2"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:11
msgid "**Goal:** Explain how to interoperate with other Python packages from the ROS 2 ecosystem."
msgstr "**Goal:** Explain how to interoperate with other Python packages from the ROS 2 ecosystem."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:19
msgid "A cautionary note, if you intended to use pre-packaged binaries (either ``deb`` files, or the “fat” binary distributions), the Python interpreter must match what was used to build the original binaries. If you intend to use something like ``virtualenv`` or ``pipenv``\\, make sure to use the system interpreter. If you use something like ``conda``, it is very likely that the interpreter will not match the system interpreter and will be incompatible with ROS 2 binaries."
msgstr "A cautionary note, if you intended to use pre-packaged binaries (either ``deb`` files, or the “fat” binary distributions), the Python interpreter must match what was used to build the original binaries. If you intend to use something like ``virtualenv`` or ``pipenv``\\, make sure to use the system interpreter. If you use something like ``conda``, it is very likely that the interpreter will not match the system interpreter and will be incompatible with ROS 2 binaries."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:24
msgid "Installing via ``rosdep``"
msgstr "Installing via ``rosdep``"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:26
msgid "The fastest way to include third-party python packages is to use their corresponding rosdep keys, if available.  ``rosdep`` keys can be checked via:"
msgstr "The fastest way to include third-party python packages is to use their corresponding rosdep keys, if available.  ``rosdep`` keys can be checked via:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:28
msgid "https://github.com/ros/rosdistro/blob/master/rosdep/base.yaml"
msgstr "https://github.com/ros/rosdistro/blob/master/rosdep/base.yaml"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:29
msgid "https://github.com/ros/rosdistro/blob/master/rosdep/python.yaml"
msgstr "https://github.com/ros/rosdistro/blob/master/rosdep/python.yaml"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:31
msgid "These ``rosdep`` keys can be added to your ``package.xml`` file, which indicates to the build system that your package (and dependent packages) depend on those keys. In a new workspace, you can also quickly install all rosdep keys with:"
msgstr "These ``rosdep`` keys can be added to your ``package.xml`` file, which indicates to the build system that your package (and dependent packages) depend on those keys. In a new workspace, you can also quickly install all rosdep keys with:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:38
msgid "If there aren’t currently ``rosdep`` keys for the package that you are interested in, it is possible to add them by following the `rosdep key contribution guide`_."
msgstr "If there aren’t currently ``rosdep`` keys for the package that you are interested in, it is possible to add them by following the `rosdep key contribution guide`_."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:40
msgid "To learn more about the ``rosdep`` tool and how it works, consult the `rosdep documentation`_."
msgstr "To learn more about the ``rosdep`` tool and how it works, consult the `rosdep documentation`_."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:43
msgid "Installing via a package manager"
msgstr "Installing via a package manager"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:45
msgid "If you don’t want to make a rosdep key, but the package is available in your system package manager (eg ``apt``), you can install and use the package that way:"
msgstr "If you don’t want to make a rosdep key, but the package is available in your system package manager (eg ``apt``), you can install and use the package that way:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:51
msgid "If the package is available on `The Python Package Index (PyPI) <https://pypi.org/>`_ and you want to install globally on your system:"
msgstr "If the package is available on `The Python Package Index (PyPI) <https://pypi.org/>`_ and you want to install globally on your system:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:57
msgid "If the package is available on PyPI and you want to install locally to your user:"
msgstr "If the package is available on PyPI and you want to install locally to your user:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:64
msgid "Installing via a virtual environment"
msgstr "Installing via a virtual environment"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:66
msgid "First, create a Colcon workspace:"
msgstr "First, create a Colcon workspace:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:73
msgid "Then setup your virtual environment:"
msgstr "Then setup your virtual environment:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:83
msgid "Next, install the Python packages that you want in your virtual environment:"
msgstr "Next, install the Python packages that you want in your virtual environment:"


#: ../../source/How-To-Guides/Using-Python-Packages.rst:89
msgid "Now you can build your workspace and run your python node that depends on packages installed in your virtual environment."
msgstr "Now you can build your workspace and run your python node that depends on packages installed in your virtual environment."


#: ../../source/How-To-Guides/Using-Python-Packages.rst:99
msgid "If you want to release your package using Bloom, you should add the packages you require to ``rosdep``, see the `rosdep key contribution guide`_."
msgstr "If you want to release your package using Bloom, you should add the packages you require to ``rosdep``, see the `rosdep key contribution guide`_."


#: ../../source/How-To-Guides/Using-Variants.rst:2
msgid "Using variants"
msgstr "Using variants"


#: ../../source/How-To-Guides/Using-Variants.rst:4
msgid "Metapackages do not provide software directly but depend on a group of other related packages to provide a convienent installation mechanism for the complete group of packages. [#]_ [#]_ Variants are a list of official metapackages for commonly useful groups of ROS packages."
msgstr "Metapackages do not provide software directly but depend on a group of other related packages to provide a convienent installation mechanism for the complete group of packages. [#]_ [#]_ Variants are a list of official metapackages for commonly useful groups of ROS packages."


#: ../../source/How-To-Guides/Using-Variants.rst:7
msgid "https://wiki.debian.org/metapackage"
msgstr "https://wiki.debian.org/metapackage"


#: ../../source/How-To-Guides/Using-Variants.rst:8
msgid "https://help.ubuntu.com/community/MetaPackages"
msgstr "https://help.ubuntu.com/community/MetaPackages"


#: ../../source/How-To-Guides/Using-Variants.rst:10
msgid "The different variants in ROS 2 are specified in `REP-2001 <https://ros.org/reps/rep-2001.html>`_."
msgstr "The different variants in ROS 2 are specified in `REP-2001 <https://ros.org/reps/rep-2001.html>`_."


#: ../../source/How-To-Guides/Using-Variants.rst:12
msgid "In addition to the official variants, there may be metapackages for specific institutions or robots as described in `REP-108 <https://www.ros.org/reps/rep-0108.html#institution-specific>`_."
msgstr "In addition to the official variants, there may be metapackages for specific institutions or robots as described in `REP-108 <https://www.ros.org/reps/rep-0108.html#institution-specific>`_."


#: ../../source/How-To-Guides/Using-Variants.rst:15
msgid "Adding variants"
msgstr "Adding variants"


#: ../../source/How-To-Guides/Using-Variants.rst:17
msgid "Additional variants that are of general use to the ROS community can be proposed by contributing an update to `REP-2001 via pull request <https://github.com/ros-infrastructure/rep/blob/master/rep-2001.rst>`_ describing the packages included in the new variant. Institution and robot specific variants can be published directly by their respective maintainers and no update to REP-2001 is required."
msgstr "Additional variants that are of general use to the ROS community can be proposed by contributing an update to `REP-2001 via pull request <https://github.com/ros-infrastructure/rep/blob/master/rep-2001.rst>`_ describing the packages included in the new variant. Institution and robot specific variants can be published directly by their respective maintainers and no update to REP-2001 is required."


#: ../../source/How-To-Guides/Using-Variants.rst:21
msgid "Creating project-specific variants"
msgstr "Creating project-specific variants"


#: ../../source/How-To-Guides/Using-Variants.rst:23
msgid "If you are creating ROS packages to use privately in your own projects, you can create variants specific to your projects using the official variants as examples. To do so you need only create two files:"
msgstr "If you are creating ROS packages to use privately in your own projects, you can create variants specific to your projects using the official variants as examples. To do so you need only create two files:"


#: ../../source/How-To-Guides/Using-Variants.rst:26
msgid "A minimal variant package is created as a package with the ``ament_cmake`` build type, a ``buildtool_depend`` on ``ament_cmake`` and ``exec_depend`` entries for each package you want to include in the variant."
msgstr "A minimal variant package is created as a package with the ``ament_cmake`` build type, a ``buildtool_depend`` on ``ament_cmake`` and ``exec_depend`` entries for each package you want to include in the variant."


#: ../../source/How-To-Guides/Using-Variants.rst:49
msgid "A minimal ament_cmake package includes a ``CMakeLists.txt`` which registers the package.xml as an ament package for use in ROS 2."
msgstr "A minimal ament_cmake package includes a ``CMakeLists.txt`` which registers the package.xml as an ament package for use in ROS 2."


#: ../../source/How-To-Guides/Using-Variants.rst:59
msgid "You can then build and install your variant package alongside your other private packages."
msgstr "You can then build and install your variant package alongside your other private packages."


#: ../../source/How-To-Guides/Using-Variants.rst:62
msgid "Creating custom variants with platform-specific tools"
msgstr "Creating custom variants with platform-specific tools"


#: ../../source/How-To-Guides/Using-Variants.rst:64
msgid "Some platforms have tools for creating basic packages that do not require a full ROS build farm environment or equivalent infrastructure. It is possible to use these tools to create platform-dependent variants. This approach does not include support for ROS packaging tools and is platform dependent but requires much less infrastructure to produce if you are creating collections of existing packages rather than a mix of public and private ROS packages. For example, on Debian or Ubuntu systems you can use the ``equivs`` utilities. The Debian Administrator's handbook has a `Section on meta-packages <https://www.debian.org/doc/manuals/debian-handbook/sect.building-first-package.en.html#id-1.18.5.2>`_."
msgstr "Some platforms have tools for creating basic packages that do not require a full ROS build farm environment or equivalent infrastructure. It is possible to use these tools to create platform-dependent variants. This approach does not include support for ROS packaging tools and is platform dependent but requires much less infrastructure to produce if you are creating collections of existing packages rather than a mix of public and private ROS packages. For example, on Debian or Ubuntu systems you can use the ``equivs`` utilities. The Debian Administrator's handbook has a `Section on meta-packages <https://www.debian.org/doc/manuals/debian-handbook/sect.building-first-package.en.html#id-1.18.5.2>`_."


#: ../../source/How-To-Guides/Using-callback-groups.rst:2
msgid "Using Callback Groups"
msgstr "Using Callback Groups"


#: ../../source/How-To-Guides/Using-callback-groups.rst:4
msgid "When running a node in a Multi-Threaded Executor, ROS 2 offers callback groups as a tool for controlling the execution of different callbacks. This page is meant as a guide on how to use callback groups efficiently. It is assumed that the reader has a basic understanding about the concept of :doc:`executors <../Concepts/About-Executors>`."
msgstr "When running a node in a Multi-Threaded Executor, ROS 2 offers callback groups as a tool for controlling the execution of different callbacks. This page is meant as a guide on how to use callback groups efficiently. It is assumed that the reader has a basic understanding about the concept of :doc:`executors <../Concepts/About-Executors>`."


#: ../../source/How-To-Guides/Using-callback-groups.rst:14
msgid "Basics of callback groups"
msgstr "Basics of callback groups"


#: ../../source/How-To-Guides/Using-callback-groups.rst:16
msgid "When running a node in a Multi-Threaded Executor, ROS 2 offers two different types of callback groups for controlling execution of callbacks:"
msgstr "When running a node in a Multi-Threaded Executor, ROS 2 offers two different types of callback groups for controlling execution of callbacks:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:20
msgid "Mutually Exclusive Callback Group"
msgstr "Mutually Exclusive Callback Group"


#: ../../source/How-To-Guides/Using-callback-groups.rst:21
msgid "Reentrant Callback Group"
msgstr "Reentrant Callback Group"


#: ../../source/How-To-Guides/Using-callback-groups.rst:23
msgid "These callback groups restrict the execution of their callbacks in different ways. In short:"
msgstr "These callback groups restrict the execution of their callbacks in different ways. In short:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:27
msgid "Mutually Exclusive Callback Group prevents its callbacks from being executed in parallel - essentially making it as if the callbacks in the group were executed by a SingleThreadedExecutor."
msgstr "Mutually Exclusive Callback Group prevents its callbacks from being executed in parallel - essentially making it as if the callbacks in the group were executed by a SingleThreadedExecutor."


#: ../../source/How-To-Guides/Using-callback-groups.rst:30
msgid "Reentrant Callback Group allows the executor to schedule and execute the group's callbacks in any way it sees fit, without restrictions. This means that, in addition to different callbacks being run parallel to each other, different instances of the same callback may also be executed concurrently."
msgstr "Reentrant Callback Group allows the executor to schedule and execute the group's callbacks in any way it sees fit, without restrictions. This means that, in addition to different callbacks being run parallel to each other, different instances of the same callback may also be executed concurrently."


#: ../../source/How-To-Guides/Using-callback-groups.rst:35
msgid "Callbacks belonging to different callback groups (of any type) can always be executed parallel to each other."
msgstr "Callbacks belonging to different callback groups (of any type) can always be executed parallel to each other."


#: ../../source/How-To-Guides/Using-callback-groups.rst:38
msgid "It is also important to keep in mind that different ROS 2 entities relay their callback group to all callbacks they spawn. For example, if one assigns a callback group to an action client, all callbacks created by the client will be assigned to that callback group."
msgstr "It is also important to keep in mind that different ROS 2 entities relay their callback group to all callbacks they spawn. For example, if one assigns a callback group to an action client, all callbacks created by the client will be assigned to that callback group."


#: ../../source/How-To-Guides/Using-callback-groups.rst:43
msgid "Callback groups can be created by a node's ``create_callback_group`` function in rclcpp and by calling the constructor of the group in rclpy. The callback group can then be passed as argument/option when creating a subscription, timer, etc."
msgstr "Callback groups can be created by a node's ``create_callback_group`` function in rclcpp and by calling the constructor of the group in rclpy. The callback group can then be passed as argument/option when creating a subscription, timer, etc."


#: ../../source/How-To-Guides/Using-callback-groups.rst:69
msgid "If the user does not specify any callback group when creating a subscription, timer, etc., this entity will be assigned to the node's default callback group. The default callback group is a Mutually Exclusive Callback Group and it can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and via ``Node.default_callback_group`` in rclpy."
msgstr "If the user does not specify any callback group when creating a subscription, timer, etc., this entity will be assigned to the node's default callback group. The default callback group is a Mutually Exclusive Callback Group and it can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and via ``Node.default_callback_group`` in rclpy."


#: ../../source/How-To-Guides/Using-callback-groups.rst:76
msgid "About callbacks"
msgstr "About callbacks"


#: ../../source/How-To-Guides/Using-callback-groups.rst:78
msgid "In the context of ROS 2 and executors, a callback means a function whose scheduling and execution is handled by an executor. Examples of callbacks in this context are"
msgstr "In the context of ROS 2 and executors, a callback means a function whose scheduling and execution is handled by an executor. Examples of callbacks in this context are"


#: ../../source/How-To-Guides/Using-callback-groups.rst:82
msgid "subscription callbacks (receiving and handling data from a topic),"
msgstr "subscription callbacks (receiving and handling data from a topic),"


#: ../../source/How-To-Guides/Using-callback-groups.rst:83
msgid "timer callbacks,"
msgstr "timer callbacks,"


#: ../../source/How-To-Guides/Using-callback-groups.rst:84
msgid "service callbacks (for executing service requests in a server),"
msgstr "service callbacks (for executing service requests in a server),"


#: ../../source/How-To-Guides/Using-callback-groups.rst:85
msgid "different callbacks in action servers and clients,"
msgstr "different callbacks in action servers and clients,"


#: ../../source/How-To-Guides/Using-callback-groups.rst:86
msgid "done-callbacks of Futures."
msgstr "done-callbacks of Futures."


#: ../../source/How-To-Guides/Using-callback-groups.rst:88
msgid "Below are a couple important points about callbacks that should be kept in mind when working with callback groups."
msgstr "Below are a couple important points about callbacks that should be kept in mind when working with callback groups."


#: ../../source/How-To-Guides/Using-callback-groups.rst:91
msgid "Almost everything in ROS 2 is a callback! Every function that is run by an executor is, by definition, a callback. The non-callback functions in a ROS 2 system are found mainly at the edge of the system (user and sensor inputs etc)."
msgstr "Almost everything in ROS 2 is a callback! Every function that is run by an executor is, by definition, a callback. The non-callback functions in a ROS 2 system are found mainly at the edge of the system (user and sensor inputs etc)."


#: ../../source/How-To-Guides/Using-callback-groups.rst:95
msgid "Sometimes the callbacks are hidden and their presence may not be obvious from the user/developer API. This is the case especially with any kind of “synchronous” call to a service or an action (in rclpy). For example, the synchronous call ``Client.call(request)`` to a service adds a Future's done-callback that needs to be executed during the execution of the function call, but this callback is not directly visible to the user."
msgstr "Sometimes the callbacks are hidden and their presence may not be obvious from the user/developer API. This is the case especially with any kind of “synchronous” call to a service or an action (in rclpy). For example, the synchronous call ``Client.call(request)`` to a service adds a Future's done-callback that needs to be executed during the execution of the function call, but this callback is not directly visible to the user."


#: ../../source/How-To-Guides/Using-callback-groups.rst:106
msgid "Controlling execution"
msgstr "Controlling execution"


#: ../../source/How-To-Guides/Using-callback-groups.rst:108
msgid "In order to control execution with callback groups, one can consider the following guidelines."
msgstr "In order to control execution with callback groups, one can consider the following guidelines."


#: ../../source/How-To-Guides/Using-callback-groups.rst:111
msgid "For the interaction of an individual callback with itself:"
msgstr "For the interaction of an individual callback with itself:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:113
msgid "Register it to a Reentrant Callback Group if it should be executed in parallel to itself. An example case could be an action/service server that needs to be able to process several action calls in parallel to each other."
msgstr "Register it to a Reentrant Callback Group if it should be executed in parallel to itself. An example case could be an action/service server that needs to be able to process several action calls in parallel to each other."


#: ../../source/How-To-Guides/Using-callback-groups.rst:117
msgid "Register it to a Mutually Exclusive Callback Group if it should **never** be executed in parallel to itself. An example case could be a timer callback that runs a control loop that publishes control commands."
msgstr "Register it to a Mutually Exclusive Callback Group if it should **never** be executed in parallel to itself. An example case could be a timer callback that runs a control loop that publishes control commands."


#: ../../source/How-To-Guides/Using-callback-groups.rst:120
msgid "For the interaction of different callbacks with each other:"
msgstr "For the interaction of different callbacks with each other:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:122
msgid "Register them to the same Mutually Exclusive Callback Group if they should **never** be executed in parallel. An example case could be that the callbacks are accessing shared critical and non-thread-safe resources."
msgstr "Register them to the same Mutually Exclusive Callback Group if they should **never** be executed in parallel. An example case could be that the callbacks are accessing shared critical and non-thread-safe resources."


#: ../../source/How-To-Guides/Using-callback-groups.rst:125
msgid "If they should be executed in parallel, you have two options, depending on whether the individual callbacks should be able to overlap themselves or not:"
msgstr "If they should be executed in parallel, you have two options, depending on whether the individual callbacks should be able to overlap themselves or not:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:128
msgid "Register them to different Mutually Exclusive Callback Groups (no overlap of the individual callbacks)"
msgstr "Register them to different Mutually Exclusive Callback Groups (no overlap of the individual callbacks)"


#: ../../source/How-To-Guides/Using-callback-groups.rst:130
msgid "Register them to a Reentrant Callback Group (overlap of the individual callbacks)"
msgstr "Register them to a Reentrant Callback Group (overlap of the individual callbacks)"


#: ../../source/How-To-Guides/Using-callback-groups.rst:132
msgid "An example case of running different callbacks in parallel is a Node that has a synchronous service client and a timer calling this service. See the detailed example below."
msgstr "An example case of running different callbacks in parallel is a Node that has a synchronous service client and a timer calling this service. See the detailed example below."


#: ../../source/How-To-Guides/Using-callback-groups.rst:137
msgid "Avoiding deadlocks"
msgstr "Avoiding deadlocks"


#: ../../source/How-To-Guides/Using-callback-groups.rst:139
msgid "Setting up callback groups of a node incorrectly can lead to deadlocks (or other unwanted behavior), especially if one desires to use synchronous calls to services or actions. Indeed, even the API documentation of ROS 2 mentions that synchronous calls to actions or services should not be done in callbacks, because it can lead to deadlocks. While using asynchronous calls is indeed safer in this regard, synchronous calls can also be made to work. On the other hand, synchronous calls also have their advantages, such as making the code simpler and easier to understand. Hence, this section provides some guidelines on how to set up a node's callback groups correctly in order to avoid deadlocks."
msgstr "Setting up callback groups of a node incorrectly can lead to deadlocks (or other unwanted behavior), especially if one desires to use synchronous calls to services or actions. Indeed, even the API documentation of ROS 2 mentions that synchronous calls to actions or services should not be done in callbacks, because it can lead to deadlocks. While using asynchronous calls is indeed safer in this regard, synchronous calls can also be made to work. On the other hand, synchronous calls also have their advantages, such as making the code simpler and easier to understand. Hence, this section provides some guidelines on how to set up a node's callback groups correctly in order to avoid deadlocks."


#: ../../source/How-To-Guides/Using-callback-groups.rst:152
msgid "First thing to note here is that every node's default callback group is a Mutually Exclusive Callback Group. If the user does not specify any other callback group when creating a timer, subscription, client etc., any callbacks created then or later by these entities will use the node's default callback group. Furthermore, if everything in a node uses the same Mutually Exclusive Callback Group, that node essentially acts as if it was handled by a Single-Threaded Executor, even if a multi-threaded one is specified! Thus, whenever one decides to use a Multi-Threaded Executor, some callback group(s) should always be specified in order for the executor choice to make sense."
msgstr "First thing to note here is that every node's default callback group is a Mutually Exclusive Callback Group. If the user does not specify any other callback group when creating a timer, subscription, client etc., any callbacks created then or later by these entities will use the node's default callback group. Furthermore, if everything in a node uses the same Mutually Exclusive Callback Group, that node essentially acts as if it was handled by a Single-Threaded Executor, even if a multi-threaded one is specified! Thus, whenever one decides to use a Multi-Threaded Executor, some callback group(s) should always be specified in order for the executor choice to make sense."


#: ../../source/How-To-Guides/Using-callback-groups.rst:164
msgid "With the above in mind, here are a couple guidelines to help avoid deadlocks:"
msgstr "With the above in mind, here are a couple guidelines to help avoid deadlocks:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:166
msgid "If you make a synchronous call in any type of a callback, this callback and the client making the call need to belong to"
msgstr "If you make a synchronous call in any type of a callback, this callback and the client making the call need to belong to"


#: ../../source/How-To-Guides/Using-callback-groups.rst:169
msgid "different callback groups (of any type), or"
msgstr "different callback groups (of any type), or"


#: ../../source/How-To-Guides/Using-callback-groups.rst:170
msgid "a Reentrant Callback Group."
msgstr "a Reentrant Callback Group."


#: ../../source/How-To-Guides/Using-callback-groups.rst:172
msgid "If the above configuration is not possible due to other requirements - such as thread-safety and/or blocking of other callbacks while waiting for the result (or if you want to make absolutely sure that there is never a possibility of a deadlock), use asynchronous calls."
msgstr "If the above configuration is not possible due to other requirements - such as thread-safety and/or blocking of other callbacks while waiting for the result (or if you want to make absolutely sure that there is never a possibility of a deadlock), use asynchronous calls."


#: ../../source/How-To-Guides/Using-callback-groups.rst:177
msgid "Failing the first point will always cause a deadlock. An example of such a case would be making a synchronous service call in a timer callback (see the next section for an example)."
msgstr "Failing the first point will always cause a deadlock. An example of such a case would be making a synchronous service call in a timer callback (see the next section for an example)."


#: ../../source/How-To-Guides/Using-callback-groups.rst:185
msgid "Let us look at some simple examples of different callback group setups. The following demo code considers calling a service synchronously in a timer callback."
msgstr "Let us look at some simple examples of different callback group setups. The following demo code considers calling a service synchronously in a timer callback."


#: ../../source/How-To-Guides/Using-callback-groups.rst:190
msgid "Demo code"
msgstr "Demo code"


#: ../../source/How-To-Guides/Using-callback-groups.rst:192
msgid "We have two nodes - one providing a simple service:"
msgstr "We have two nodes - one providing a simple service:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:277
msgid "and another containing a client to the service along with a timer for making service calls:"
msgstr "and another containing a client to the service along with a timer for making service calls:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:284
msgid "*Note:* The API of service client in rclcpp does not offer a synchronous call method similar to the one in rclpy, so we wait on the future object to simulate the effect of a synchronous call."
msgstr "*Note:* The API of service client in rclcpp does not offer a synchronous call method similar to the one in rclpy, so we wait on the future object to simulate the effect of a synchronous call."


#: ../../source/How-To-Guides/Using-callback-groups.rst:387
msgid "The client node's constructor contains options for setting the callback groups of the service client and the timer. With the default setting above (both being ``nullptr`` / ``None``), both the timer and the client will use the node's default Mutually Exclusive Callback Group."
msgstr "The client node's constructor contains options for setting the callback groups of the service client and the timer. With the default setting above (both being ``nullptr`` / ``None``), both the timer and the client will use the node's default Mutually Exclusive Callback Group."


#: ../../source/How-To-Guides/Using-callback-groups.rst:394
msgid "The problem"
msgstr "The problem"


#: ../../source/How-To-Guides/Using-callback-groups.rst:396
msgid "Since we are making service calls with a 1 second timer, the expected outcome is that the service gets called once a second, the client always gets a response and prints ``Received response``. If we try running the server and client nodes in terminals, we get the following outputs."
msgstr "Since we are making service calls with a 1 second timer, the expected outcome is that the service gets called once a second, the client always gets a response and prints ``Received response``. If we try running the server and client nodes in terminals, we get the following outputs."


#: ../../source/How-To-Guides/Using-callback-groups.rst:404 ../../source/How-To-Guides/Using-callback-groups.rst:467
msgid "Client"
msgstr "Client"


#: ../../source/How-To-Guides/Using-callback-groups.rst:412 ../../source/How-To-Guides/Using-callback-groups.rst:482
msgid "Server"
msgstr "Server"


#: ../../source/How-To-Guides/Using-callback-groups.rst:420
msgid "So, it turns out that instead of the service being called repeatedly, the response of the first call is never received, after which the client node seemingly gets stuck and does not make further calls. That is, the execution stopped at a deadlock!"
msgstr "So, it turns out that instead of the service being called repeatedly, the response of the first call is never received, after which the client node seemingly gets stuck and does not make further calls. That is, the execution stopped at a deadlock!"


#: ../../source/How-To-Guides/Using-callback-groups.rst:425
msgid "The reason for this is that the timer callback and the client are using the same Mutually Exclusive Callback Group (the node's default). When the service call is made, the client then passes its callback group to the Future object (hidden inside the call-method in the Python version) whose done-callback needs to execute for the result of the service call to be available. But because this done-callback and the timer callback are in the same Mutually Exclusive group and the timer callback is still executing (waiting for the result of the service call), the done-callback never gets to execute. The stuck timer callback also blocks any other executions of itself, so the timer does not fire for a second time."
msgstr "The reason for this is that the timer callback and the client are using the same Mutually Exclusive Callback Group (the node's default). When the service call is made, the client then passes its callback group to the Future object (hidden inside the call-method in the Python version) whose done-callback needs to execute for the result of the service call to be available. But because this done-callback and the timer callback are in the same Mutually Exclusive group and the timer callback is still executing (waiting for the result of the service call), the done-callback never gets to execute. The stuck timer callback also blocks any other executions of itself, so the timer does not fire for a second time."


#: ../../source/How-To-Guides/Using-callback-groups.rst:439
msgid "Solution"
msgstr "Solution"


#: ../../source/How-To-Guides/Using-callback-groups.rst:441
msgid "We can fix this easily - for example - by assigning the timer and client to different callback groups. Thus, let us change the first two lines of the client node's constructor to be as follows (everything else shall stay the same):"
msgstr "We can fix this easily - for example - by assigning the timer and client to different callback groups. Thus, let us change the first two lines of the client node's constructor to be as follows (everything else shall stay the same):"


#: ../../source/How-To-Guides/Using-callback-groups.rst:462
msgid "Now we get the expected result, i.e. the timer fires repeatedly and each service call gets the result as it should:"
msgstr "Now we get the expected result, i.e. the timer fires repeatedly and each service call gets the result as it should:"


#: ../../source/How-To-Guides/Using-callback-groups.rst:493
msgid "One might consider if just avoiding the node's default callback group is enough. This is not the case: replacing the default group by a different Mutually Exclusive group changes nothing. Thus, the following configuration also leads to the previously discovered deadlock."
msgstr "One might consider if just avoiding the node's default callback group is enough. This is not the case: replacing the default group by a different Mutually Exclusive group changes nothing. Thus, the following configuration also leads to the previously discovered deadlock."


#: ../../source/How-To-Guides/Using-callback-groups.rst:516
msgid "In fact, the exact condition with which everything works in this case is that the timer and client must not belong to the same Mutually Exclusive group. Hence, all of the following configurations (and some others as well) produce the desired outcome where the timer fires repeatedly and service calls are completed."
msgstr "In fact, the exact condition with which everything works in this case is that the timer and client must not belong to the same Mutually Exclusive group. Hence, all of the following configurations (and some others as well) produce the desired outcome where the timer fires repeatedly and service calls are completed."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:2
msgid "Using ``ros1_bridge`` with upstream ROS on Ubuntu 22.04"
msgstr "Using ``ros1_bridge`` with upstream ROS on Ubuntu 22.04"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:8
msgid "The release of ROS 2 Humble (and Rolling) on Ubuntu 22.04 Jammy Jellyfish marks the first ROS 2 release on a platform with no official ROS 1 release. While ROS 1 Noetic will continue to be supported through the duration of its `long term support window <https://www.ros.org/reps/rep-0003.html#noetic-ninjemys-may-2020-may-2025>`__, it will only target Ubuntu 20.04. Alternatively, there are `upstream variants of ROS 1 packages <https://packages.ubuntu.com/jammy/ros-desktop>`__ in Debian and Ubuntu that are not maintained as an official distribution by the ROS maintainers."
msgstr "The release of ROS 2 Humble (and Rolling) on Ubuntu 22.04 Jammy Jellyfish marks the first ROS 2 release on a platform with no official ROS 1 release. While ROS 1 Noetic will continue to be supported through the duration of its `long term support window <https://www.ros.org/reps/rep-0003.html#noetic-ninjemys-may-2020-may-2025>`__, it will only target Ubuntu 20.04. Alternatively, there are `upstream variants of ROS 1 packages <https://packages.ubuntu.com/jammy/ros-desktop>`__ in Debian and Ubuntu that are not maintained as an official distribution by the ROS maintainers."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:12
msgid "This guide outlines the current mechanism for bridging ROS 2 releases with these upstream packages on Ubuntu 22.04 Jammy Jellyfish. This provides a migration path for users who still depend on ROS 1, but desire moving to newer ROS 2 and Ubuntu releases."
msgstr "This guide outlines the current mechanism for bridging ROS 2 releases with these upstream packages on Ubuntu 22.04 Jammy Jellyfish. This provides a migration path for users who still depend on ROS 1, but desire moving to newer ROS 2 and Ubuntu releases."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:16
msgid "ROS 2 via Debian packages"
msgstr "ROS 2 via Debian packages"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:18
msgid "Installing :doc:`ROS 2 from Debian packages <../Installation/Ubuntu-Install-Debians>` currently does not work for ROS 2 on Ubuntu Jammy. The version of ``catkin-pkg-modules`` available in the Ubuntu repository conflicts with that in the ROS 2 package repository."
msgstr "Installing :doc:`ROS 2 from Debian packages <../Installation/Ubuntu-Install-Debians>` currently does not work for ROS 2 on Ubuntu Jammy. The version of ``catkin-pkg-modules`` available in the Ubuntu repository conflicts with that in the ROS 2 package repository."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:21
msgid "If the ROS 2 apt repository is in the available apt repositories (``/etc/apt/sources.list.d``), no ROS 1 packages will be installable. The error will be:"
msgstr "If the ROS 2 apt repository is in the available apt repositories (``/etc/apt/sources.list.d``), no ROS 1 packages will be installable. The error will be:"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:40
msgid "To correct this, remove packages.ros.org from your ``sources.list``. If you were following the ROS 2 installation guide, simply remove ``/etc/apt/sources.list.d/ros2.list``"
msgstr "To correct this, remove packages.ros.org from your ``sources.list``. If you were following the ROS 2 installation guide, simply remove ``/etc/apt/sources.list.d/ros2.list``"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:43
msgid "For now, to support ``ros1_bridge``, follow the instructions below for building ROS 2 from source."
msgstr "For now, to support ``ros1_bridge``, follow the instructions below for building ROS 2 from source."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:46
msgid "ROS 2 from source"
msgstr "ROS 2 from source"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:48
msgid "Installing :doc:`ROS 2 from Source <../Installation/Alternatives/Ubuntu-Development-Setup>` is the only configuration that works for ROS 2 on Ubuntu Jammy."
msgstr "Installing :doc:`ROS 2 from Source <../Installation/Alternatives/Ubuntu-Development-Setup>` is the only configuration that works for ROS 2 on Ubuntu Jammy."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:50
msgid "Below is a summary of the necessary instructions from the source build instructions. The substantial deviation is that we skip using the ROS 2 apt repositories because of conflicting packages."
msgstr "Below is a summary of the necessary instructions from the source build instructions. The substantial deviation is that we skip using the ROS 2 apt repositories because of conflicting packages."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:54
msgid "Install development tools and ROS tools"
msgstr "Install development tools and ROS tools"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:56
msgid "Since we aren't using the ROS 2 apt repositories, ``colcon`` must be installed via ``pip``."
msgstr "Since we aren't using the ROS 2 apt repositories, ``colcon`` must be installed via ``pip``."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:85
msgid "From here, continue with the :doc:`source install guide <../Installation/Alternatives/Ubuntu-Development-Setup>` to build ROS 2."
msgstr "From here, continue with the :doc:`source install guide <../Installation/Alternatives/Ubuntu-Development-Setup>` to build ROS 2."


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:88
msgid "Install ROS 1 from Ubuntu packages"
msgstr "Install ROS 1 from Ubuntu packages"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:96
msgid "Build ``ros1_bridge``"
msgstr "Build ``ros1_bridge``"


#: ../../source/How-To-Guides/Using-ros1_bridge-Jammy-upstream.rst:112
msgid "After building all of ``ros1_bridge``, the remainder of the `ros1_bridge examples <https://github.com/ros2/ros1_bridge#example-1-run-the-bridge-and-the-example-talker-and-listener>`__ should work with your new installation"
msgstr "After building all of ``ros1_bridge``, the remainder of the `ros1_bridge examples <https://github.com/ros2/ros1_bridge#example-1-run-the-bridge-and-the-example-talker-and-listener>`__ should work with your new installation"


#: ../../source/How-To-Guides/Using-ros2-param.rst:2
msgid "Using the ``ros2 param`` command-line tool"
msgstr "Using the ``ros2 param`` command-line tool"


#: ../../source/How-To-Guides/Using-ros2-param.rst:8
msgid "Parameters in ROS 2 can be get, set, listed, and described through a set of services as described in :doc:`the concept document <../Concepts/About-ROS-2-Parameters>`. The ``ros2 param`` command-line tool is a wrapper around these service calls that makes it easy to manipulate parameters from the command-line."
msgstr "Parameters in ROS 2 can be get, set, listed, and described through a set of services as described in :doc:`the concept document <../Concepts/About-ROS-2-Parameters>`. The ``ros2 param`` command-line tool is a wrapper around these service calls that makes it easy to manipulate parameters from the command-line."


#: ../../source/How-To-Guides/Using-ros2-param.rst:12
msgid "``ros2 param list``"
msgstr "``ros2 param list``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:14
msgid "This command will list all of the available parameters on a given node, or on all discoverable nodes if no node is given."
msgstr "This command will list all of the available parameters on a given node, or on all discoverable nodes if no node is given."


#: ../../source/How-To-Guides/Using-ros2-param.rst:16
msgid "To get all of the parameters on a given node:"
msgstr "To get all of the parameters on a given node:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:22
msgid "To get all of the parameters on all nodes in the system (this can take a long time on a complicated network):"
msgstr "To get all of the parameters on all nodes in the system (this can take a long time on a complicated network):"


#: ../../source/How-To-Guides/Using-ros2-param.rst:29
msgid "``ros2 param get``"
msgstr "``ros2 param get``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:31
msgid "This command will get the value of a particular parameter on a particular node."
msgstr "This command will get the value of a particular parameter on a particular node."


#: ../../source/How-To-Guides/Using-ros2-param.rst:33
msgid "To get the value of a parameter on a node:"
msgstr "To get the value of a parameter on a node:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:40
msgid "``ros2 param set``"
msgstr "``ros2 param set``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:42
msgid "This command will set the value of a particular parameter on a particular node. For most parameters, the type of the new value must be the same as the existing type."
msgstr "This command will set the value of a particular parameter on a particular node. For most parameters, the type of the new value must be the same as the existing type."


#: ../../source/How-To-Guides/Using-ros2-param.rst:45
msgid "To set the value of a parameter on a node:"
msgstr "To set the value of a parameter on a node:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:51
msgid "The value that is passed on the command-line is in YAML, which allows arbitrary YAML expressions to be used. However, it also means that certain expressions will be interpreted differently than might be expected. For instance, if the parameter ``my_string`` on node ``my_node`` is of type string, the following will not work:"
msgstr "The value that is passed on the command-line is in YAML, which allows arbitrary YAML expressions to be used. However, it also means that certain expressions will be interpreted differently than might be expected. For instance, if the parameter ``my_string`` on node ``my_node`` is of type string, the following will not work:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:59
msgid "That's because YAML is interpreting \"off\" as a boolean, and ``my_string`` is a string type. This can be worked around by using the YAML syntax for explicitly setting strings, e.g.:"
msgstr "That's because YAML is interpreting \"off\" as a boolean, and ``my_string`` is a string type. This can be worked around by using the YAML syntax for explicitly setting strings, e.g.:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:66
msgid "Additionally, YAML supports heterogeneous lists, containing (say) a string, a boolean, and an integer. However, ROS 2 parameters do not support heterogenous lists, so any YAML list that has multiple types will be interpreted as a string. Assuming that the parameter ``my_int_array`` on node ``my_node`` is of type integer array, the following will not work:"
msgstr "Additionally, YAML supports heterogeneous lists, containing (say) a string, a boolean, and an integer. However, ROS 2 parameters do not support heterogenous lists, so any YAML list that has multiple types will be interpreted as a string. Assuming that the parameter ``my_int_array`` on node ``my_node`` is of type integer array, the following will not work:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:74
msgid "The following string typed parameter would work:"
msgstr "The following string typed parameter would work:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:81
msgid "``ros2 param delete``"
msgstr "``ros2 param delete``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:83
msgid "This command will remove a parameter from a particular node. However, note that this can only remove dynamic parameters (not declared parameters). See :doc:`the concept document <../Concepts/About-ROS-2-Parameters>` for more information."
msgstr "This command will remove a parameter from a particular node. However, note that this can only remove dynamic parameters (not declared parameters). See :doc:`the concept document <../Concepts/About-ROS-2-Parameters>` for more information."


#: ../../source/How-To-Guides/Using-ros2-param.rst:92
msgid "``ros2 param describe``"
msgstr "``ros2 param describe``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:94
msgid "This command will provide a textual description of a particular parameter on a particular node:"
msgstr "This command will provide a textual description of a particular parameter on a particular node:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:101
msgid "``ros2 param dump``"
msgstr "``ros2 param dump``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:103
msgid "This command will print out all of the parameters on a particular node in a YAML file format. The output of this command can then be used to re-run the node with the same parameters later:"
msgstr "This command will print out all of the parameters on a particular node in a YAML file format. The output of this command can then be used to re-run the node with the same parameters later:"


#: ../../source/How-To-Guides/Using-ros2-param.rst:111
msgid "``ros2 param load``"
msgstr "``ros2 param load``"


#: ../../source/How-To-Guides/Using-ros2-param.rst:113
msgid "This command will load the values of the parameters from a YAML file into a particular node. That is, this command can reload values at runtime that were dumped out by ``ros2 param dump``:"
msgstr "This command will load the values of the parameters from a YAML file into a particular node. That is, this command can reload values at runtime that were dumped out by ``ros2 param dump``:"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:2
msgid "Visualizing ROS 2 data with Foxglove Studio"
msgstr "Visualizing ROS 2 data with Foxglove Studio"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:4
msgid "`Foxglove Studio <https://foxglove.dev/studio>`__ is an open source visualization and debugging tool for your robotics data."
msgstr "`Foxglove Studio <https://foxglove.dev/studio>`__ is an open source visualization and debugging tool for your robotics data."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:6
msgid "It is available in a variety of ways to make development as convenient as possible – it can be run as a standalone desktop app, accessed via your browser, or even self-hosted on your own domain."
msgstr "It is available in a variety of ways to make development as convenient as possible – it can be run as a standalone desktop app, accessed via your browser, or even self-hosted on your own domain."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:8
msgid "View the source code on `GitHub <https://www.github.com/foxglove/studio>`__."
msgstr "View the source code on `GitHub <https://www.github.com/foxglove/studio>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:11
msgid "Installation"
msgstr "Installation"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:13
msgid "To use the web app, simply open Google Chrome and navigate to `studio.foxglove.dev <https://studio.foxglove.dev>`__."
msgstr "To use the web app, simply open Google Chrome and navigate to `studio.foxglove.dev <https://studio.foxglove.dev>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:15
msgid "To use the desktop app for Linux, macOS, or Windows, download it directly from the `Foxglove Studio website <https://foxglove.dev/download>`__."
msgstr "To use the desktop app for Linux, macOS, or Windows, download it directly from the `Foxglove Studio website <https://foxglove.dev/download>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:18
msgid "Connect to a data source"
msgstr "Connect to a data source"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:20
msgid "On opening Foxglove Studio, you will see a dialog with a list of `all possible data sources <https://foxglove.dev/docs/studio/connection/data-sources>`__."
msgstr "On opening Foxglove Studio, you will see a dialog with a list of `all possible data sources <https://foxglove.dev/docs/studio/connection/data-sources>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:22
msgid "To connect to your ROS 2 stack, click \"Open connection\", select the \"Rosbridge (ROS 1 & 2)\" tab, and configure your \"WebSocket URL\"."
msgstr "To connect to your ROS 2 stack, click \"Open connection\", select the \"Rosbridge (ROS 1 & 2)\" tab, and configure your \"WebSocket URL\"."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:24
msgid "You could also drag-and-drop any local ROS 2 ``.db3`` files directly into the application to load them for playback."
msgstr "You could also drag-and-drop any local ROS 2 ``.db3`` files directly into the application to load them for playback."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:28
msgid "In order to `load custom message definitions in your ROS 2 files <https://github.com/ros2/rosbag2/issues/782>`__, try converting them to the `MCAP file format <https://mcap.dev>`__."
msgstr "In order to `load custom message definitions in your ROS 2 files <https://github.com/ros2/rosbag2/issues/782>`__, try converting them to the `MCAP file format <https://mcap.dev>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:30
msgid "Check out the `Foxglove Studio docs <https://foxglove.dev/docs/studio/connection/native>`__ for more detailed instructions."
msgstr "Check out the `Foxglove Studio docs <https://foxglove.dev/docs/studio/connection/native>`__ for more detailed instructions."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:33
msgid "Building layouts with panels"
msgstr "Building layouts with panels"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:35
msgid "`Panels <https://foxglove.dev/docs/studio/panels/introduction>`__ are modular visualization interfaces that can be configured and arranged into Studio `layouts <https://foxglove.dev/docs/studio/layouts>`__. You can also save your layouts for future use, for your own personal reference or with your larger robotics team."
msgstr "`Panels <https://foxglove.dev/docs/studio/panels/introduction>`__ are modular visualization interfaces that can be configured and arranged into Studio `layouts <https://foxglove.dev/docs/studio/layouts>`__. You can also save your layouts for future use, for your own personal reference or with your larger robotics team."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:38
msgid "Find the full list of available panels in the sidebar's \"Add panel\" tab."
msgstr "Find the full list of available panels in the sidebar's \"Add panel\" tab."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:40
msgid "We've highlighted some particularly useful ones below:"
msgstr "We've highlighted some particularly useful ones below:"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:43
msgid "1 3D: Display visualization markers in a 3D scene"
msgstr "1 3D: Display visualization markers in a 3D scene"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:45
msgid "Publish marker messages to add primitive shapes (arrows, spheres, etc.) and more complex visualizations (occupancy grids, point clouds, etc.) to your 3D panel's scene."
msgstr "Publish marker messages to add primitive shapes (arrows, spheres, etc.) and more complex visualizations (occupancy grids, point clouds, etc.) to your 3D panel's scene."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:47
msgid "Choose the topics you want to display via the topic picker on the left, and configure each topic's visualization settings in the \"Edit topic settings\" menu."
msgstr "Choose the topics you want to display via the topic picker on the left, and configure each topic's visualization settings in the \"Edit topic settings\" menu."


msgid "Foxglove Studio's 3D panel"
msgstr "Foxglove Studio's 3D panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:53
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/3d>`__ for a full list of `supported message types <https://foxglove.dev/docs/studio/panels/3d#supported-messages>`__ and some useful `user interactions <https://foxglove.dev/docs/studio/panels/3d#user-interactions>`__."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/3d>`__ for a full list of `supported message types <https://foxglove.dev/docs/studio/panels/3d#supported-messages>`__ and some useful `user interactions <https://foxglove.dev/docs/studio/panels/3d#user-interactions>`__."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:56
msgid "2 Diagnostics: Filter and sort diagnostics messages"
msgstr "2 Diagnostics: Filter and sort diagnostics messages"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:58
msgid "Display the status of seen nodes (i.e. stale, error, warn, or OK) from topics with a ``diagnostic_msgs/msg/DiagnosticArray`` datatype in a running feed, and display the diagnostics data for a given ``diagnostic_name/hardware_id``."
msgstr "Display the status of seen nodes (i.e. stale, error, warn, or OK) from topics with a ``diagnostic_msgs/msg/DiagnosticArray`` datatype in a running feed, and display the diagnostics data for a given ``diagnostic_name/hardware_id``."


msgid "Foxglove Studio's Diagnostics panel"
msgstr "Foxglove Studio's Diagnostics panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:64
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/diagnostics>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/diagnostics>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:67
msgid "3 Image: View camera feed images"
msgstr "3 Image: View camera feed images"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:69
msgid "Select a ``sensor_msgs/msg/Image`` or ``sensor_msgs/msg/CompressedImage`` topic to display."
msgstr "Select a ``sensor_msgs/msg/Image`` or ``sensor_msgs/msg/CompressedImage`` topic to display."


msgid "Foxglove Studio's Image panel"
msgstr "Foxglove Studio's Image panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:75
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/image>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/image>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:78
msgid "4 Log: View log messages"
msgstr "4 Log: View log messages"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:80
msgid "To view ``rcl_interfaces/msg/Log`` messages live, use the desktop app to `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. To view ``rcl_interfaces/msg/Log`` messages from a pre-recorded data file, you can drag-and-drop your file into either the `web <https://studio.foxglove.dev>`__ or desktop app."
msgstr "To view ``rcl_interfaces/msg/Log`` messages live, use the desktop app to `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. To view ``rcl_interfaces/msg/Log`` messages from a pre-recorded data file, you can drag-and-drop your file into either the `web <https://studio.foxglove.dev>`__ or desktop app."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:83
msgid "Next, add a `Log <https://foxglove.dev/docs/studio/panels/log>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a list of your log messages, with the ability to filter them by node name or severity level."
msgstr "Next, add a `Log <https://foxglove.dev/docs/studio/panels/log>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a list of your log messages, with the ability to filter them by node name or severity level."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:86
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/log>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/log>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:89
msgid "5 Plot: Plot arbitrary values over time"
msgstr "5 Plot: Plot arbitrary values over time"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:91
msgid "Plot arbitrary values from your topics' message paths over playback time."
msgstr "Plot arbitrary values from your topics' message paths over playback time."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:93
msgid "Specify the topic values you want to plot along the y-axis. For the x-axis, choose between plotting the y-axis value's timestamp, element index, or another custom topic message path."
msgstr "Specify the topic values you want to plot along the y-axis. For the x-axis, choose between plotting the y-axis value's timestamp, element index, or another custom topic message path."


msgid "Foxglove Studio's Plot panel"
msgstr "Foxglove Studio's Plot panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:100
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/plot>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/plot>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:103
msgid "6 Raw Messages: View incoming topic messages"
msgstr "6 Raw Messages: View incoming topic messages"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:105
msgid "Display incoming topic data in an easy-to-read collapsible JSON tree format."
msgstr "Display incoming topic data in an easy-to-read collapsible JSON tree format."


msgid "Foxglove Studio's Raw Messages panel"
msgstr "Foxglove Studio's Raw Messages panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:111
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/raw-messages>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/raw-messages>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:114
msgid "7 Teleop: Teleoperate your robot"
msgstr "7 Teleop: Teleoperate your robot"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:116
msgid "Teleoperate your physical robot by publishing ``geometry_msgs/msg/Twist`` messages on a given topic back to your live ROS stack."
msgstr "Teleoperate your physical robot by publishing ``geometry_msgs/msg/Twist`` messages on a given topic back to your live ROS stack."


msgid "Foxglove Studio's URDF Viewer panel"
msgstr "Foxglove Studio's URDF Viewer panel"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:122
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/teleop>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/teleop>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:125
msgid "8 URDF Viewer: View and manipulate your URDF model"
msgstr "8 URDF Viewer: View and manipulate your URDF model"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:127
msgid "To visualize and control your robot model in Foxglove Studio, open the web or desktop application and add a `URDF Viewer <https://foxglove.dev/docs/studio/panels/urdf-viewer>`__ panel to your layout. Then, drag and drop your URDF file into that panel to visualize your robot model."
msgstr "To visualize and control your robot model in Foxglove Studio, open the web or desktop application and add a `URDF Viewer <https://foxglove.dev/docs/studio/panels/urdf-viewer>`__ panel to your layout. Then, drag and drop your URDF file into that panel to visualize your robot model."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:134
msgid "Select any topic publishing a ``JointState`` message to update the visualization based on the published joint states (defaults to ``/joint_states``)."
msgstr "Select any topic publishing a ``JointState`` message to update the visualization based on the published joint states (defaults to ``/joint_states``)."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:136
msgid "Toggle to \"Manual joint control\" to set joint positions using the provided controls."
msgstr "Toggle to \"Manual joint control\" to set joint positions using the provided controls."


msgid "Foxglove Studio's URDF Viewer panel with editable joint positions"
msgstr "Foxglove Studio's URDF Viewer panel with editable joint positions"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:142
msgid "Reference the `docs <https://foxglove.dev/docs/studio/panels/urdf-viewer>`__ for more details."
msgstr "Reference the `docs <https://foxglove.dev/docs/studio/panels/urdf-viewer>`__ for more details."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:145
msgid "Other basic actions"
msgstr "Other basic actions"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:148
msgid "1 View your ROS graph"
msgstr "1 View your ROS graph"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:150
msgid "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Topic Graph <https://foxglove.dev/docs/studio/panels/topic-graph>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a computational graph of your ROS nodes, topics, and services in that panel. Use the controls on the right side of the panel to select which topics to display or to toggle services."
msgstr "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Topic Graph <https://foxglove.dev/docs/studio/panels/topic-graph>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a computational graph of your ROS nodes, topics, and services in that panel. Use the controls on the right side of the panel to select which topics to display or to toggle services."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:156
msgid "2 View and edit your ROS params"
msgstr "2 View and edit your ROS params"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:158
msgid "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Parameters <https://foxglove.dev/docs/studio/panels/parameters>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a live view of your current ``rosparams``. You can edit these parameter values to publish ``rosparam`` updates back to your ROS stack."
msgstr "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Parameters <https://foxglove.dev/docs/studio/panels/parameters>`__ panel to your layout. If you've connected to your ROS stack correctly, you should now see a live view of your current ``rosparams``. You can edit these parameter values to publish ``rosparam`` updates back to your ROS stack."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:164
msgid "3 Publish messages back to your live ROS stack"
msgstr "3 Publish messages back to your live ROS stack"


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:166
msgid "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Publish <https://foxglove.dev/docs/studio/panels/publish>`__ panel to your layout."
msgstr "`Using the desktop app <https://foxglove.dev/download>`__, `connect <https://foxglove.dev/docs/studio/connection/native>`__ to your running ROS stack. Next, add a `Publish <https://foxglove.dev/docs/studio/panels/publish>`__ panel to your layout."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:169
msgid "Specify the topic you want to publish on to infer its datatype and populate the text field with a JSON message template."
msgstr "Specify the topic you want to publish on to infer its datatype and populate the text field with a JSON message template."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:171
msgid "Selecting a datatype in the dropdown of common ROS datatypes will also populate the text field with a JSON message template."
msgstr "Selecting a datatype in the dropdown of common ROS datatypes will also populate the text field with a JSON message template."


#: ../../source/How-To-Guides/Visualizing-ROS-2-Data-With-Foxglove-Studio.rst:173
msgid "Edit the template to customize your message before hitting \"Publish\"."
msgstr "Edit the template to customize your message before hitting \"Publish\"."


msgid "Foxglove Studio's Publish panel"
msgstr "Foxglove Studio's Publish panel"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:8
msgid "Working with multiple ROS 2 middleware implementations"
msgstr "Working with multiple ROS 2 middleware implementations"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:14
msgid "This page explains the default RMW implementation and how to specify an alternative."
msgstr "This page explains the default RMW implementation and how to specify an alternative."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:19
msgid "You should have already read the :doc:`DDS and ROS middleware implementations page <../Concepts/About-Different-Middleware-Vendors>`."
msgstr "You should have already read the :doc:`DDS and ROS middleware implementations page <../Concepts/About-Different-Middleware-Vendors>`."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:22
msgid "Specifying RMW implementations"
msgstr "Specifying RMW implementations"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:24
msgid "To have multiple RMW implementations available for use you must have installed the ROS 2 binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (the RMW implementations are included in the build by default if their compile-time dependencies are met). See :doc:`Install DDS implementations <../Installation/DDS-Implementations>`."
msgstr "To have multiple RMW implementations available for use you must have installed the ROS 2 binaries and any additional dependencies for specific RMW implementations, or built ROS 2 from source with multiple RMW implementations in the workspace (the RMW implementations are included in the build by default if their compile-time dependencies are met). See :doc:`Install DDS implementations <../Installation/DDS-Implementations>`."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:28
msgid "Both C++ and Python nodes support an environment variable ``RMW_IMPLEMENTATION`` that allows the user to select the RMW implementation to use when running ROS 2 applications."
msgstr "Both C++ and Python nodes support an environment variable ``RMW_IMPLEMENTATION`` that allows the user to select the RMW implementation to use when running ROS 2 applications."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:30
msgid "The user may set this variable to a specific implementation identifier, such as ``rmw_cyclonedds_cpp``, ``rmw_fastrtps_cpp``, ``rmw_connextdds``, or ``rmw_gurumdds_cpp``."
msgstr "The user may set this variable to a specific implementation identifier, such as ``rmw_cyclonedds_cpp``, ``rmw_fastrtps_cpp``, ``rmw_connextdds``, or ``rmw_gurumdds_cpp``."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:32
msgid "For example, to run the talker demo using the C++ talker and Python listener with the Connext RMW implementation:"
msgstr "For example, to run the talker demo using the C++ talker and Python listener with the Connext RMW implementation:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:66
msgid "Adding RMW implementations to your workspace"
msgstr "Adding RMW implementations to your workspace"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:68
msgid "Suppose that you have built your ROS 2 workspace with only Fast DDS installed and therefore only the Fast DDS RMW implementation built. The last time your workspace was built, any other RMW implementation packages, ``rmw_connextdds`` for example, were probably unable to find installations of the relevant DDS implementations. If you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built. You can do this by specifying the ``--cmake-clean-cache`` flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation."
msgstr "Suppose that you have built your ROS 2 workspace with only Fast DDS installed and therefore only the Fast DDS RMW implementation built. The last time your workspace was built, any other RMW implementation packages, ``rmw_connextdds`` for example, were probably unable to find installations of the relevant DDS implementations. If you then install an additional DDS implementation, Connext for example, you will need to re-trigger the check for a Connext installation that occurs when the Connext RMW implementation is being built. You can do this by specifying the ``--cmake-clean-cache`` flag on your next workspace build, and you should see that the RMW implementation package then gets built for the newly installed DDS implementation."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:73
msgid "It is possible to run into a problem when \"rebuilding\" the workspace with an additional RMW implementation using the ``--cmake-clean-cache`` option where the build complains about the default RMW implementation changing. To resolve this, you can either set the default implementation to what is was before with the ``RMW_IMPLEMENTATION`` CMake argument or you can delete the build folder for packages that complain and continue the build with ``--packages-start <package name>``."
msgstr "It is possible to run into a problem when \"rebuilding\" the workspace with an additional RMW implementation using the ``--cmake-clean-cache`` option where the build complains about the default RMW implementation changing. To resolve this, you can either set the default implementation to what is was before with the ``RMW_IMPLEMENTATION`` CMake argument or you can delete the build folder for packages that complain and continue the build with ``--packages-start <package name>``."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:77
msgid "Troubleshooting"
msgstr "Troubleshooting"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:80
msgid "Checking the Current RMW"
msgstr "Checking the Current RMW"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:82
msgid "To check the RMW that is currently in use you simply check the ``RMW_IMPLEMENTATION`` environment variable. On Linux systems ``printenv`` prints the full list of environment variables. Other operating systems will have other procedures for viewing environment variables. If ``RMW_IMPLEMENTATION`` is not in the environment it is safe to assume you are using the default for your ROS distro, otherwise the current RMW is the value listed. The default RMW for each ROS Distro can be found in `REP-2000 <https://www.ros.org/reps/rep-2000.html#platforms-by-distribution>`_."
msgstr "To check the RMW that is currently in use you simply check the ``RMW_IMPLEMENTATION`` environment variable. On Linux systems ``printenv`` prints the full list of environment variables. Other operating systems will have other procedures for viewing environment variables. If ``RMW_IMPLEMENTATION`` is not in the environment it is safe to assume you are using the default for your ROS distro, otherwise the current RMW is the value listed. The default RMW for each ROS Distro can be found in `REP-2000 <https://www.ros.org/reps/rep-2000.html#platforms-by-distribution>`_."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:88
msgid "Ensuring use of a particular RMW implementation"
msgstr "Ensuring use of a particular RMW implementation"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:90
msgid "If the ``RMW_IMPLEMENTATION`` environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:"
msgstr "If the ``RMW_IMPLEMENTATION`` environment variable is set to an RMW implementation for which support is not installed, you will see an error message similar to the following if you have only one implementation installed:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:96
msgid "If you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:"
msgstr "If you have support for multiple RMW implementations installed and you request use of one that is not installed, you will see something similar to:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:102
msgid "If this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the ``RMW_IMPLEMENTATION`` environment variable."
msgstr "If this occurs, double check that your ROS 2 installation includes support for the RMW implementation that you have specified in the ``RMW_IMPLEMENTATION`` environment variable."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:104
msgid "If you want to switch between RMW implementations, verify that the ROS 2 daemon process is not running with the previous RMW implementation to avoid any issues between nodes and command line tools such as ``ros2 node``. For example, if you run:"
msgstr "If you want to switch between RMW implementations, verify that the ROS 2 daemon process is not running with the previous RMW implementation to avoid any issues between nodes and command line tools such as ``ros2 node``. For example, if you run:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:111
msgid "and"
msgstr "and"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:117
msgid "it will generate a daemon with a Fast DDS implementation:"
msgstr "it will generate a daemon with a Fast DDS implementation:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:123
msgid "Even if you run the command line tool again with the correct RMW implementation, the daemon's RMW implementation will not change and the ROS 2 command line tools will fail."
msgstr "Even if you run the command line tool again with the correct RMW implementation, the daemon's RMW implementation will not change and the ROS 2 command line tools will fail."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:125
msgid "To solve this, simply stop the daemon process:"
msgstr "To solve this, simply stop the daemon process:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:131
msgid "and rerun the ROS 2 command line tool with the correct RMW implementation."
msgstr "and rerun the ROS 2 command line tool with the correct RMW implementation."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:134
msgid "RTI Connext on OSX: Failure due to insufficient shared memory kernel settings"
msgstr "RTI Connext on OSX: Failure due to insufficient shared memory kernel settings"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:136
msgid "If you receive an error message similar to below when running RTI Connext on OSX:"
msgstr "If you receive an error message similar to below when running RTI Connext on OSX:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:143
msgid "This error is caused by an insufficient number or size of shared memory segments allowed by the operating system. As a result, the ``DomainParticipant`` is unable to allocate enough resources and calculate its participant index which causes the error."
msgstr "This error is caused by an insufficient number or size of shared memory segments allowed by the operating system. As a result, the ``DomainParticipant`` is unable to allocate enough resources and calculate its participant index which causes the error."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:145
msgid "You can increase the shared memory resources of your machine either temporarily or permanently."
msgstr "You can increase the shared memory resources of your machine either temporarily or permanently."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:147
msgid "To increase the settings temporarily, you can run the following commands as user root:"
msgstr "To increase the settings temporarily, you can run the following commands as user root:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:157
msgid "To increase the settings permanently, you will need to edit or create the file ``/etc/sysctl.conf``. Creating or editing this file will require root permissions. Either add to your existing ``etc/sysctl.conf`` file or create ``/etc/sysctl.conf`` with the following lines:"
msgstr "To increase the settings permanently, you will need to edit or create the file ``/etc/sysctl.conf``. Creating or editing this file will require root permissions. Either add to your existing ``etc/sysctl.conf`` file or create ``/etc/sysctl.conf`` with the following lines:"


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:167
msgid "You will need to reboot the machine after modifying this file to have the changes take effect."
msgstr "You will need to reboot the machine after modifying this file to have the changes take effect."


#: ../../source/How-To-Guides/Working-with-multiple-RMW-implementations.rst:169
msgid "This solution is edited from the RTI Connext community forum. See the `original post <https://community.rti.com/kb/osx510>`__ for more detailed explanation."
msgstr "This solution is edited from the RTI Connext community forum. See the `original post <https://community.rti.com/kb/osx510>`__ for more detailed explanation."

