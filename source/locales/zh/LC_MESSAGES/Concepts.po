# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 Documentation: Humble package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 Documentation: Humble \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-15 19:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"


#: ../../source/Concepts.rst:4
msgid "Concepts"
msgstr "Concepts"


#: ../../source/Concepts.rst:6
msgid "Conceptual overviews provide relatively high-level, general background information about key aspects of ROS 2."
msgstr "Conceptual overviews provide relatively high-level, general background information about key aspects of ROS 2."


#: ../../source/Concepts.rst:29
msgid "The Core Stack Developer Concepts are much more detailed conceptual articles intended for developers who plan modify or contribute to the ROS 2 core:"
msgstr "The Core Stack Developer Concepts are much more detailed conceptual articles intended for developers who plan modify or contribute to the ROS 2 core:"


#: ../../source/Concepts.rst:40
msgid "Quick overview of ROS 2 Concepts"
msgstr "Quick overview of ROS 2 Concepts"


#: ../../source/Concepts.rst:45
msgid "ROS 2 is a middleware based on an anonymous publish/subscribe mechanism that allows for message passing between different ROS processes."
msgstr "ROS 2 is a middleware based on an anonymous publish/subscribe mechanism that allows for message passing between different ROS processes."


#: ../../source/Concepts.rst:47
msgid "At the heart of any ROS 2 system is the ROS graph. The ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate."
msgstr "At the heart of any ROS 2 system is the ROS graph. The ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate."


#: ../../source/Concepts.rst:51
msgid "Graph Concepts"
msgstr "Graph Concepts"


#: ../../source/Concepts.rst:54
msgid "Nodes: A node is an entity that uses ROS to communicate with other nodes."
msgstr "Nodes: A node is an entity that uses ROS to communicate with other nodes."


#: ../../source/Concepts.rst:55
msgid "Messages: ROS data type used when subscribing or publishing to a topic."
msgstr "Messages: ROS data type used when subscribing or publishing to a topic."


#: ../../source/Concepts.rst:56
msgid "Topics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages."
msgstr "Topics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages."


#: ../../source/Concepts.rst:57
msgid "Discovery: The automatic process through which nodes determine how to talk to each other."
msgstr "Discovery: The automatic process through which nodes determine how to talk to each other."


#: ../../source/Concepts.rst:60
msgid "Nodes"
msgstr "Nodes"


#: ../../source/Concepts.rst:62
msgid "A node is a participant in the ROS graph. ROS nodes use a ROS client library to communicate with other nodes. Nodes can publish or subscribe to Topics. Nodes can also provide or use Services and Actions. There are configurable Parameters associated with a node. Connections between nodes are established through a distributed discovery process. Nodes may be located in the same process, in different processes, or on different machines. These concepts will be described in more detail in the sections that follow."
msgstr "A node is a participant in the ROS graph. ROS nodes use a ROS client library to communicate with other nodes. Nodes can publish or subscribe to Topics. Nodes can also provide or use Services and Actions. There are configurable Parameters associated with a node. Connections between nodes are established through a distributed discovery process. Nodes may be located in the same process, in different processes, or on different machines. These concepts will be described in more detail in the sections that follow."


#: ../../source/Concepts.rst:72
msgid "Client Libraries"
msgstr "客户端库"


#: ../../source/Concepts.rst:74
msgid "ROS client libraries allow nodes written in different programming languages to communicate. There is a core ROS client library (RCL) that implements common functionality needed for the ROS APIs of different languages. This makes it so that language-specific client libraries are easier to write and that they have more consistent behavior."
msgstr "ROS client libraries allow nodes written in different programming languages to communicate. There is a core ROS client library (RCL) that implements common functionality needed for the ROS APIs of different languages. This makes it so that language-specific client libraries are easier to write and that they have more consistent behavior."


#: ../../source/Concepts.rst:78
msgid "The following client libraries are maintained by the ROS 2 team:"
msgstr "The following client libraries are maintained by the ROS 2 team:"


#: ../../source/Concepts.rst:81
msgid "rclcpp = C++ client library"
msgstr "rclcpp = C++ client library"


#: ../../source/Concepts.rst:82
msgid "rclpy = Python client library"
msgstr "rclpy = Python client library"


#: ../../source/Concepts.rst:84
msgid "Additionally, other client libraries have been developed by the ROS community. See the :doc:`ROS 2 Client Libraries <Concepts/About-ROS-2-Client-Libraries>` article for more details."
msgstr "Additionally, other client libraries have been developed by the ROS community. See the :doc:`ROS 2 Client Libraries <Concepts/About-ROS-2-Client-Libraries>` article for more details."


#: ../../source/Concepts.rst:88
msgid "Discovery"
msgstr "Discovery"


#: ../../source/Concepts.rst:90
msgid "Discovery of nodes happens automatically through the underlying middleware of ROS 2. It can be summarized as follows:"
msgstr "Discovery of nodes happens automatically through the underlying middleware of ROS 2. It can be summarized as follows:"


#: ../../source/Concepts.rst:93
msgid "When a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable). Nodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate."
msgstr "When a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable). Nodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate."


#: ../../source/Concepts.rst:95
msgid "Nodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period."
msgstr "Nodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period."


#: ../../source/Concepts.rst:96
msgid "Nodes advertise to other nodes when they go offline."
msgstr "Nodes advertise to other nodes when they go offline."


#: ../../source/Concepts.rst:98
msgid "Nodes will only establish connections with other nodes if they have compatible :doc:`Quality of Service <../Tutorials/Demos/Quality-of-Service>` settings."
msgstr "Nodes will only establish connections with other nodes if they have compatible :doc:`Quality of Service <../Tutorials/Demos/Quality-of-Service>` settings."


#: ../../source/Concepts.rst:100
msgid "Take the :ref:`talker-listener demo <talker-listener>` for example. Running the C++ talker node in one terminal will publish messages on a topic, and the Python listener node running in another terminal  will subscribe to messages on the same topic."
msgstr "Take the :ref:`talker-listener demo <talker-listener>` for example. Running the C++ talker node in one terminal will publish messages on a topic, and the Python listener node running in another terminal  will subscribe to messages on the same topic."


#: ../../source/Concepts.rst:104
msgid "You should see that these nodes discover each other automatically, and begin to exchange messages."
msgstr "You should see that these nodes discover each other automatically, and begin to exchange messages."


#: ../../source/Concepts.rst:107
msgid "Security"
msgstr "安全性"


#: ../../source/Concepts.rst:109
msgid "ROS 2 includes the ability to secure communications among nodes within the ROS 2 computational graph. Similar to discovery, security happens through the underlying ROS 2 middleware (provided it has support for the corresponding security plugins). No additional software installation is needed to enable security; however, the middleware requires configuration files for each ROS graph participant. These files enable encryption and authentication, and define policies both for individual nodes and for the overall ROS graph. ROS 2 also adds a master \"on/off\" switch to control security behavior."
msgstr "ROS 2 includes the ability to secure communications among nodes within the ROS 2 computational graph. Similar to discovery, security happens through the underlying ROS 2 middleware (provided it has support for the corresponding security plugins). No additional software installation is needed to enable security; however, the middleware requires configuration files for each ROS graph participant. These files enable encryption and authentication, and define policies both for individual nodes and for the overall ROS graph. ROS 2 also adds a master \"on/off\" switch to control security behavior."


#: ../../source/Concepts.rst:115
msgid "ROS utilities can create the authoritative `trust anchor <https://en.wikipedia.org/wiki/Trust_anchor>`_ for a ROS application, or an external certificate authority can be used."
msgstr "ROS utilities can create the authoritative `trust anchor <https://en.wikipedia.org/wiki/Trust_anchor>`_ for a ROS application, or an external certificate authority can be used."


#: ../../source/Concepts.rst:117
msgid "See the :doc:`ROS 2 Security <Concepts/About-Security>` article for additional details or ROS security features."
msgstr "See the :doc:`ROS 2 Security <Concepts/About-Security>` article for additional details or ROS security features."


#: ../../source/Concepts.rst:121
msgid "Related Content"
msgstr "Related Content"


#: ../../source/Concepts.rst:123
msgid ":doc:`See the ROS 2 citations <Citations>` for more explanation of concepts and citable resources."
msgstr ":doc:`See the ROS 2 citations <Citations>` for more explanation of concepts and citable resources."


#: ../../source/Concepts.rst:125
msgid "For a brief video introduction to ROS 2, see this community contributed content:"
msgstr "For a brief video introduction to ROS 2, see this community contributed content:"


#: ../../source/Concepts.rst:127
msgid "`Getting started with ROS Part 1: Nodes, Parameters and Topics <https://youtu.be/46TPAKXBOF8>`_"
msgstr "`Getting started with ROS Part 1: Nodes, Parameters and Topics <https://youtu.be/46TPAKXBOF8>`_"


#: ../../source/Concepts.rst:128
msgid "`Getting started with ROS Part 2: Services and Actions <https://youtu.be/keZAJ83eEoM>`_"
msgstr "`Getting started with ROS Part 2: Services and Actions <https://youtu.be/keZAJ83eEoM>`_"


#: ../../source/Concepts/About-Build-System.rst:2
msgid "About the build system"
msgstr "About the build system"


#: ../../source/Concepts/About-Build-System.rst:6
msgid "Under everything is the build system. Iterating on ``catkin`` from ROS 1, we have created a set of |packages| under the moniker ``ament``. Some of the reasons for changing the name to ``ament`` are that we wanted it to not collide with ``catkin`` (in case we want to mix them at some point) and to prevent confusion with existing ``catkin`` documentation. ``ament``'s primary responsibility is to make it easier to develop and maintain ROS 2 core |packages|. However, this responsibility extends to any user who is willing to make use of our build system conventions and tools. Additionally it should make |packages| conventional, such that developers should be able to pick up any ``ament`` based |package| and make some assumptions about how it works, how to introspect it, and how to build or use it."
msgstr "Under everything is the build system. Iterating on ``catkin`` from ROS 1, we have created a set of |packages| under the moniker ``ament``. Some of the reasons for changing the name to ``ament`` are that we wanted it to not collide with ``catkin`` (in case we want to mix them at some point) and to prevent confusion with existing ``catkin`` documentation. ``ament``'s primary responsibility is to make it easier to develop and maintain ROS 2 core |packages|. However, this responsibility extends to any user who is willing to make use of our build system conventions and tools. Additionally it should make |packages| conventional, such that developers should be able to pick up any ``ament`` based |package| and make some assumptions about how it works, how to introspect it, and how to build or use it."


#: ../../source/Concepts/About-Build-System.rst:13
msgid "``ament`` consists of a few important repositories which are all in the ``ament`` `GitHub organization <https://github.com/ament>`_:"
msgstr "``ament`` consists of a few important repositories which are all in the ``ament`` `GitHub organization <https://github.com/ament>`_:"


#: ../../source/Concepts/About-Build-System.rst:20
msgid "The ``ament_package`` Package"
msgstr "The ``ament_package`` Package"


#: ../../source/Concepts/About-Build-System.rst:22
msgid "Located on |GitHub|_ at `ament/ament_package <https://github.com/ament/ament_package>`_, this repository contains a single :term:`ament Python package` that provides various utilities for |ament packages|, e.g. templates for environment hooks."
msgstr "Located on |GitHub|_ at `ament/ament_package <https://github.com/ament/ament_package>`_, this repository contains a single :term:`ament Python package` that provides various utilities for |ament packages|, e.g. templates for environment hooks."


#: ../../source/Concepts/About-Build-System.rst:24
msgid "All |ament packages| must contain a single :term:`package.xml` file at the root of the package regardless of their underlying build system. The :term:`package.xml` \"manifest\" file contains information that is required in order to process and operate on a |package|. This |package| information includes things like the |package|'s name, which is globally unique, and the package's dependencies. The :term:`package.xml` file also serves as the marker file which indicates the location of the |package| on the file system."
msgstr "All |ament packages| must contain a single :term:`package.xml` file at the root of the package regardless of their underlying build system. The :term:`package.xml` \"manifest\" file contains information that is required in order to process and operate on a |package|. This |package| information includes things like the |package|'s name, which is globally unique, and the package's dependencies. The :term:`package.xml` file also serves as the marker file which indicates the location of the |package| on the file system."


#: ../../source/Concepts/About-Build-System.rst:29
msgid "Parsing of the :term:`package.xml` files is provided by ``catkin_pkg`` (as in ROS 1), while functionality to locate |packages| by searching the file system for these :term:`package.xml` files is provided by build tools such as ``colcon``."
msgstr "Parsing of the :term:`package.xml` files is provided by ``catkin_pkg`` (as in ROS 1), while functionality to locate |packages| by searching the file system for these :term:`package.xml` files is provided by build tools such as ``colcon``."


#: ../../source/Concepts/About-Build-System.rst:32
msgid "package.xml"
msgstr "package.xml"


#: ../../source/Concepts/About-Build-System.rst:34
msgid "Package manifest file which marks the root of a :term:`package` and contains meta information about the :term:`package` including its name, version, description, maintainer, license, dependencies, and more. The contents of the manifest are in machine readable XML format and the contents are described in the |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ and `140 <http://www.ros.org/reps/rep-0140.html>`_, with the possibility of further modifications in future |REPs|."
msgstr "Package manifest file which marks the root of a :term:`package` and contains meta information about the :term:`package` including its name, version, description, maintainer, license, dependencies, and more. The contents of the manifest are in machine readable XML format and the contents are described in the |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ and `140 <http://www.ros.org/reps/rep-0140.html>`_, with the possibility of further modifications in future |REPs|."


#: ../../source/Concepts/About-Build-System.rst:37
msgid "So anytime some |package| is referred to as an :term:`ament package`, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using a :term:`package.xml` manifest file."
msgstr "So anytime some |package| is referred to as an :term:`ament package`, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using a :term:`package.xml` manifest file."


#: ../../source/Concepts/About-Build-System.rst:40
msgid "ament package"
msgstr "ament package"


#: ../../source/Concepts/About-Build-System.rst:42
msgid "Any |package| which contains a :term:`package.xml` and follows the packaging guidelines of ``ament``, regardless of the underlying build system."
msgstr "Any |package| which contains a :term:`package.xml` and follows the packaging guidelines of ``ament``, regardless of the underlying build system."


#: ../../source/Concepts/About-Build-System.rst:44
msgid "Since the term :term:`ament package` is build system agnostic, there can be different kinds of |ament packages|, e.g. :term:`ament CMake package`, :term:`ament Python package`, etc."
msgstr "Since the term :term:`ament package` is build system agnostic, there can be different kinds of |ament packages|, e.g. :term:`ament CMake package`, :term:`ament Python package`, etc."


#: ../../source/Concepts/About-Build-System.rst:46
msgid "Here is a list of common package types that you might run into in this software stack:"
msgstr "Here is a list of common package types that you might run into in this software stack:"


#: ../../source/Concepts/About-Build-System.rst:49
msgid "CMake package"
msgstr "CMake package"


#: ../../source/Concepts/About-Build-System.rst:51
msgid "Any |package| containing a plain CMake project and a :term:`package.xml` manifest file."
msgstr "Any |package| containing a plain CMake project and a :term:`package.xml` manifest file."


#: ../../source/Concepts/About-Build-System.rst:52
msgid "ament CMake package"
msgstr "ament CMake package"


#: ../../source/Concepts/About-Build-System.rst:54
msgid "A :term:`CMake package` that also follows the ``ament`` packaging guidelines."
msgstr "A :term:`CMake package` that also follows the ``ament`` packaging guidelines."


#: ../../source/Concepts/About-Build-System.rst:55
msgid "Python package"
msgstr "Python package"


#: ../../source/Concepts/About-Build-System.rst:57
msgid "Any |package| containing a `setuptools <https://pypi.org/project/setuptools/>`_ based Python project and a :term:`package.xml` manifest file."
msgstr "Any |package| containing a `setuptools <https://pypi.org/project/setuptools/>`_ based Python project and a :term:`package.xml` manifest file."


#: ../../source/Concepts/About-Build-System.rst:58
msgid "ament Python package"
msgstr "ament Python package"


#: ../../source/Concepts/About-Build-System.rst:60
msgid "A :term:`Python package` that also follows the ``ament`` packaging guidelines."
msgstr "A :term:`Python package` that also follows the ``ament`` packaging guidelines."


#: ../../source/Concepts/About-Build-System.rst:63
msgid "The ``ament_cmake`` Repository"
msgstr "The ``ament_cmake`` Repository"


#: ../../source/Concepts/About-Build-System.rst:65
msgid "Located on |GitHub|_ at `ament/ament_cmake <https://github.com/ament/ament_cmake>`_, this repository contains many \"ament CMake\" and pure CMake packages which provide the infrastructure in CMake that is required to create \"ament CMake\" packages. In this context \"ament CMake\" packages means: ``ament`` packages that are built using CMake. So the |packages| in this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more \"ament CMake\" (or ``ament_cmake``) packages. Packages of this type are identified with the ``<build_type>ament_cmake</build_type>`` tag in the ``<export>`` tag of the :term:`package.xml` file."
msgstr "Located on |GitHub|_ at `ament/ament_cmake <https://github.com/ament/ament_cmake>`_, this repository contains many \"ament CMake\" and pure CMake packages which provide the infrastructure in CMake that is required to create \"ament CMake\" packages. In this context \"ament CMake\" packages means: ``ament`` packages that are built using CMake. So the |packages| in this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more \"ament CMake\" (or ``ament_cmake``) packages. Packages of this type are identified with the ``<build_type>ament_cmake</build_type>`` tag in the ``<export>`` tag of the :term:`package.xml` file."


#: ../../source/Concepts/About-Build-System.rst:70
msgid "The |packages| in this repository are extremely modular, but there is a single \"bottleneck\" |package| called ``ament_cmake``. Anyone can depend on the ``ament_cmake`` |package| to get all of the aggregate functionality of the |packages| in this repository. Here a list of the |packages| in the repository along with a short description:"
msgstr "The |packages| in this repository are extremely modular, but there is a single \"bottleneck\" |package| called ``ament_cmake``. Anyone can depend on the ``ament_cmake`` |package| to get all of the aggregate functionality of the |packages| in this repository. Here a list of the |packages| in the repository along with a short description:"


#: ../../source/Concepts/About-Build-System.rst:74
msgid "``ament_cmake``"
msgstr "``ament_cmake``"


#: ../../source/Concepts/About-Build-System.rst:76
msgid "aggregates all other |packages| in this repository, users need only to depend on this"
msgstr "aggregates all other |packages| in this repository, users need only to depend on this"


#: ../../source/Concepts/About-Build-System.rst:78
msgid "``ament_cmake_auto``"
msgstr "``ament_cmake_auto``"


#: ../../source/Concepts/About-Build-System.rst:80
msgid "provides convenience CMake functions which automatically handle a lot of the tedious parts of writing a |package|'s ``CMakeLists.txt`` file"
msgstr "provides convenience CMake functions which automatically handle a lot of the tedious parts of writing a |package|'s ``CMakeLists.txt`` file"


#: ../../source/Concepts/About-Build-System.rst:82
msgid "``ament_cmake_core``"
msgstr "``ament_cmake_core``"


#: ../../source/Concepts/About-Build-System.rst:84
msgid "provides all built-in core concepts for ``ament``, e.g. environment hooks, resource indexing, symbolic linking install and others"
msgstr "provides all built-in core concepts for ``ament``, e.g. environment hooks, resource indexing, symbolic linking install and others"


#: ../../source/Concepts/About-Build-System.rst:86
msgid "``ament_cmake_gmock``"
msgstr "``ament_cmake_gmock``"


#: ../../source/Concepts/About-Build-System.rst:88
msgid "adds convenience functions for making gmock based unit tests"
msgstr "adds convenience functions for making gmock based unit tests"


#: ../../source/Concepts/About-Build-System.rst:90
msgid "``ament_cmake_gtest``"
msgstr "``ament_cmake_gtest``"


#: ../../source/Concepts/About-Build-System.rst:92
msgid "adds convenience functions for making gtest based automated tests"
msgstr "adds convenience functions for making gtest based automated tests"


#: ../../source/Concepts/About-Build-System.rst:94
msgid "``ament_cmake_nose``"
msgstr "``ament_cmake_nose``"


#: ../../source/Concepts/About-Build-System.rst:96
msgid "adds convenience functions for making nosetests based python automated tests"
msgstr "adds convenience functions for making nosetests based python automated tests"


#: ../../source/Concepts/About-Build-System.rst:98
msgid "``ament_cmake_python``"
msgstr "``ament_cmake_python``"


#: ../../source/Concepts/About-Build-System.rst:100
msgid "provides CMake functions for |packages| that contain Python code"
msgstr "provides CMake functions for |packages| that contain Python code"


#: ../../source/Concepts/About-Build-System.rst:101
msgid "see the :doc:`ament_cmake_python user documentation <../How-To-Guides/Ament-CMake-Python-Documentation>`"
msgstr "see the :doc:`ament_cmake_python user documentation <../How-To-Guides/Ament-CMake-Python-Documentation>`"


#: ../../source/Concepts/About-Build-System.rst:103
msgid "``ament_cmake_test``"
msgstr "``ament_cmake_test``"


#: ../../source/Concepts/About-Build-System.rst:105
msgid "aggregates different kinds of tests, e.g. gtest and nosetests, under a single target using `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_"
msgstr "aggregates different kinds of tests, e.g. gtest and nosetests, under a single target using `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_"


#: ../../source/Concepts/About-Build-System.rst:107
msgid "The ``ament_cmake_core`` |package| contains a lot of the CMake infrastructure that makes it possible to cleanly pass information between |packages| using conventional interfaces. This makes the |packages| have more decoupled build interfaces with other |packages|, promoting their reuse and encouraging conventions in the build systems of different |packages|. For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies between |packages| so that consumers of this information can access this information in a conventional way."
msgstr "The ``ament_cmake_core`` |package| contains a lot of the CMake infrastructure that makes it possible to cleanly pass information between |packages| using conventional interfaces. This makes the |packages| have more decoupled build interfaces with other |packages|, promoting their reuse and encouraging conventions in the build systems of different |packages|. For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies between |packages| so that consumers of this information can access this information in a conventional way."


#: ../../source/Concepts/About-Build-System.rst:111
msgid "The ``ament_cmake_core`` |package| also provides features of the ``ament`` build system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them. This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect. This feature essentially replaces the \"devel space\" from ``catkin`` because it has most of the advantages with few of the complications or drawbacks."
msgstr "The ``ament_cmake_core`` |package| also provides features of the ``ament`` build system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them. This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect. This feature essentially replaces the \"devel space\" from ``catkin`` because it has most of the advantages with few of the complications or drawbacks."


#: ../../source/Concepts/About-Build-System.rst:115
msgid "Another feature provided by ``ament_cmake_core`` is the |package| resource indexing which is a way for |packages| to indicate that they contain a resource of some type. The design of this feature makes it much more efficient to answer simple questions like what |packages| are in this prefix (e.g. ``/usr/local``) because it only requires that you list the files in a single possible location under that prefix. You can read more about this feature in the `design docs <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`_ for the resource index."
msgstr "Another feature provided by ``ament_cmake_core`` is the |package| resource indexing which is a way for |packages| to indicate that they contain a resource of some type. The design of this feature makes it much more efficient to answer simple questions like what |packages| are in this prefix (e.g. ``/usr/local``) because it only requires that you list the files in a single possible location under that prefix. You can read more about this feature in the `design docs <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`_ for the resource index."


#: ../../source/Concepts/About-Build-System.rst:119
msgid "Like ``catkin``, ``ament_cmake_core`` also provides environment setup files and |package| specific environment hooks. The environment setup files, often named something like ``setup.bash``, are a place for |package| developers to define changes to the environment that are needed to utilize their |package|. The developers are able to do this using an \"environment hook\" which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc... This feature is how, for example, ROS 1 set the ``ROS_DISTRO`` environment variable without ``catkin`` knowing anything about the ROS distribution."
msgstr "Like ``catkin``, ``ament_cmake_core`` also provides environment setup files and |package| specific environment hooks. The environment setup files, often named something like ``setup.bash``, are a place for |package| developers to define changes to the environment that are needed to utilize their |package|. The developers are able to do this using an \"environment hook\" which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc... This feature is how, for example, ROS 1 set the ``ROS_DISTRO`` environment variable without ``catkin`` knowing anything about the ROS distribution."


#: ../../source/Concepts/About-Build-System.rst:125
msgid "The ``ament_lint`` Repository"
msgstr "The ``ament_lint`` Repository"


#: ../../source/Concepts/About-Build-System.rst:127
msgid "Located on |GitHub|_ at `ament/ament_lint <https://github.com/ament/ament_lint>`_, this repository provides several |packages| which provide linting and testing services in a convenient and consistent manner. Currently there are |packages| to support C++ style linting using ``uncrustify``, static C++ code checks using ``cppcheck``, checking for copyright in source code, Python style linting using ``pep8``, and other things. The list of helper packages will likely grow in the future."
msgstr "Located on |GitHub|_ at `ament/ament_lint <https://github.com/ament/ament_lint>`_, this repository provides several |packages| which provide linting and testing services in a convenient and consistent manner. Currently there are |packages| to support C++ style linting using ``uncrustify``, static C++ code checks using ``cppcheck``, checking for copyright in source code, Python style linting using ``pep8``, and other things. The list of helper packages will likely grow in the future."


#: ../../source/Concepts/About-Build-System.rst:132
msgid "Build tools"
msgstr "Build tools"


#: ../../source/Concepts/About-Build-System.rst:134
msgid "A build tool performs the task of building a workspace of packages together at once with a single invocation. For ROS 2 releases up to Ardent, the build tool providing this functionality is called ``ament_tools``. As of ROS 2 Bouncy, ``ament_tools`` has been superseded by ``colcon``, as described in `the universal build tool article <http://design.ros2.org/articles/build_tool.html>`_."
msgstr "A build tool performs the task of building a workspace of packages together at once with a single invocation. For ROS 2 releases up to Ardent, the build tool providing this functionality is called ``ament_tools``. As of ROS 2 Bouncy, ``ament_tools`` has been superseded by ``colcon``, as described in `the universal build tool article <http://design.ros2.org/articles/build_tool.html>`_."


#: ../../source/Concepts/About-Catment.rst:6
msgid "On the mixing of ament and catkin (catment)"
msgstr "On the mixing of ament and catkin (catment)"


#: ../../source/Concepts/About-Catment.rst:8
msgid "**All that follows is experimental and speculative.**"
msgstr "**All that follows is experimental and speculative.**"


#: ../../source/Concepts/About-Catment.rst:12 ../../source/Concepts/About-Command-Line-Tools.rst:11 ../../source/Concepts/About-Composition.rst:6 ../../source/Concepts/About-Executors.rst:7 ../../source/Concepts/About-Logging.rst:11 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:13 ../../source/Concepts/About-ROS-2-Parameters.rst:11 ../../source/Concepts/About-ROS-Interfaces.rst:11 ../../source/Concepts/About-RQt.rst:13 ../../source/Concepts/About-Security.rst:8 ../../source/Concepts/About-Tf2.rst:8 ../../source/Concepts/About-Topic-Statistics.rst:11
msgid "Table of Contents"
msgstr "目录"


#: ../../source/Concepts/About-Catment.rst:15
msgid "Background"
msgstr "背景"


#: ../../source/Concepts/About-Catment.rst:17
msgid "There once was a thing called ``rosbuild``. Then came a thing called ``catkin``, which largely replaced ``rosbuild``. Recently introduced is a thing called ``ament``, which may one day replace ``catkin``."
msgstr "There once was a thing called ``rosbuild``. Then came a thing called ``catkin``, which largely replaced ``rosbuild``. Recently introduced is a thing called ``ament``, which may one day replace ``catkin``."


#: ../../source/Concepts/About-Catment.rst:21
msgid "All three tools can be considered \"meta-build systems\". They sit atop other build systems (e.g. CMake, Python setuptools) and provide extra functionality that's intended to make those build systems easier to use, especially when managing dependencies across multiple packages and when building multiple packages in a single workspace."
msgstr "All three tools can be considered \"meta-build systems\". They sit atop other build systems (e.g. CMake, Python setuptools) and provide extra functionality that's intended to make those build systems easier to use, especially when managing dependencies across multiple packages and when building multiple packages in a single workspace."


#: ../../source/Concepts/About-Catment.rst:24
msgid "Each of these meta-build systems does two things:"
msgstr "Each of these meta-build systems does two things:"


#: ../../source/Concepts/About-Catment.rst:28
msgid "Adds an API to the underlying build system (e.g. CMake) that can be used to simplify common tasks (e.g. supplying all the flags exported by depended-upon packages when building an executable). There are usually hooks to allow injection of extra APIs by packages outside of the core meta-build system."
msgstr "Adds an API to the underlying build system (e.g. CMake) that can be used to simplify common tasks (e.g. supplying all the flags exported by depended-upon packages when building an executable). There are usually hooks to allow injection of extra APIs by packages outside of the core meta-build system."


#: ../../source/Concepts/About-Catment.rst:32
msgid "``rosbuild``: ``mk/cmake.mk``, ``rosbuild_init()``, ``rosbuild_add_executable()``, etc."
msgstr "``rosbuild``: ``mk/cmake.mk``, ``rosbuild_init()``, ``rosbuild_add_executable()``, etc."


#: ../../source/Concepts/About-Catment.rst:33
msgid "``catkin``: ``catkin_package()``, ``catkin_install_python()``, etc."
msgstr "``catkin``: ``catkin_package()``, ``catkin_install_python()``, etc."


#: ../../source/Concepts/About-Catment.rst:34
msgid "``ament``: ``ament_target_dependencies()``, ``ament_export_dependencies()``, ``ament_package()``, etc."
msgstr "``ament``: ``ament_target_dependencies()``, ``ament_export_dependencies()``, ``ament_package()``, etc."


#: ../../source/Concepts/About-Catment.rst:37
msgid "Provides a tool that can be used to iterate in dependency order over a workspace full of packages, building and perhaps installing each one."
msgstr "Provides a tool that can be used to iterate in dependency order over a workspace full of packages, building and perhaps installing each one."


#: ../../source/Concepts/About-Catment.rst:40
msgid "``rosbuild``: ``rosmake``"
msgstr "``rosbuild``: ``rosmake``"


#: ../../source/Concepts/About-Catment.rst:41
msgid "``catkin``: ``catkin build``, ``catkin_make``, ``catkin_make_isolated``, etc."
msgstr "``catkin``: ``catkin build``, ``catkin_make``, ``catkin_make_isolated``, etc."


#: ../../source/Concepts/About-Catment.rst:42
msgid "``ament``: ``ament build``"
msgstr "``ament``: ``ament build``"


#: ../../source/Concepts/About-Catment.rst:44
msgid "The common thread that ties all of these systems together is the division of the code into **packages**\\ , with each package containing a manifest file (``manifest.xml`` or ``package.xml``). This manifest is required (with some exceptions) for both parts of the meta-build system (API and build tool) to function."
msgstr "The common thread that ties all of these systems together is the division of the code into **packages**\\ , with each package containing a manifest file (``manifest.xml`` or ``package.xml``). This manifest is required (with some exceptions) for both parts of the meta-build system (API and build tool) to function."


#: ../../source/Concepts/About-Catment.rst:48
msgid "Postulates"
msgstr "Postulates"


#: ../../source/Concepts/About-Catment.rst:51
msgid "**While we usually consider the two aspects of a meta-build system to be coupled, they needn't be.** The API used inside a package and the tool that iterates over the packages can be considered largely independent, with the package manifest forming the interface between them. There's no reason in principle why, for example, ``rosmake`` couldn't be modified to iterate over a workspace filled with ``catkin`` packages, stepping into them in dependency order and doing the usual ``mkdir build; cd build; cmake ..; make install`` routine for each one (with appropriate flags passed to ``cmake`` and ``make``)."
msgstr "**While we usually consider the two aspects of a meta-build system to be coupled, they needn't be.** The API used inside a package and the tool that iterates over the packages can be considered largely independent, with the package manifest forming the interface between them. There's no reason in principle why, for example, ``rosmake`` couldn't be modified to iterate over a workspace filled with ``catkin`` packages, stepping into them in dependency order and doing the usual ``mkdir build; cd build; cmake ..; make install`` routine for each one (with appropriate flags passed to ``cmake`` and ``make``)."


#: ../../source/Concepts/About-Catment.rst:55
msgid "**The effort required to migrate from one meta-build system to another should be minimized.** The mass migration from ``rosbuild`` to ``catkin`` was difficult and remains a sore point for many in the community. While it's reasonable to ask developers to make changes in exchange for getting access to new functionality, the changes that are required should be as small as possible without sacrificing the effectiveness of the new system. This is especially true when the old system is in widespread use."
msgstr "**The effort required to migrate from one meta-build system to another should be minimized.** The mass migration from ``rosbuild`` to ``catkin`` was difficult and remains a sore point for many in the community. While it's reasonable to ask developers to make changes in exchange for getting access to new functionality, the changes that are required should be as small as possible without sacrificing the effectiveness of the new system. This is especially true when the old system is in widespread use."


#: ../../source/Concepts/About-Catment.rst:61
msgid "Corollary: **Migration to a new meta-build system should not be required without a very good reason.** If a developer doesn't want the functionality offered by the new system, then they shouldn't be coerced into migrating from the old system unless there's something irrevocably broken about the old system (e.g. ``rosbuild``\\ 's in-source build pattern and lack of an \"install\" step)."
msgstr "Corollary: **Migration to a new meta-build system should not be required without a very good reason.** If a developer doesn't want the functionality offered by the new system, then they shouldn't be coerced into migrating from the old system unless there's something irrevocably broken about the old system (e.g. ``rosbuild``\\ 's in-source build pattern and lack of an \"install\" step)."


#: ../../source/Concepts/About-Catment.rst:65
msgid "**Interoperability is a good thing.** Whenever possible (not all combinations will be practical), developers should be able to mix and match meta-build systems, including mixing their different aspects (i.e., use the building tool from one system and the API from another). Such mixing and matching is especially important when developers want to combine a large existing codebase using one meta-build system (e.g. ROS with ``catkin``) with new libraries and tools offered by a codebase using another meta-build system (e.g. ROS 2 with ``ament``). Ideally, that kind of combination can be done without requiring changes to the API used by either codebase and without telling the developer which builder tool to use."
msgstr "**Interoperability is a good thing.** Whenever possible (not all combinations will be practical), developers should be able to mix and match meta-build systems, including mixing their different aspects (i.e., use the building tool from one system and the API from another). Such mixing and matching is especially important when developers want to combine a large existing codebase using one meta-build system (e.g. ROS with ``catkin``) with new libraries and tools offered by a codebase using another meta-build system (e.g. ROS 2 with ``ament``). Ideally, that kind of combination can be done without requiring changes to the API used by either codebase and without telling the developer which builder tool to use."


#: ../../source/Concepts/About-Catment.rst:71
msgid "Corollary: **Workspaces needn't be homogeneous.** There's no reason that we shouldn't be able to freely mix, say, ``catkin`` and ``ament`` packages in one workspace, with dependencies going in both directions, so long as the builder tool in use knows how to build them both. The primary interface between packages (at least, CMake-controlled packages) is their CMake configuration file. So long as that configuration file follows the standard protocol (setting ``foo_LIBRARIES``, etc.), then it shouldn't matter who wrote the file. It could be auto-generated by ``catkin`` or ``ament``, or even manually crafted by a developer who wants to use plain CMake in their package, but still have that package depended-upon by ``catkin`` or ``ament`` packages."
msgstr "Corollary: **Workspaces needn't be homogeneous.** There's no reason that we shouldn't be able to freely mix, say, ``catkin`` and ``ament`` packages in one workspace, with dependencies going in both directions, so long as the builder tool in use knows how to build them both. The primary interface between packages (at least, CMake-controlled packages) is their CMake configuration file. So long as that configuration file follows the standard protocol (setting ``foo_LIBRARIES``, etc.), then it shouldn't matter who wrote the file. It could be auto-generated by ``catkin`` or ``ament``, or even manually crafted by a developer who wants to use plain CMake in their package, but still have that package depended-upon by ``catkin`` or ``ament`` packages."


#: ../../source/Concepts/About-Catment.rst:78
msgid "Use cases, with experimental implementations"
msgstr "Use cases, with experimental implementations"


#: ../../source/Concepts/About-Catment.rst:81
msgid "Adding ROS packages to a ROS 2 workspace and building with ``ament build``"
msgstr "Adding ROS packages to a ROS 2 workspace and building with ``ament build``"


#: ../../source/Concepts/About-Catment.rst:83
msgid "Let's say that you want to add some existing ROS packages to your ROS 2 workspace and don't want to migrate the ROS packages from ``catkin`` to ``ament`` (or vice versa). Here are two patches that let you do that:"
msgstr "Let's say that you want to add some existing ROS packages to your ROS 2 workspace and don't want to migrate the ROS packages from ``catkin`` to ``ament`` (or vice versa). Here are two patches that let you do that:"


#: ../../source/Concepts/About-Catment.rst:86
msgid "`ament_package <https://github.com/ament/ament_package/compare/catkin?expand=1>`__: Adds support for format 1 package manifests, instead of requiring format 2. This change isn't strictly related to ``catkin`` vs. ``ament``, because format 2 has been around for a while and ``catkin`` supports it, so developers could already update their manifests to format 2. But there's a ton of ROS code out there that uses format 1, so we should support it. This implementation could be improved, e.g. by reasoning over the various flavors of depend tags and how they differ between formats 1 and 2."
msgstr "`ament_package <https://github.com/ament/ament_package/compare/catkin?expand=1>`__: Adds support for format 1 package manifests, instead of requiring format 2. This change isn't strictly related to ``catkin`` vs. ``ament``, because format 2 has been around for a while and ``catkin`` supports it, so developers could already update their manifests to format 2. But there's a ton of ROS code out there that uses format 1, so we should support it. This implementation could be improved, e.g. by reasoning over the various flavors of depend tags and how they differ between formats 1 and 2."


#: ../../source/Concepts/About-Catment.rst:91
msgid "`ament_tools <https://github.com/ament/ament_tools/compare/catkin?expand=1>`__: Adds a new ``catkin`` build type to ``ament``. This implementation just treats ``catkin`` packages the same as plain ``cmake`` packages, which seems to work fine. It could be made more sophisticated."
msgstr "`ament_tools <https://github.com/ament/ament_tools/compare/catkin?expand=1>`__: Adds a new ``catkin`` build type to ``ament``. This implementation just treats ``catkin`` packages the same as plain ``cmake`` packages, which seems to work fine. It could be made more sophisticated."


#: ../../source/Concepts/About-Catment.rst:96
msgid "Example usage:"
msgstr "Example usage:"


#: ../../source/Concepts/About-Catment.rst:99
msgid "Get the ROS 2 code as usual, using the branches mentioned above."
msgstr "Get the ROS 2 code as usual, using the branches mentioned above."


#: ../../source/Concepts/About-Catment.rst:100
msgid "Add to your workspace some ``catkin`` ROS packages, ensuring that all of their dependencies are satisfied (either present in the workspace or installed elsewhere with appropriate setup shell files sourced)."
msgstr "Add to your workspace some ``catkin`` ROS packages, ensuring that all of their dependencies are satisfied (either present in the workspace or installed elsewhere with appropriate setup shell files sourced)."


#: ../../source/Concepts/About-Catment.rst:101
msgid "Build as usual (e.g. ``colcon build``)."
msgstr "Build as usual (e.g. ``colcon build``)."


#: ../../source/Concepts/About-Catment.rst:103
msgid "Voila: your existing code isn't suddenly broken just because there's a new build tool in use."
msgstr "Voila: your existing code isn't suddenly broken just because there's a new build tool in use."


#: ../../source/Concepts/About-Catment.rst:106
msgid "Variation: Building ROS packages with ``ament build``"
msgstr "Variation: Building ROS packages with ``ament build``"


#: ../../source/Concepts/About-Catment.rst:108
msgid "Let's say that you love the new ``ament`` tool and want to use it to build your existing ROS packages that use ``catkin`` internally. Here's an example of how to do that, by doing a minimal installation of ``ament`` and then using it to build a workspace full of ROS ``catkin`` packages:"
msgstr "Let's say that you love the new ``ament`` tool and want to use it to build your existing ROS packages that use ``catkin`` internally. Here's an example of how to do that, by doing a minimal installation of ``ament`` and then using it to build a workspace full of ROS ``catkin`` packages:"


#: ../../source/Concepts/About-Catment.rst:126
msgid "Now build the ROS packages:"
msgstr "Now build the ROS packages:"


#: ../../source/Concepts/About-Catment.rst:134
msgid "Voila: you used the ``ament`` build tool to build your ``catkin`` packages, without having to migrate them."
msgstr "Voila: you used the ``ament`` build tool to build your ``catkin`` packages, without having to migrate them."


#: ../../source/Concepts/About-Catment.rst:137
msgid "Variation: Using the ``catkin`` API in a ROS 2 package"
msgstr "Variation: Using the ``catkin`` API in a ROS 2 package"


#: ../../source/Concepts/About-Catment.rst:139
msgid "Let's say that you're building on top of ROS 2, which internally uses the ``ament`` API, and you want to add a new package using the ``catkin`` API."
msgstr "Let's say that you're building on top of ROS 2, which internally uses the ``ament`` API, and you want to add a new package using the ``catkin`` API."


#: ../../source/Concepts/About-Catment.rst:141
msgid "To make this work, you need a Python3 installation of ``catkin`` (the binary debians use Python2.7). Here's an example of doing that, installing to ``$HOME/catkin``:"
msgstr "To make this work, you need a Python3 installation of ``catkin`` (the binary debians use Python2.7). Here's an example of doing that, installing to ``$HOME/catkin``:"


#: ../../source/Concepts/About-Catment.rst:160
msgid "To use that version of catkin, you just need to source the ``$HOME/catkin/setup.bash`` file."
msgstr "To use that version of catkin, you just need to source the ``$HOME/catkin/setup.bash`` file."


#: ../../source/Concepts/About-Catment.rst:162
msgid "Let's assume that you have the usual ROS 2 workspace in ``~/ros2_ws``, and that you're on the ``catkin`` branches in ``ament_package`` and ``ament_tools``. Add to that workspace the ``image_tools_catkin`` package from https://github.com/gerkey/catment. It's a simple port of the ROS 2 ``image_tools`` package, taking it from the ``ament`` API to the ``catkin`` API. To build it:"
msgstr "Let's assume that you have the usual ROS 2 workspace in ``~/ros2_ws``, and that you're on the ``catkin`` branches in ``ament_package`` and ``ament_tools``. Add to that workspace the ``image_tools_catkin`` package from https://github.com/gerkey/catment. It's a simple port of the ROS 2 ``image_tools`` package, taking it from the ``ament`` API to the ``catkin`` API. To build it:"


#: ../../source/Concepts/About-Catment.rst:173
msgid "Voila: when adding new packages atop ROS 2, you're free to choose which CMake API you prefer inside your package."
msgstr "Voila: when adding new packages atop ROS 2, you're free to choose which CMake API you prefer inside your package."


#: ../../source/Concepts/About-Catment.rst:176
msgid "**Caveat**: Requires commenting out the use of ``CATKIN_DEPENDS`` inside ``catkin_package()``, because somewhere somebody was getting upset that things like ``rclcpp`` aren't ``catkin`` packages. That constraint needs to be relaxed somehow."
msgstr "**Caveat**: Requires commenting out the use of ``CATKIN_DEPENDS`` inside ``catkin_package()``, because somewhere somebody was getting upset that things like ``rclcpp`` aren't ``catkin`` packages. That constraint needs to be relaxed somehow."


#: ../../source/Concepts/About-Catment.rst:178
msgid "**TODO**: The same demo but with an ``ament`` package that depends on a ``catkin`` package (this is easy)."
msgstr "**TODO**: The same demo but with an ``ament`` package that depends on a ``catkin`` package (this is easy)."


#: ../../source/Concepts/About-Catment.rst:179
msgid "**TODO**: The same demo but with a package that has a vanilla ``CMakeLists.txt`` that uses neither ``ament`` nor ``catkin``, and provides a manually generated ``fooConfig.cmake`` file that exports the right stuff to make it look the same to outsiders."
msgstr "**TODO**: The same demo but with a package that has a vanilla ``CMakeLists.txt`` that uses neither ``ament`` nor ``catkin``, and provides a manually generated ``fooConfig.cmake`` file that exports the right stuff to make it look the same to outsiders."


#: ../../source/Concepts/About-Catment.rst:182
msgid "Building ROS 2 packages with ``catkin_make_isolated``"
msgstr "Building ROS 2 packages with ``catkin_make_isolated``"


#: ../../source/Concepts/About-Catment.rst:184
msgid "Let's say that you're already familiar with ROS and ``catkin`` and you're excited to try ROS 2, but you're not in the mood to learn about ``ament``. You'd rather stick to what you know, such as using ``catkin_make_isolated`` to build everything. Here is a patch that allows you to do that:"
msgstr "Let's say that you're already familiar with ROS and ``catkin`` and you're excited to try ROS 2, but you're not in the mood to learn about ``ament``. You'd rather stick to what you know, such as using ``catkin_make_isolated`` to build everything. Here is a patch that allows you to do that:"


#: ../../source/Concepts/About-Catment.rst:189
msgid "`catkin <https://github.com/ros/catkin/compare/ament?expand=1>`__: Adds support for packages that declare themselves to have a build type of ``ament_*``. This implementation calls out to ``ament`` to build each such package. While ``ament_cmake`` packages can be treated as plain ``cmake`` packages (as we did when adding ``catkin`` support to ``ament``), ``ament_python`` packages require some gnarly invocations of Python. Instead of trying to replicate that logic in ``catkin``, it's easier to just let ``ament`` handle it. Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when building."
msgstr "`catkin <https://github.com/ros/catkin/compare/ament?expand=1>`__: Adds support for packages that declare themselves to have a build type of ``ament_*``. This implementation calls out to ``ament`` to build each such package. While ``ament_cmake`` packages can be treated as plain ``cmake`` packages (as we did when adding ``catkin`` support to ``ament``), ``ament_python`` packages require some gnarly invocations of Python. Instead of trying to replicate that logic in ``catkin``, it's easier to just let ``ament`` handle it. Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when building."


#: ../../source/Concepts/About-Catment.rst:195
msgid "`catkin_pkg <https://github.com/ros-infrastructure/catkin_pkg/compare/ament?expand=1>`__: Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when computing the topological order."
msgstr "`catkin_pkg <https://github.com/ros-infrastructure/catkin_pkg/compare/ament?expand=1>`__: Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when computing the topological order."


#: ../../source/Concepts/About-Catment.rst:198
msgid "Because we're going to call out to ``ament build``, we will also need a minimal installation of ``ament``, as done in a previous example:"
msgstr "Because we're going to call out to ``ament build``, we will also need a minimal installation of ``ament``, as done in a previous example:"


#: ../../source/Concepts/About-Catment.rst:215
msgid "Then we need to install the modified version of catkin somewhere:"
msgstr "Then we need to install the modified version of catkin somewhere:"


#: ../../source/Concepts/About-Catment.rst:233
msgid "Now build the ROS 2 packages:"
msgstr "Now build the ROS 2 packages:"


#: ../../source/Concepts/About-Catment.rst:243
msgid "Voila: you've built ROS 2 using the tools that you're familiar with."
msgstr "Voila: you've built ROS 2 using the tools that you're familiar with."


#: ../../source/Concepts/About-Catment.rst:246
msgid "**Caveat**: we're ignoring the ``eProsima`` packages in the workspace because they lack ``package.xml`` files, which means that ``catkin`` can't see them. ``ament`` has some heuristics for handling such packages. Options: backport those heuristics to ``catkin``; switch to installing non-``package.xml``-containing packages outside of the workspace; or just add a ``package.xml`` to each of those packages (e.g. in our own fork)."
msgstr "**Caveat**: we're ignoring the ``eProsima`` packages in the workspace because they lack ``package.xml`` files, which means that ``catkin`` can't see them. ``ament`` has some heuristics for handling such packages. Options: backport those heuristics to ``catkin``; switch to installing non-``package.xml``-containing packages outside of the workspace; or just add a ``package.xml`` to each of those packages (e.g. in our own fork)."


#: ../../source/Concepts/About-Catment.rst:251
msgid "Combining all of ROS and ROS 2 in one workspace and building it (TODO)"
msgstr "Combining all of ROS and ROS 2 in one workspace and building it (TODO)"


#: ../../source/Concepts/About-Catment.rst:253
msgid "This step will require sorting out some things, including at least:"
msgstr "This step will require sorting out some things, including at least:"


#: ../../source/Concepts/About-Catment.rst:255
msgid "Package name conflicts. We currently have ROS 2 versions of ROS message packages, as well as some stuff in ``geometry2``. Either the functionality needs to be merged into one package that can support both systems, or the new versions need different names."
msgstr "Package name conflicts. We currently have ROS 2 versions of ROS message packages, as well as some stuff in ``geometry2``. Either the functionality needs to be merged into one package that can support both systems, or the new versions need different names."


#: ../../source/Concepts/About-Catment.rst:258
msgid "Message generation. ROS and ROS 2 have different message generation steps, the output of which might or might not conflict. Something sophisticated needs to be done to allow generation of all the right artifacts from a single message package (or, as indicated above, the new message packages need different names)."
msgstr "Message generation. ROS and ROS 2 have different message generation steps, the output of which might or might not conflict. Something sophisticated needs to be done to allow generation of all the right artifacts from a single message package (or, as indicated above, the new message packages need different names)."


#: ../../source/Concepts/About-Catment.rst:263
msgid "Using ``bloom`` to release ``ament`` packages (TODO)"
msgstr "Using ``bloom`` to release ``ament`` packages (TODO)"


#: ../../source/Concepts/About-Catment.rst:265
msgid "It seems like ``bloom`` ought be able to release packages that use the ``ament`` CMake API, and that the resulting releases should be able to be built on the farm. We can make changes to ``bloom`` and ``ros_buildfarm`` as needed to enable this use case."
msgstr "It seems like ``bloom`` ought be able to release packages that use the ``ament`` CMake API, and that the resulting releases should be able to be built on the farm. We can make changes to ``bloom`` and ``ros_buildfarm`` as needed to enable this use case."


#: ../../source/Concepts/About-Command-Line-Tools.rst:7
msgid "Introspection with command line tools"
msgstr "Introspection with command line tools"


#: ../../source/Concepts/About-Command-Line-Tools.rst:13
msgid "ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system."
msgstr "ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system."


#: ../../source/Concepts/About-Command-Line-Tools.rst:16
msgid "Usage"
msgstr "Usage"


#: ../../source/Concepts/About-Command-Line-Tools.rst:18
msgid "The main entry point for the tools is the command ``ros2``, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more."
msgstr "The main entry point for the tools is the command ``ros2``, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more."


#: ../../source/Concepts/About-Command-Line-Tools.rst:20
msgid "To see all available sub-commands run:"
msgstr "To see all available sub-commands run:"


#: ../../source/Concepts/About-Command-Line-Tools.rst:26
msgid "Examples of sub-commands that are available include:"
msgstr "Examples of sub-commands that are available include:"


#: ../../source/Concepts/About-Command-Line-Tools.rst:29
msgid "action: Introspect/interact with ROS actions"
msgstr "action: Introspect/interact with ROS actions"


#: ../../source/Concepts/About-Command-Line-Tools.rst:30
msgid "bag: Record/play a rosbag"
msgstr "bag: Record/play a rosbag"


#: ../../source/Concepts/About-Command-Line-Tools.rst:31
msgid "component: Manage component containers"
msgstr "component: Manage component containers"


#: ../../source/Concepts/About-Command-Line-Tools.rst:32
msgid "daemon: Introspect/configure the ROS 2 daemon"
msgstr "daemon: Introspect/configure the ROS 2 daemon"


#: ../../source/Concepts/About-Command-Line-Tools.rst:33
msgid "doctor: Check ROS setup for potential issues"
msgstr "doctor: Check ROS setup for potential issues"


#: ../../source/Concepts/About-Command-Line-Tools.rst:34
msgid "interface: Show information about ROS interfaces"
msgstr "interface: Show information about ROS interfaces"


#: ../../source/Concepts/About-Command-Line-Tools.rst:35
msgid "launch: Run/introspect a launch file"
msgstr "launch: Run/introspect a launch file"


#: ../../source/Concepts/About-Command-Line-Tools.rst:36
msgid "lifecycle: Introspect/manage nodes with managed lifecycles"
msgstr "lifecycle: Introspect/manage nodes with managed lifecycles"


#: ../../source/Concepts/About-Command-Line-Tools.rst:37
msgid "node: Introspect ROS nodes"
msgstr "node: Introspect ROS nodes"


#: ../../source/Concepts/About-Command-Line-Tools.rst:38
msgid "param: Introspect/configure parameters on a node"
msgstr "param: Introspect/configure parameters on a node"


#: ../../source/Concepts/About-Command-Line-Tools.rst:39
msgid "pkg: Introspect ROS packages"
msgstr "pkg: Introspect ROS packages"


#: ../../source/Concepts/About-Command-Line-Tools.rst:40
msgid "run: Run ROS nodes"
msgstr "run: Run ROS nodes"


#: ../../source/Concepts/About-Command-Line-Tools.rst:41
msgid "security: Configure security settings"
msgstr "security: Configure security settings"


#: ../../source/Concepts/About-Command-Line-Tools.rst:42
msgid "service: Introspect/call ROS services"
msgstr "service: Introspect/call ROS services"


#: ../../source/Concepts/About-Command-Line-Tools.rst:43
msgid "test: Run a ROS launch test"
msgstr "test: Run a ROS launch test"


#: ../../source/Concepts/About-Command-Line-Tools.rst:44
msgid "topic: Introspect/publish ROS topics"
msgstr "topic: Introspect/publish ROS topics"


#: ../../source/Concepts/About-Command-Line-Tools.rst:45
msgid "trace: Tracing tools to get information on ROS nodes execution (only available on Linux)"
msgstr "trace: Tracing tools to get information on ROS nodes execution (only available on Linux)"


#: ../../source/Concepts/About-Command-Line-Tools.rst:48
msgid "Example"
msgstr "示例"


#: ../../source/Concepts/About-Command-Line-Tools.rst:50
msgid "To produce the typical talker-listener example using command-line tools, the ``topic`` sub-command can be used to publish and echo messages on a topic."
msgstr "To produce the typical talker-listener example using command-line tools, the ``topic`` sub-command can be used to publish and echo messages on a topic."


#: ../../source/Concepts/About-Command-Line-Tools.rst:52
msgid "Publish messages in one terminal with:"
msgstr "Publish messages in one terminal with:"


#: ../../source/Concepts/About-Command-Line-Tools.rst:62
msgid "Echo messages received in another terminal with:"
msgstr "Echo messages received in another terminal with:"


#: ../../source/Concepts/About-Command-Line-Tools.rst:72
msgid "Behind the scenes"
msgstr "Behind the scenes"


#: ../../source/Concepts/About-Command-Line-Tools.rst:74
msgid "ROS 2 uses a distributed discovery process for nodes to connect to each other. As this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph. Because of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names."
msgstr "ROS 2 uses a distributed discovery process for nodes to connect to each other. As this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph. Because of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names."


#: ../../source/Concepts/About-Command-Line-Tools.rst:78
msgid "The daemon is automatically started when the relevant command-line tools are used for the first time. You can run ``ros2 daemon --help`` for more options for interacting with the daemon."
msgstr "The daemon is automatically started when the relevant command-line tools are used for the first time. You can run ``ros2 daemon --help`` for more options for interacting with the daemon."


#: ../../source/Concepts/About-Command-Line-Tools.rst:82
msgid "Implementation"
msgstr "实施"


#: ../../source/Concepts/About-Command-Line-Tools.rst:84
msgid "The source code for the ``ros2`` command is available at https://github.com/ros2/ros2cli."
msgstr "The source code for the ``ros2`` command is available at https://github.com/ros2/ros2cli."


#: ../../source/Concepts/About-Command-Line-Tools.rst:86
msgid "The ``ros2`` tool has been implemented as a framework that can be extended via plugins. For example, the `sros2 <https://github.com/ros2/sros2>`__ package provides a ``security`` sub-command that is automatically detected by the ``ros2`` tool if the ``sros2`` package is installed."
msgstr "The ``ros2`` tool has been implemented as a framework that can be extended via plugins. For example, the `sros2 <https://github.com/ros2/sros2>`__ package provides a ``security`` sub-command that is automatically detected by the ``ros2`` tool if the ``sros2`` package is installed."


#: ../../source/Concepts/About-Composition.rst:2
msgid "About Composition"
msgstr "About Composition"


#: ../../source/Concepts/About-Composition.rst:9
msgid "ROS 1 - Nodes vs. Nodelets"
msgstr "ROS 1 - Nodes vs. Nodelets"


#: ../../source/Concepts/About-Composition.rst:11
msgid "In ROS 1 you can write your code either as a `ROS node <https://wiki.ros.org/Nodes>`__ or as a `ROS nodelet <https://wiki.ros.org/nodelet>`__. ROS 1 nodes are compiled into executables. ROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process."
msgstr "In ROS 1 you can write your code either as a `ROS node <https://wiki.ros.org/Nodes>`__ or as a `ROS nodelet <https://wiki.ros.org/nodelet>`__. ROS 1 nodes are compiled into executables. ROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process."


#: ../../source/Concepts/About-Composition.rst:16
msgid "ROS 2 - Unified API"
msgstr "ROS 2 - Unified API"


#: ../../source/Concepts/About-Composition.rst:18
msgid "In ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a ``Component``. This makes it easy to add common concepts to existing code, like a `life cycle <https://design.ros2.org/articles/node_lifecycle.html>`__. Having different APIs, which was the biggest drawback in ROS 1, is avoided in ROS 2 since both approaches use the same API."
msgstr "In ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a ``Component``. This makes it easy to add common concepts to existing code, like a `life cycle <https://design.ros2.org/articles/node_lifecycle.html>`__. Having different APIs, which was the biggest drawback in ROS 1, is avoided in ROS 2 since both approaches use the same API."


#: ../../source/Concepts/About-Composition.rst:24
msgid "It is still possible to use the node-like style of \"writing your own main\" but for the common case it is not recommended."
msgstr "It is still possible to use the node-like style of \"writing your own main\" but for the common case it is not recommended."


#: ../../source/Concepts/About-Composition.rst:27
msgid "By making the process layout a deploy-time decision the user can choose between:"
msgstr "By making the process layout a deploy-time decision the user can choose between:"


#: ../../source/Concepts/About-Composition.rst:30
msgid "running multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and"
msgstr "running multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and"


#: ../../source/Concepts/About-Composition.rst:31
msgid "running multiple nodes in a single process with the lower overhead and optionally more efficient communication (see :doc:`Intra Process Communication <../Tutorials/Demos/Intra-Process-Communication>`)."
msgstr "running multiple nodes in a single process with the lower overhead and optionally more efficient communication (see :doc:`Intra Process Communication <../Tutorials/Demos/Intra-Process-Communication>`)."


#: ../../source/Concepts/About-Composition.rst:33
msgid "Additionally ``ros2 launch`` can be used to automate these actions through specialized launch actions."
msgstr "Additionally ``ros2 launch`` can be used to automate these actions through specialized launch actions."


#: ../../source/Concepts/About-Composition.rst:37
msgid "Writing a Component"
msgstr "Writing a Component"


#: ../../source/Concepts/About-Composition.rst:39
msgid "Since a component is only built into a shared library, it doesn't have a ``main`` function (see `Talker source code <https://github.com/ros2/demos/blob/humble/composition/src/talker_component.cpp>`__). A component is commonly a subclass of ``rclcpp::Node``. Since it is not in control of the thread, it shouldn't perform any long running or blocking tasks in its constructor. Instead, it can use timers to get periodic notifications. Additionally, it can create publishers, subscriptions, servers, and clients."
msgstr "Since a component is only built into a shared library, it doesn't have a ``main`` function (see `Talker source code <https://github.com/ros2/demos/blob/humble/composition/src/talker_component.cpp>`__). A component is commonly a subclass of ``rclcpp::Node``. Since it is not in control of the thread, it shouldn't perform any long running or blocking tasks in its constructor. Instead, it can use timers to get periodic notifications. Additionally, it can create publishers, subscriptions, servers, and clients."


#: ../../source/Concepts/About-Composition.rst:45
msgid "An important aspect of making such a class a component is that the class registers itself using macros from the package ``rclcpp_components`` (see the last line in the source code). This makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point."
msgstr "An important aspect of making such a class a component is that the class registers itself using macros from the package ``rclcpp_components`` (see the last line in the source code). This makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point."


#: ../../source/Concepts/About-Composition.rst:48
msgid "Additionally, once a component is created, it must be registered with the index to be discoverable by the tooling."
msgstr "Additionally, once a component is created, it must be registered with the index to be discoverable by the tooling."


#: ../../source/Concepts/About-Composition.rst:59
msgid "In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace."
msgstr "In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace."


#: ../../source/Concepts/About-Composition.rst:64
msgid "Using Components"
msgstr "Using Components"


#: ../../source/Concepts/About-Composition.rst:66
msgid "The `composition <https://github.com/ros2/demos/tree/humble/composition>`__ package contains a couple of different approaches on how to use components. The three most common ones are:"
msgstr "The `composition <https://github.com/ros2/demos/tree/humble/composition>`__ package contains a couple of different approaches on how to use components. The three most common ones are:"


#: ../../source/Concepts/About-Composition.rst:70
msgid "Start a (`generic container process <https://github.com/ros2/rclcpp/blob/humble/rclcpp_components/src/component_container.cpp>`__) and call the ROS service `load_node <https://github.com/ros2/rcl_interfaces/blob/humble/composition_interfaces/srv/LoadNode.srv>`__ offered by the container. The ROS service will then load the component specified by the passed package name and library name and start executing it within the running process. Instead of calling the ROS service programmatically you can also use a `command line tool <https://github.com/ros2/ros2cli/tree/humble/ros2component>`__ to invoke the ROS service with the passed command line arguments"
msgstr "Start a (`generic container process <https://github.com/ros2/rclcpp/blob/humble/rclcpp_components/src/component_container.cpp>`__) and call the ROS service `load_node <https://github.com/ros2/rcl_interfaces/blob/humble/composition_interfaces/srv/LoadNode.srv>`__ offered by the container. The ROS service will then load the component specified by the passed package name and library name and start executing it within the running process. Instead of calling the ROS service programmatically you can also use a `command line tool <https://github.com/ros2/ros2cli/tree/humble/ros2component>`__ to invoke the ROS service with the passed command line arguments"


#: ../../source/Concepts/About-Composition.rst:73
msgid "Create a `custom executable <https://github.com/ros2/demos/blob/humble/composition/src/manual_composition.cpp>`__ containing multiple nodes which are known at compile time. This approach requires that each component has a header file (which is not strictly needed for the first case)."
msgstr "Create a `custom executable <https://github.com/ros2/demos/blob/humble/composition/src/manual_composition.cpp>`__ containing multiple nodes which are known at compile time. This approach requires that each component has a header file (which is not strictly needed for the first case)."


#: ../../source/Concepts/About-Composition.rst:75
msgid "Create a launch file and use ``ros2 launch`` to create a container process with multiple components loaded."
msgstr "Create a launch file and use ``ros2 launch`` to create a container process with multiple components loaded."


#: ../../source/Concepts/About-Composition.rst:78
msgid "Practical application"
msgstr "Practical application"


#: ../../source/Concepts/About-Composition.rst:80
msgid "Try the :doc:`Composition demos <../Tutorials/Intermediate/Composition>`."
msgstr "Try the :doc:`Composition demos <../Tutorials/Intermediate/Composition>`."


#: ../../source/Concepts/About-Cross-Compilation.rst:2
msgid "About Cross-compilation"
msgstr "About Cross-compilation"


#: ../../source/Concepts/About-Cross-Compilation.rst:5 ../../source/Concepts/About-Domain-ID.rst:6 ../../source/Concepts/About-Executors.rst:10 ../../source/Concepts/About-Logging.rst:14 ../../source/Concepts/About-Quality-of-Service-Settings.rst:10 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:16 ../../source/Concepts/About-ROS-2-Parameters.rst:14 ../../source/Concepts/About-RQt.rst:16 ../../source/Concepts/About-Security.rst:11 ../../source/Concepts/About-Tf2.rst:11 ../../source/Concepts/About-Topic-Statistics.rst:14
msgid "Overview"
msgstr "Overview"


#: ../../source/Concepts/About-Cross-Compilation.rst:10
msgid "Open Robotics provides pre-built ROS 2 packages for multiple platforms, but a number of developers still rely on `cross-compilation <https://en.wikipedia.org/wiki/Cross_compiler>`__ for different reasons such as:"
msgstr "Open Robotics provides pre-built ROS 2 packages for multiple platforms, but a number of developers still rely on `cross-compilation <https://en.wikipedia.org/wiki/Cross_compiler>`__ for different reasons such as:"


#: ../../source/Concepts/About-Cross-Compilation.rst:8
msgid "The development machine does not match the target system."
msgstr "The development machine does not match the target system."


#: ../../source/Concepts/About-Cross-Compilation.rst:9
msgid "Tuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3)."
msgstr "Tuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3)."


#: ../../source/Concepts/About-Cross-Compilation.rst:10
msgid "Targeting a file system other than the ones supported by the pre-built images released by Open Robotics."
msgstr "Targeting a file system other than the ones supported by the pre-built images released by Open Robotics."


#: ../../source/Concepts/About-Cross-Compilation.rst:13
msgid "How does it work ?"
msgstr "How does it work ?"


#: ../../source/Concepts/About-Cross-Compilation.rst:15
msgid "Cross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain."
msgstr "Cross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain."


#: ../../source/Concepts/About-Cross-Compilation.rst:20
msgid "There are a number of factors which make this process more complex:"
msgstr "There are a number of factors which make this process more complex:"


#: ../../source/Concepts/About-Cross-Compilation.rst:18
msgid "The software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code."
msgstr "The software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code."


#: ../../source/Concepts/About-Cross-Compilation.rst:19
msgid "All dependencies (e.g. libraries) must be present, either as pre-built or cross-compiled packages, before the target software using them is cross-compiled."
msgstr "All dependencies (e.g. libraries) must be present, either as pre-built or cross-compiled packages, before the target software using them is cross-compiled."


#: ../../source/Concepts/About-Cross-Compilation.rst:20
msgid "When building software stacks (as opposed to standalone software) using build tools (e.g. colcon), it is expected that the build tool provides a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each piece of software in the stack."
msgstr "When building software stacks (as opposed to standalone software) using build tools (e.g. colcon), it is expected that the build tool provides a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each piece of software in the stack."


#: ../../source/Concepts/About-Cross-Compilation.rst:23
msgid "Cross-compiling ROS 2"
msgstr "Cross-compiling ROS 2"


#: ../../source/Concepts/About-Cross-Compilation.rst:25
msgid "The ROS 2 cross-compile tool is under shared ownership of Open Robotics and ROS Tooling Working Group. It is a Python script that compiles ROS 2 source files for supported target architectures using an emulator in a docker container. Detailed design of the tool can be found on `ROS 2 design <https://design.ros2.org/articles/cc_build_tools.html>`__. Instructions to use the tool are in the `cross_compile package <https://github.com/ros-tooling/cross_compile>`__."
msgstr "The ROS 2 cross-compile tool is under shared ownership of Open Robotics and ROS Tooling Working Group. It is a Python script that compiles ROS 2 source files for supported target architectures using an emulator in a docker container. Detailed design of the tool can be found on `ROS 2 design <https://design.ros2.org/articles/cc_build_tools.html>`__. Instructions to use the tool are in the `cross_compile package <https://github.com/ros-tooling/cross_compile>`__."


#: ../../source/Concepts/About-Cross-Compilation.rst:30
msgid "If you are using an older version, please follow the :doc:`cross-compilation guide <../How-To-Guides/Cross-compilation>`."
msgstr "If you are using an older version, please follow the :doc:`cross-compilation guide <../How-To-Guides/Cross-compilation>`."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:6
msgid "About different ROS 2 DDS/RTPS vendors"
msgstr "About different ROS 2 DDS/RTPS vendors"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:8
msgid "ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation. `This article <https://design.ros2.org/articles/ros_on_dds.html>`__ explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail. In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different \"Quality of Service\" options for the transportation."
msgstr "ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation. `This article <https://design.ros2.org/articles/ros_on_dds.html>`__ explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail. In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different \"Quality of Service\" options for the transportation."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:12
msgid "`DDS <https://www.omg.org/omg-dds-portal>`__ is an industry standard which is implemented by a range of vendors, such as RTI's `Connext DDS <https://www.rti.com/products/>`__, eProsima's `Fast DDS <https://fast-dds.docs.eprosima.com/>`__, Eclipse's `Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__, or GurumNetworks's `GurumDDS <https://gurum.cc/index_eng>`__. RTPS (a.k.a. `DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\\ ) is the wire protocol used by DDS to communicate over the network."
msgstr "`DDS <https://www.omg.org/omg-dds-portal>`__ is an industry standard which is implemented by a range of vendors, such as RTI's `Connext DDS <https://www.rti.com/products/>`__, eProsima's `Fast DDS <https://fast-dds.docs.eprosima.com/>`__, Eclipse's `Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__, or GurumNetworks's `GurumDDS <https://gurum.cc/index_eng>`__. RTPS (a.k.a. `DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\\ ) is the wire protocol used by DDS to communicate over the network."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:15
msgid "ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily \"one size fits all\" when it comes to choosing a vendor/implementation. There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint. Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs. For example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time)."
msgstr "ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily \"one size fits all\" when it comes to choosing a vendor/implementation. There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint. Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs. For example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time)."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:20
msgid "In order to use a DDS/RTPS implementation with ROS 2, a \"\\ **R**\\ OS **M**\\ iddle\\ **w**\\ are interface\" (a.k.a. ``rmw`` interface or just ``rmw``\\ ) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation's API and tools. It's a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project's needs."
msgstr "In order to use a DDS/RTPS implementation with ROS 2, a \"\\ **R**\\ OS **M**\\ iddle\\ **w**\\ are interface\" (a.k.a. ``rmw`` interface or just ``rmw``\\ ) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation's API and tools. It's a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project's needs."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:24
msgid "Supported RMW implementations"
msgstr "Supported RMW implementations"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:29
msgid "Product name"
msgstr "Product name"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:30
msgid "License"
msgstr "License"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:31
msgid "RMW implementation"
msgstr "RMW implementation"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:32
msgid "Status"
msgstr "Status"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:33
msgid "eProsima *Fast DDS*"
msgstr "eProsima *Fast DDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:34
msgid "Apache 2"
msgstr "Apache 2"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:35
msgid "``rmw_fastrtps_cpp``"
msgstr "``rmw_fastrtps_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:36
msgid "Full support. Default RMW. Packaged with binary releases."
msgstr "Full support. Default RMW. Packaged with binary releases."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:37
msgid "Eclipse *Cyclone DDS*"
msgstr "Eclipse *Cyclone DDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:38
msgid "Eclipse Public License v2.0"
msgstr "Eclipse Public License v2.0"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:39
msgid "``rmw_cyclonedds_cpp``"
msgstr "``rmw_cyclonedds_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:40
msgid "Full support. Packaged with binary releases."
msgstr "Full support. Packaged with binary releases."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:41
msgid "RTI *Connext DDS*"
msgstr "RTI *Connext DDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:42
msgid "commercial, research"
msgstr "commercial, research"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:43
msgid "``rmw_connextdds``"
msgstr "``rmw_connextdds``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:44
msgid "Full support. Support included in binaries, but Connext installed separately."
msgstr "Full support. Support included in binaries, but Connext installed separately."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:45
msgid "GurumNetworks *GurumDDS*"
msgstr "GurumNetworks *GurumDDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:46
msgid "commercial"
msgstr "commercial"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:47
msgid "``rmw_gurumdds_cpp``"
msgstr "``rmw_gurumdds_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:48
msgid "Community support. Support included in binaries, but GurumDDS installed separately."
msgstr "Community support. Support included in binaries, but GurumDDS installed separately."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:50
msgid "For practical information on working with multiple RMW implementations, see the :doc:`\"Working with multiple RMW implementations\" <../How-To-Guides/Working-with-multiple-RMW-implementations>` tutorial."
msgstr "For practical information on working with multiple RMW implementations, see the :doc:`\"Working with multiple RMW implementations\" <../How-To-Guides/Working-with-multiple-RMW-implementations>` tutorial."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:53
msgid "Multiple RMW implementations"
msgstr "Multiple RMW implementations"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:55
msgid "The ROS 2 binary releases for currently active distros have built-in support for several RMW implementations out of the box (Fast DDS, RTI Connext Pro, Eclipse Cyclone DDS, GurumNetworks GurumDDS). The default is Fast DDS, which works without any additional installation steps because we distribute it with our binary packages."
msgstr "The ROS 2 binary releases for currently active distros have built-in support for several RMW implementations out of the box (Fast DDS, RTI Connext Pro, Eclipse Cyclone DDS, GurumNetworks GurumDDS). The default is Fast DDS, which works without any additional installation steps because we distribute it with our binary packages."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:58
msgid "Other RMWs like Cyclone DDS, Connext or GurumDDS can be enabled by :doc:`installing additional packages <../Installation/DDS-Implementations>`, but without having to rebuild anything or replace any existing packages."
msgstr "Other RMWs like Cyclone DDS, Connext or GurumDDS can be enabled by :doc:`installing additional packages <../Installation/DDS-Implementations>`, but without having to rebuild anything or replace any existing packages."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:60
msgid "A ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously. While the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured. For example, if the code for the `RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__ is in the workspace, it will be built if an installation of RTI's Connext Pro can also be found."
msgstr "A ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously. While the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured. For example, if the code for the `RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__ is in the workspace, it will be built if an installation of RTI's Connext Pro can also be found."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:64
msgid "For many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances. Here is a list of inter-vendor communication configurations that are not supported:"
msgstr "For many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances. Here is a list of inter-vendor communication configurations that are not supported:"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:67
msgid "Fast DDS <-> Connext"
msgstr "Fast DDS <-> Connext"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:68
msgid "``WString`` published by Fast DDS can't be received correctly by Connext on macOS"
msgstr "``WString`` published by Fast DDS can't be received correctly by Connext on macOS"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:70
msgid "Connext <-> Cyclone DDS"
msgstr "Connext <-> Cyclone DDS"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:70
msgid "does not support pub/sub communication for ``WString``"
msgstr "does not support pub/sub communication for ``WString``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:73
msgid "Default RMW implementation"
msgstr "Default RMW implementation"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:75
msgid "If a ROS 2 workspace has multiple RMW implementations, Fast DDS is selected as the default RMW implementation if it is available. If the Fast DDS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used. The implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. ``rmw_cyclonedds_cpp``. For example, if both ``rmw_cyclonedds_cpp`` and ``rmw_connextdds`` ROS packages are installed, ``rmw_connextdds`` would be the default. If ``rmw_fastrtps_cpp`` is ever installed, it would be the default."
msgstr "If a ROS 2 workspace has multiple RMW implementations, Fast DDS is selected as the default RMW implementation if it is available. If the Fast DDS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used. The implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. ``rmw_cyclonedds_cpp``. For example, if both ``rmw_cyclonedds_cpp`` and ``rmw_connextdds`` ROS packages are installed, ``rmw_connextdds`` would be the default. If ``rmw_fastrtps_cpp`` is ever installed, it would be the default."


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:81
msgid "See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to specify which RMW implementation is to be used when running the ROS 2 examples."
msgstr "See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to specify which RMW implementation is to be used when running the ROS 2 examples."


#: ../../source/Concepts/About-Domain-ID.rst:3
msgid "The ROS_DOMAIN_ID"
msgstr "The ROS_DOMAIN_ID"


#: ../../source/Concepts/About-Domain-ID.rst:8
msgid "As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS. In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. All ROS 2 nodes use domain ID 0 by default. To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group."
msgstr "As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS. In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. All ROS 2 nodes use domain ID 0 by default. To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group."


#: ../../source/Concepts/About-Domain-ID.rst:15
msgid "Choosing a domain ID (short version)"
msgstr "Choosing a domain ID (short version)"


#: ../../source/Concepts/About-Domain-ID.rst:17
msgid "The text below explains the derivation of the range of domain IDs that should be used in ROS 2. To skip that background and just choose a safe number, simply choose a domain ID between 0 and 101, inclusive."
msgstr "The text below explains the derivation of the range of domain IDs that should be used in ROS 2. To skip that background and just choose a safe number, simply choose a domain ID between 0 and 101, inclusive."


#: ../../source/Concepts/About-Domain-ID.rst:22
msgid "Choosing a domain ID (long version)"
msgstr "Choosing a domain ID (long version)"


#: ../../source/Concepts/About-Domain-ID.rst:24
msgid "The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication. See `this article <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__ for details on how the ports are computed. Remembering our basic networking, the UDP port is an `unsigned 16-bit integer <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__. Thus, the highest port number that can be allocated is 65535. Doing some math with the formula in the article above, this means that the highest domain ID that can possibly be assigned is 232, while the lowest that can be assigned is 0."
msgstr "The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication. See `this article <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__ for details on how the ports are computed. Remembering our basic networking, the UDP port is an `unsigned 16-bit integer <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__. Thus, the highest port number that can be allocated is 65535. Doing some math with the formula in the article above, this means that the highest domain ID that can possibly be assigned is 232, while the lowest that can be assigned is 0."


#: ../../source/Concepts/About-Domain-ID.rst:31
msgid "Platform-specific constraints"
msgstr "Platform-specific constraints"


#: ../../source/Concepts/About-Domain-ID.rst:33
msgid "For maximum compatibility, some additional platform-specific constraints should be followed when choosing a domain ID. In particular, it is best to avoid allocating domain IDs in the operating system's `ephemeral port range <https://en.wikipedia.org/wiki/Ephemeral_port>`__. This avoids possible conflicts between the ports used by the ROS 2 nodes and other networking services on the computers."
msgstr "For maximum compatibility, some additional platform-specific constraints should be followed when choosing a domain ID. In particular, it is best to avoid allocating domain IDs in the operating system's `ephemeral port range <https://en.wikipedia.org/wiki/Ephemeral_port>`__. This avoids possible conflicts between the ports used by the ROS 2 nodes and other networking services on the computers."


#: ../../source/Concepts/About-Domain-ID.rst:37
msgid "Here are some platform-specific notes about ephemeral ports."
msgstr "Here are some platform-specific notes about ephemeral ports."


#: ../../source/Concepts/About-Domain-ID.rst:41
msgid "Linux"
msgstr "Linux"


#: ../../source/Concepts/About-Domain-ID.rst:43
msgid "By default, the Linux kernel uses ports 32768-60999 for ephemeral ports. This means that domain IDs 0-101 and 215-232 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Linux by setting custom values in ``/proc/sys/net/ipv4/ip_local_port_range``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "By default, the Linux kernel uses ports 32768-60999 for ephemeral ports. This means that domain IDs 0-101 and 215-232 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Linux by setting custom values in ``/proc/sys/net/ipv4/ip_local_port_range``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."


#: ../../source/Concepts/About-Domain-ID.rst:48
msgid "macOS"
msgstr "macOS"


#: ../../source/Concepts/About-Domain-ID.rst:50
msgid "By default, the ephemeral port range on macOS is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in macOS by setting custom sysctl values for ``net.inet.ip.portrange.first`` and ``net.inet.ip.portrange.last``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "By default, the ephemeral port range on macOS is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in macOS by setting custom sysctl values for ``net.inet.ip.portrange.first`` and ``net.inet.ip.portrange.last``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."


#: ../../source/Concepts/About-Domain-ID.rst:55
msgid "Windows"
msgstr "Windows"


#: ../../source/Concepts/About-Domain-ID.rst:57
msgid "By default, the ephemeral port range on Windows is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Windows by `using netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "By default, the ephemeral port range on Windows is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Windows by `using netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."


#: ../../source/Concepts/About-Domain-ID.rst:63
msgid "Participant constraints"
msgstr "Participant constraints"


#: ../../source/Concepts/About-Domain-ID.rst:65
msgid "For each ROS 2 process running on a computer, one DDS \"participant\" is created. Since each DDS participant takes up two ports on the computer, running more than 120 ROS 2 processes on one computer may spill over into other domain IDs or the ephemeral ports."
msgstr "For each ROS 2 process running on a computer, one DDS \"participant\" is created. Since each DDS participant takes up two ports on the computer, running more than 120 ROS 2 processes on one computer may spill over into other domain IDs or the ephemeral ports."


#: ../../source/Concepts/About-Domain-ID.rst:68
msgid "To see why, consider the domain IDs 1 and 2."
msgstr "To see why, consider the domain IDs 1 and 2."


#: ../../source/Concepts/About-Domain-ID.rst:70
msgid "Domain ID 1 uses port 7650 and 7651 for multicast."
msgstr "Domain ID 1 uses port 7650 and 7651 for multicast."


#: ../../source/Concepts/About-Domain-ID.rst:71
msgid "Domain ID 2 uses port 7900 and 7901 for multicast."
msgstr "Domain ID 2 uses port 7900 and 7901 for multicast."


#: ../../source/Concepts/About-Domain-ID.rst:72
msgid "When creating the 1st process (zeroth participant) in domain ID 1, the ports 7660 and 7661 are used for unicast."
msgstr "When creating the 1st process (zeroth participant) in domain ID 1, the ports 7660 and 7661 are used for unicast."


#: ../../source/Concepts/About-Domain-ID.rst:73
msgid "When creating the 120th process (119th participant) in domain ID 1, the ports 7898 and 7899 are used for unicast."
msgstr "When creating the 120th process (119th participant) in domain ID 1, the ports 7898 and 7899 are used for unicast."


#: ../../source/Concepts/About-Domain-ID.rst:74
msgid "When creating the 121st process (120th participant) in domain ID 1, the ports 7900 and 7901 are used for unicast and overlap with domain ID 2."
msgstr "When creating the 121st process (120th participant) in domain ID 1, the ports 7900 and 7901 are used for unicast and overlap with domain ID 2."


#: ../../source/Concepts/About-Domain-ID.rst:76
msgid "If it is known that the computer will only ever be on a single domain ID at a time, and the domain ID is low enough, it is safe to create more ROS 2 processes than this."
msgstr "If it is known that the computer will only ever be on a single domain ID at a time, and the domain ID is low enough, it is safe to create more ROS 2 processes than this."


#: ../../source/Concepts/About-Domain-ID.rst:78
msgid "When choosing a domain ID that is near the top of the range of platform-specific domain IDs, one additional constraint should be considered."
msgstr "When choosing a domain ID that is near the top of the range of platform-specific domain IDs, one additional constraint should be considered."


#: ../../source/Concepts/About-Domain-ID.rst:80
msgid "For instance, assume a Linux computer with a domain ID of 101:"
msgstr "For instance, assume a Linux computer with a domain ID of 101:"


#: ../../source/Concepts/About-Domain-ID.rst:82
msgid "The zero'th ROS 2 process on the computer will connect to ports 32650, 32651, 32660, and 32661."
msgstr "The zero'th ROS 2 process on the computer will connect to ports 32650, 32651, 32660, and 32661."


#: ../../source/Concepts/About-Domain-ID.rst:83
msgid "The first ROS 2 process on the computer will connect to ports 32650, 32651, 32662, and 32663."
msgstr "The first ROS 2 process on the computer will connect to ports 32650, 32651, 32662, and 32663."


#: ../../source/Concepts/About-Domain-ID.rst:84
msgid "The 53rd ROS 2 process on the computer will connect to ports 32650, 32651, 32766, and 32767."
msgstr "The 53rd ROS 2 process on the computer will connect to ports 32650, 32651, 32766, and 32767."


#: ../../source/Concepts/About-Domain-ID.rst:85
msgid "The 54th ROS 2 process on the computer will connect to ports 32650, 32651, 32768, and 32769, running into the ephemeral port range."
msgstr "The 54th ROS 2 process on the computer will connect to ports 32650, 32651, 32768, and 32769, running into the ephemeral port range."


#: ../../source/Concepts/About-Domain-ID.rst:87
msgid "Thus the maximum number of processes that should be created when using domain ID 101 on Linux is 54. Similarly, the maximum number of processes that should be created when using domain ID 232 on Linux is 63, as the maximum port number is 65535."
msgstr "Thus the maximum number of processes that should be created when using domain ID 101 on Linux is 54. Similarly, the maximum number of processes that should be created when using domain ID 232 on Linux is 63, as the maximum port number is 65535."


#: ../../source/Concepts/About-Domain-ID.rst:90
msgid "The situation is similar on macOS and Windows, though the numbers are different. On macOS and Windows, when choosing a domain ID of 166 (the top of the range), the maximum number of ROS 2 processes that can be created on a computer before running into the ephemeral port range is 120."
msgstr "The situation is similar on macOS and Windows, though the numbers are different. On macOS and Windows, when choosing a domain ID of 166 (the top of the range), the maximum number of ROS 2 processes that can be created on a computer before running into the ephemeral port range is 120."


#: ../../source/Concepts/About-Domain-ID.rst:94
msgid "Domain ID to UDP Port Calculator"
msgstr "Domain ID to UDP Port Calculator"


#: ../../source/Concepts/About-Executors.rst:4
msgid "Executors"
msgstr "Executors"


#: ../../source/Concepts/About-Executors.rst:12
msgid "Execution management in ROS 2 is explicated by the concept of Executors. An Executor uses one or more threads of the underlying operating system to invoke the callbacks of subscriptions, timers, service servers, action servers, etc. on incoming messages and events. The explicit Executor class (in `executor.hpp <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/executor.hpp>`_ in rclcpp, in `executors.py <https://github.com/ros2/rclpy/blob/humble/rclpy/rclpy/executors.py>`_ in rclpy, or in `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in rclc) provides more control over execution management than the spin mechanism in ROS 1, although the basic API is very similar."
msgstr "Execution management in ROS 2 is explicated by the concept of Executors. An Executor uses one or more threads of the underlying operating system to invoke the callbacks of subscriptions, timers, service servers, action servers, etc. on incoming messages and events. The explicit Executor class (in `executor.hpp <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/executor.hpp>`_ in rclcpp, in `executors.py <https://github.com/ros2/rclpy/blob/humble/rclpy/rclpy/executors.py>`_ in rclpy, or in `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in rclc) provides more control over execution management than the spin mechanism in ROS 1, although the basic API is very similar."


#: ../../source/Concepts/About-Executors.rst:16
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr "In the following, we focus on the C++ Client Library *rclcpp*."


#: ../../source/Concepts/About-Executors.rst:19
msgid "Basic use"
msgstr "Basic use"


#: ../../source/Concepts/About-Executors.rst:21
msgid "In the simplest case, the main thread is used for processing the incoming messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:"
msgstr "In the simplest case, the main thread is used for processing the incoming messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:"


#: ../../source/Concepts/About-Executors.rst:42
msgid "The call to ``spin(node)`` basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor:"
msgstr "The call to ``spin(node)`` basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor:"


#: ../../source/Concepts/About-Executors.rst:50
msgid "By invoking ``spin()`` of the Executor instance, the current thread starts querying the rcl and middleware layers for incoming messages and other events and calls the corresponding callback functions until the node shuts down. In order not to counteract the QoS settings of the middleware, an incoming message is not stored in a queue on the Client Library layer but kept in the middleware until it is taken for processing by a callback function. (This is a crucial difference to ROS 1.) A *wait set* is used to inform the Executor about available messages on the middleware layer, with one binary flag per queue. The *wait set* is also used to detect when timers expire."
msgstr "By invoking ``spin()`` of the Executor instance, the current thread starts querying the rcl and middleware layers for incoming messages and other events and calls the corresponding callback functions until the node shuts down. In order not to counteract the QoS settings of the middleware, an incoming message is not stored in a queue on the Client Library layer but kept in the middleware until it is taken for processing by a callback function. (This is a crucial difference to ROS 1.) A *wait set* is used to inform the Executor about available messages on the middleware layer, with one binary flag per queue. The *wait set* is also used to detect when timers expire."


#: ../../source/Concepts/About-Executors.rst:58
msgid "The Single-Threaded Executor is also used by the container process for :doc:`components <./About-Composition>`, i.e. in all cases where nodes are created and executed without an explicit main function."
msgstr "The Single-Threaded Executor is also used by the container process for :doc:`components <./About-Composition>`, i.e. in all cases where nodes are created and executed without an explicit main function."


#: ../../source/Concepts/About-Executors.rst:61
msgid "Types of Executors"
msgstr "Types of Executors"


#: ../../source/Concepts/About-Executors.rst:63
msgid "Currently, rclcpp provides three Executor types, derived from a shared parent class:"
msgstr "Currently, rclcpp provides three Executor types, derived from a shared parent class:"


#: ../../source/Concepts/About-Executors.rst:79
msgid "The *Multi-Threaded Executor* creates a configurable number of threads to allow for processing multiple messages or events in parallel. The *Static Single-Threaded Executor* optimizes the runtime costs for scanning the structure of a node in terms of subscriptions, timers, service servers, action servers, etc. It performs this scan only once when the node is added, while the other two executors regularly scan for such changes. Therefore, the Static Single-Threaded Executor should be used only with nodes that create all subscriptions, timers, etc. during initialization."
msgstr "The *Multi-Threaded Executor* creates a configurable number of threads to allow for processing multiple messages or events in parallel. The *Static Single-Threaded Executor* optimizes the runtime costs for scanning the structure of a node in terms of subscriptions, timers, service servers, action servers, etc. It performs this scan only once when the node is added, while the other two executors regularly scan for such changes. Therefore, the Static Single-Threaded Executor should be used only with nodes that create all subscriptions, timers, etc. during initialization."


#: ../../source/Concepts/About-Executors.rst:84
msgid "All three executors can be used with multiple nodes by calling ``add_node(..)`` for each node."
msgstr "All three executors can be used with multiple nodes by calling ``add_node(..)`` for each node."


#: ../../source/Concepts/About-Executors.rst:98
msgid "In the above example, the one thread of a Static Single-Threaded Executor is used to serve three nodes together. In case of a Multi-Threaded Executor, the actual parallelism depends on the callback groups."
msgstr "In the above example, the one thread of a Static Single-Threaded Executor is used to serve three nodes together. In case of a Multi-Threaded Executor, the actual parallelism depends on the callback groups."


#: ../../source/Concepts/About-Executors.rst:102
msgid "Callback groups"
msgstr "Callback groups"


#: ../../source/Concepts/About-Executors.rst:104
msgid "ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a *callback group* can be created by the ``create_callback_group`` function of the Node class. In rclpy, the same is done by calling the constructor of the specific callback group type. The callback group must be stored throughout execution of the node (eg. as a class member), or otherwise the executor won't be able to trigger the callbacks. Then, this callback group can be specified when creating a subscription, timer, etc. - for example by the subscription options:"
msgstr "ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a *callback group* can be created by the ``create_callback_group`` function of the Node class. In rclpy, the same is done by calling the constructor of the specific callback group type. The callback group must be stored throughout execution of the node (eg. as a class member), or otherwise the executor won't be able to trigger the callbacks. Then, this callback group can be specified when creating a subscription, timer, etc. - for example by the subscription options:"


#: ../../source/Concepts/About-Executors.rst:112 ../../source/Concepts/About-Logging.rst:49 ../../source/Concepts/About-Logging.rst:185
msgid "C++"
msgstr "C++"


#: ../../source/Concepts/About-Executors.rst:123 ../../source/Concepts/About-Logging.rst:72 ../../source/Concepts/About-Logging.rst:191
msgid "Python"
msgstr "Python"


#: ../../source/Concepts/About-Executors.rst:131
msgid "All subscriptions, timers, etc. that are created without the indication of a callback group are assigned to the *default callback group*. The default callback group can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by ``Node.default_callback_group`` in rclpy."
msgstr "All subscriptions, timers, etc. that are created without the indication of a callback group are assigned to the *default callback group*. The default callback group can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by ``Node.default_callback_group`` in rclpy."


#: ../../source/Concepts/About-Executors.rst:135
msgid "There are two types of callback groups, where the type has to be specified at instantiation time:"
msgstr "There are two types of callback groups, where the type has to be specified at instantiation time:"


#: ../../source/Concepts/About-Executors.rst:137
msgid "*Mutually exclusive:* Callbacks of this group must not be executed in parallel."
msgstr "*Mutually exclusive:* Callbacks of this group must not be executed in parallel."


#: ../../source/Concepts/About-Executors.rst:138
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr "*Reentrant:* Callbacks of this group may be executed in parallel."


#: ../../source/Concepts/About-Executors.rst:140
msgid "Callbacks of different callback groups may always be executed in parallel. The Multi-Threaded Executor uses its threads as a pool to process as many callbacks as possible in parallel according to these conditions. For tips on how to use callback groups efficiently, see :doc:`Using Callback Groups <../How-To-Guides/Using-callback-groups>`."
msgstr "Callbacks of different callback groups may always be executed in parallel. The Multi-Threaded Executor uses its threads as a pool to process as many callbacks as possible in parallel according to these conditions. For tips on how to use callback groups efficiently, see :doc:`Using Callback Groups <../How-To-Guides/Using-callback-groups>`."


#: ../../source/Concepts/About-Executors.rst:144
msgid "The Executor base class in rclcpp also has the function ``add_callback_group(..)``, which allows distributing callback groups to different Executors. By configuring the underlying threads using the operating system scheduler, specific callbacks can be prioritized over other callbacks. For example, the subscriptions and timers of a control loop can be prioritized over all other subscriptions and standard services of a node. The `examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/humble/rclcpp/executors/cbg_executor>`_ provides a demo of this mechanism."
msgstr "The Executor base class in rclcpp also has the function ``add_callback_group(..)``, which allows distributing callback groups to different Executors. By configuring the underlying threads using the operating system scheduler, specific callbacks can be prioritized over other callbacks. For example, the subscriptions and timers of a control loop can be prioritized over all other subscriptions and standard services of a node. The `examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/humble/rclcpp/executors/cbg_executor>`_ provides a demo of this mechanism."


#: ../../source/Concepts/About-Executors.rst:150
msgid "Scheduling semantics"
msgstr "Scheduling semantics"


#: ../../source/Concepts/About-Executors.rst:152
msgid "If the processing time of the callbacks is shorter than the period with which messages and events occur, the Executor basically processes them in FIFO order. However, if the processing time of some callbacks is longer, messages and events will be queued on the lower layers of the stack. The wait set mechanism reports only very little information about these queues to the Executor. In detail, it only reports whether there are any messages for a certain topic or not. The Executor uses this information to process the messages (including services and actions) in a round-robin fashion - but not in FIFO order. The following flow diagram visualizes this scheduling semantics."
msgstr "If the processing time of the callbacks is shorter than the period with which messages and events occur, the Executor basically processes them in FIFO order. However, if the processing time of some callbacks is longer, messages and events will be queued on the lower layers of the stack. The wait set mechanism reports only very little information about these queues to the Executor. In detail, it only reports whether there are any messages for a certain topic or not. The Executor uses this information to process the messages (including services and actions) in a round-robin fashion - but not in FIFO order. The following flow diagram visualizes this scheduling semantics."


#: ../../source/Concepts/About-Executors.rst:161
msgid "This semantics was first described in a `paper by Casini et al. at ECRTS 2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are prioritized over all other messages. `This prioritization was removed in Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr "This semantics was first described in a `paper by Casini et al. at ECRTS 2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are prioritized over all other messages. `This prioritization was removed in Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"


#: ../../source/Concepts/About-Executors.rst:166
msgid "Outlook"
msgstr "Outlook"


#: ../../source/Concepts/About-Executors.rst:168
msgid "While the three Executors of rclcpp work well for most applications, there are some issues that make them not suitable for real-time applications, which require well-defined execution times, determinism, and custom control over the execution order. Here is a summary of some of these issues:"
msgstr "While the three Executors of rclcpp work well for most applications, there are some issues that make them not suitable for real-time applications, which require well-defined execution times, determinism, and custom control over the execution order. Here is a summary of some of these issues:"


#: ../../source/Concepts/About-Executors.rst:171
msgid "Complex and mixed scheduling semantics. Ideally you want well defined scheduling semantics to perform a formal timing analysis."
msgstr "Complex and mixed scheduling semantics. Ideally you want well defined scheduling semantics to perform a formal timing analysis."


#: ../../source/Concepts/About-Executors.rst:173
msgid "Callbacks may suffer from priority inversion. Higher priority callbacks may be blocked by lower priority callbacks."
msgstr "Callbacks may suffer from priority inversion. Higher priority callbacks may be blocked by lower priority callbacks."


#: ../../source/Concepts/About-Executors.rst:175
msgid "No explicit control over the callbacks execution order."
msgstr "No explicit control over the callbacks execution order."


#: ../../source/Concepts/About-Executors.rst:176
msgid "No built-in control over triggering for specific topics."
msgstr "No built-in control over triggering for specific topics."


#: ../../source/Concepts/About-Executors.rst:178
msgid "Additionally, the executor overhead in terms of CPU and memory usage is considerable. The Static Single-Threaded Executor reduces this overhead greatly but it might not be enough for some applications."
msgstr "Additionally, the executor overhead in terms of CPU and memory usage is considerable. The Static Single-Threaded Executor reduces this overhead greatly but it might not be enough for some applications."


#: ../../source/Concepts/About-Executors.rst:181
msgid "These issues have been partially addressed by the following developments:"
msgstr "These issues have been partially addressed by the following developments:"


#: ../../source/Concepts/About-Executors.rst:183
msgid "`rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/wait_set.hpp>`_: The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, timers, service servers, action servers, etc. instead of using an Executor. It can be used to implement deterministic, user-defined processing sequences, possibly processing multiple messages from different subscriptions together. The `examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/humble/rclcpp/wait_set>`_ provides several examples for the use of this user-level wait set mechanism."
msgstr "`rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/wait_set.hpp>`_: The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, timers, service servers, action servers, etc. instead of using an Executor. It can be used to implement deterministic, user-defined processing sequences, possibly processing multiple messages from different subscriptions together. The `examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/humble/rclcpp/wait_set>`_ provides several examples for the use of this user-level wait set mechanism."


#: ../../source/Concepts/About-Executors.rst:186
msgid "`rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: This Executor from the C Client Library *rclc*, developed for micro-ROS, gives the user fine-grained control over the execution order of callbacks and allows for custom trigger conditions to activate callbacks. Furthermore, it implements ideas of the Logical Execution Time (LET) semantics."
msgstr "`rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: This Executor from the C Client Library *rclc*, developed for micro-ROS, gives the user fine-grained control over the execution order of callbacks and allows for custom trigger conditions to activate callbacks. Furthermore, it implements ideas of the Logical Execution Time (LET) semantics."


#: ../../source/Concepts/About-Executors.rst:190
msgid "Further information"
msgstr "Further information"


#: ../../source/Concepts/About-Executors.rst:192
msgid "Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at ROS World 2021. Virtual event. 19 October 2021."
msgstr "Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at ROS World 2021. Virtual event. 19 October 2021."


#: ../../source/Concepts/About-Executors.rst:193
msgid "Ralph Lange: `\"Advanced Execution Management with ROS 2\" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference. Virtual event. 16 December 2020."
msgstr "Ralph Lange: `\"Advanced Execution Management with ROS 2\" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference. Virtual event. 16 December 2020."


#: ../../source/Concepts/About-Executors.rst:194
msgid "Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: `“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July 2019."
msgstr "Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: `“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July 2019."


#: ../../source/Concepts/About-Internal-Interfaces.rst:2
msgid "About internal ROS 2 interfaces"
msgstr "About internal ROS 2 interfaces"


#: ../../source/Concepts/About-Internal-Interfaces.rst:6
msgid "The internal ROS interfaces are public C |APIs| that are intended for use by developers who are creating |client libraries| or adding a new underlying middleware, but are not intended for use by typical ROS users. The ROS |client libraries| provide the user facing |APIs| that most ROS users are familiar with, and may come in a variety of programming languages."
msgstr "The internal ROS interfaces are public C |APIs| that are intended for use by developers who are creating |client libraries| or adding a new underlying middleware, but are not intended for use by typical ROS users. The ROS |client libraries| provide the user facing |APIs| that most ROS users are familiar with, and may come in a variety of programming languages."


#: ../../source/Concepts/About-Internal-Interfaces.rst:10
msgid "Internal API Architecture Overview"
msgstr "Internal API Architecture Overview"


#: ../../source/Concepts/About-Internal-Interfaces.rst:12
msgid "There are two main internal interfaces:"
msgstr "There are two main internal interfaces:"


#: ../../source/Concepts/About-Internal-Interfaces.rst:14
msgid "the ROS middleware interface (``rmw`` |API|)"
msgstr "the ROS middleware interface (``rmw`` |API|)"


#: ../../source/Concepts/About-Internal-Interfaces.rst:15
msgid "the ROS client library interface (``rcl`` |API|)"
msgstr "the ROS client library interface (``rcl`` |API|)"


#: ../../source/Concepts/About-Internal-Interfaces.rst:17
msgid "The ``rmw`` |API| is the interface between the ROS 2 software stack and the underlying middleware implementation. The underlying middleware used for ROS 2 is either a DDS or RTPS implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types."
msgstr "The ``rmw`` |API| is the interface between the ROS 2 software stack and the underlying middleware implementation. The underlying middleware used for ROS 2 is either a DDS or RTPS implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types."


#: ../../source/Concepts/About-Internal-Interfaces.rst:20
msgid "The ``rcl`` |API| is a slightly higher level |API| which is used to implement the |client libraries| and does not touch the middleware implementation directly, but rather does so through the ROS middleware interface (``rmw`` |API|) abstraction."
msgstr "The ``rcl`` |API| is a slightly higher level |API| which is used to implement the |client libraries| and does not touch the middleware implementation directly, but rather does so through the ROS middleware interface (``rmw`` |API|) abstraction."


msgid "ros2 software stack"
msgstr "ros2 software stack"


#: ../../source/Concepts/About-Internal-Interfaces.rst:25
msgid "As the diagram shows, these |APIs| are stacked such that the typical ROS user will use the |client library| |API|, e.g. ``rclcpp``, to implement their code (executable or library). The implementation of the |client libraries|, e.g. ``rclcpp``, use the ``rcl`` interface which provides access to the ROS graph and graph events. The ``rcl`` implementation in turn uses the ``rmw`` |API| to access the ROS graph. The purpose of the ``rcl`` implementation is to provide a common implementation for more complex ROS concepts and utilities that may be used by various |client libraries|, while remaining agnostic to the underlying middleware being used. The purpose of the ``rmw`` interface is to capture the absolute minimum middleware functionality needed to support ROS's client libraries. Finally, the implementation of the ``rmw`` |API| is provided by a middleware implementation specific |package|, e.g. ``rmw_fastrtps_cpp``, the library of which is compiled against vendor specific DDS interfaces and types."
msgstr "As the diagram shows, these |APIs| are stacked such that the typical ROS user will use the |client library| |API|, e.g. ``rclcpp``, to implement their code (executable or library). The implementation of the |client libraries|, e.g. ``rclcpp``, use the ``rcl`` interface which provides access to the ROS graph and graph events. The ``rcl`` implementation in turn uses the ``rmw`` |API| to access the ROS graph. The purpose of the ``rcl`` implementation is to provide a common implementation for more complex ROS concepts and utilities that may be used by various |client libraries|, while remaining agnostic to the underlying middleware being used. The purpose of the ``rmw`` interface is to capture the absolute minimum middleware functionality needed to support ROS's client libraries. Finally, the implementation of the ``rmw`` |API| is provided by a middleware implementation specific |package|, e.g. ``rmw_fastrtps_cpp``, the library of which is compiled against vendor specific DDS interfaces and types."


#: ../../source/Concepts/About-Internal-Interfaces.rst:32
msgid "In the diagram above there is also a box labeled ``ros_to_dds``, and the purpose of this box is to represent a category of possible packages which allow the user to access DDS vendor specific objects and settings using the ROS equivalents. One of the goals of this abstraction interface is to completely insulate the ROS user space code from the middleware being used, so that changing DDS vendors or even middleware technology has a minimal impact on the users code. However, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have. By requiring the use of one of these packages in order to access the underlying DDS vendor's objects, we can avoid exposing vendor specific symbols and headers in the normal interface. It also makes it easy to see what code is potentially violating the vendor portability by inspecting the package's dependencies to see if one of these ``ros_to_dds`` packages are being used."
msgstr "In the diagram above there is also a box labeled ``ros_to_dds``, and the purpose of this box is to represent a category of possible packages which allow the user to access DDS vendor specific objects and settings using the ROS equivalents. One of the goals of this abstraction interface is to completely insulate the ROS user space code from the middleware being used, so that changing DDS vendors or even middleware technology has a minimal impact on the users code. However, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have. By requiring the use of one of these packages in order to access the underlying DDS vendor's objects, we can avoid exposing vendor specific symbols and headers in the normal interface. It also makes it easy to see what code is potentially violating the vendor portability by inspecting the package's dependencies to see if one of these ``ros_to_dds`` packages are being used."


#: ../../source/Concepts/About-Internal-Interfaces.rst:41
msgid "Type Specific Interfaces"
msgstr "Type Specific Interfaces"


#: ../../source/Concepts/About-Internal-Interfaces.rst:43
msgid "All along the way there are some parts of the |APIs| that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type. The following diagram layouts the path from user defined ``rosidl`` files, e.g. ``.msg`` files, to the type specific code used by the user and system to perform type specific functions:"
msgstr "All along the way there are some parts of the |APIs| that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type. The following diagram layouts the path from user defined ``rosidl`` files, e.g. ``.msg`` files, to the type specific code used by the user and system to perform type specific functions:"


#: ../../source/Concepts/About-Internal-Interfaces.rst:49
msgid "ros2 idl static type support stack"
msgstr "ros2 idl static type support stack"


#: ../../source/Concepts/About-Internal-Interfaces.rst:49
msgid "Figure: flow chart of \"static\" type support generation, from ``rosidl`` files to user facing code."
msgstr "Figure: flow chart of \"static\" type support generation, from ``rosidl`` files to user facing code."


#: ../../source/Concepts/About-Internal-Interfaces.rst:51
msgid "The right hand side of the diagram shows how the ``.msg`` files are passed directly to language specific code generators, e.g. ``rosidl_generator_cpp`` or ``rosidl_generator_py``. These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the ``.msg`` files. For example, consider the message ``std_msgs/String``, a user might use this file in C++ with the statement ``#include <std_msgs/msg/string.hpp>``, or they might use the statement ``from std_msgs.msg import String`` in Python. These statements work because of the files generated by these language specific (but middleware agnostic) generator packages."
msgstr "The right hand side of the diagram shows how the ``.msg`` files are passed directly to language specific code generators, e.g. ``rosidl_generator_cpp`` or ``rosidl_generator_py``. These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the ``.msg`` files. For example, consider the message ``std_msgs/String``, a user might use this file in C++ with the statement ``#include <std_msgs/msg/string.hpp>``, or they might use the statement ``from std_msgs.msg import String`` in Python. These statements work because of the files generated by these language specific (but middleware agnostic) generator packages."


#: ../../source/Concepts/About-Internal-Interfaces.rst:56
msgid "Separately, the ``.msg`` files are used to generate type support code for each type. In this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. The type support for a given message might include things like a list of the names and types for each field in the message. It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message."
msgstr "Separately, the ``.msg`` files are used to generate type support code for each type. In this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. The type support for a given message might include things like a list of the names and types for each field in the message. It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message."


#: ../../source/Concepts/About-Internal-Interfaces.rst:62
msgid "Static Type Support"
msgstr "Static Type Support"


#: ../../source/Concepts/About-Internal-Interfaces.rst:64
msgid "When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. For example, consider the type specific publish function, when using \"vendor A\" the function will need to call some of \"vendor A\"'s |API|, but when using \"vendor B\" it will need to call \"vendor B\"'s |API|. To allow for middleware vendor specific code, the user defined ``.msg`` files may result in the generation of vendor specific code. This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the \"Private Implementation\" (or Pimpl) pattern works."
msgstr "When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. For example, consider the type specific publish function, when using \"vendor A\" the function will need to call some of \"vendor A\"'s |API|, but when using \"vendor B\" it will need to call \"vendor B\"'s |API|. To allow for middleware vendor specific code, the user defined ``.msg`` files may result in the generation of vendor specific code. This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the \"Private Implementation\" (or Pimpl) pattern works."


#: ../../source/Concepts/About-Internal-Interfaces.rst:70
msgid "Static Type Support with DDS"
msgstr "Static Type Support with DDS"


#: ../../source/Concepts/About-Internal-Interfaces.rst:72
msgid "For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (``.idl`` files), the user defined ``rosidl`` files (``.msg`` files) are converted into equivalent OMG IDL files (``.idl`` files). From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. The above diagram shows this on the left hand side, where the ``.msg`` files are consumed by the ``rosidl_dds`` package to produce ``.idl`` files, and then those ``.idl`` files are given to language specific and DDS vendor specific type support generation packages."
msgstr "For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (``.idl`` files), the user defined ``rosidl`` files (``.msg`` files) are converted into equivalent OMG IDL files (``.idl`` files). From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. The above diagram shows this on the left hand side, where the ``.msg`` files are consumed by the ``rosidl_dds`` package to produce ``.idl`` files, and then those ``.idl`` files are given to language specific and DDS vendor specific type support generation packages."


#: ../../source/Concepts/About-Internal-Interfaces.rst:76
msgid "For example, consider the Fast DDS implementation, which has a package called ``rosidl_typesupport_fastrtps_cpp``. This package is responsible for generating code to handle things like converting a C++ message object into a serialized octet buffer to be written over the network. This code, while specific to Fast DDS, is still not exposed to the user because of the abstraction in the type support code."
msgstr "For example, consider the Fast DDS implementation, which has a package called ``rosidl_typesupport_fastrtps_cpp``. This package is responsible for generating code to handle things like converting a C++ message object into a serialized octet buffer to be written over the network. This code, while specific to Fast DDS, is still not exposed to the user because of the abstraction in the type support code."


#: ../../source/Concepts/About-Internal-Interfaces.rst:81
msgid "Dynamic Type Support"
msgstr "Dynamic Type Support"


#: ../../source/Concepts/About-Internal-Interfaces.rst:83
msgid "Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type. Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type. This is referred to as \"dynamic\" type support, as opposed to \"static\" type support which requires generated versions of a function for each type."
msgstr "Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type. Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type. This is referred to as \"dynamic\" type support, as opposed to \"static\" type support which requires generated versions of a function for each type."


#: ../../source/Concepts/About-Internal-Interfaces.rst:91
msgid "ros2 idl dynamic type support stack"
msgstr "ros2 idl dynamic type support stack"


#: ../../source/Concepts/About-Internal-Interfaces.rst:91
msgid "Figure: flow chart of \"dynamic\" type support generation, from ``rosidl`` files to user facing code."
msgstr "Figure: flow chart of \"dynamic\" type support generation, from ``rosidl`` files to user facing code."


#: ../../source/Concepts/About-Internal-Interfaces.rst:93
msgid "The above diagram shows the flow from user defined ``rosidl`` files to generated user facing code. It is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram. In dynamic type support the ``.msg`` files are converted directly into user facing code."
msgstr "The above diagram shows the flow from user defined ``rosidl`` files to generated user facing code. It is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram. In dynamic type support the ``.msg`` files are converted directly into user facing code."


#: ../../source/Concepts/About-Internal-Interfaces.rst:97
msgid "This code is also middleware agnostic, because it only contains meta information about the messages. The function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific |APIs|. Note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. ``rosidl_typesupport_introspection_c`` and ``rosidl_typesupport_introspection_cpp``. The ``introspection`` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. This is the fundamental capability that allows for generic implementations of functions like \"publish to a topic\"."
msgstr "This code is also middleware agnostic, because it only contains meta information about the messages. The function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific |APIs|. Note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. ``rosidl_typesupport_introspection_c`` and ``rosidl_typesupport_introspection_cpp``. The ``introspection`` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. This is the fundamental capability that allows for generic implementations of functions like \"publish to a topic\"."


#: ../../source/Concepts/About-Internal-Interfaces.rst:103
msgid "This approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support. It also results in less generated code, which reduces compile time and code size."
msgstr "This approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support. It also results in less generated code, which reduces compile time and code size."


#: ../../source/Concepts/About-Internal-Interfaces.rst:106
msgid "However, dynamic type support requires that the underlying middleware support a similar form of dynamic type support. In the case of DDS the DDS-XTypes standard allows for publishing of messages using meta information rather than generated code. DDS-XTypes, or something like it, is required in the underlying middleware in order to support dynamic type support. Also, this approach to type support is normally slower than the static type support alternative. The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type's meta data to perform things like serialization."
msgstr "However, dynamic type support requires that the underlying middleware support a similar form of dynamic type support. In the case of DDS the DDS-XTypes standard allows for publishing of messages using meta information rather than generated code. DDS-XTypes, or something like it, is required in the underlying middleware in order to support dynamic type support. Also, this approach to type support is normally slower than the static type support alternative. The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type's meta data to perform things like serialization."


#: ../../source/Concepts/About-Internal-Interfaces.rst:113
msgid "The ``rcl`` Repository"
msgstr "The ``rcl`` Repository"


#: ../../source/Concepts/About-Internal-Interfaces.rst:115
msgid "The ROS Client Library interface (``rcl`` |API|) can be used by |client libraries| (e.g. ``rclc``, ``rclcpp``, ``rclpy``, etc.) in order to avoid duplicating logic and features. By reusing the ``rcl`` |API|, client libraries can be smaller and more consistent with each other. Some parts of the client library are intentionally left out of the ``rcl`` |API| because the language idiomatic method should be used to implement those parts of the system. A good example of this is the execution model, which ``rcl`` does not address at all. Instead the client library should provide a language idiomatic solution like ``pthreads`` in C, ``std::thread`` in C++11, and ``threading.Thread`` in Python. Generally the ``rcl`` interface provides functions that are not specific to a language pattern and are not specific to a particular message type."
msgstr "The ROS Client Library interface (``rcl`` |API|) can be used by |client libraries| (e.g. ``rclc``, ``rclcpp``, ``rclpy``, etc.) in order to avoid duplicating logic and features. By reusing the ``rcl`` |API|, client libraries can be smaller and more consistent with each other. Some parts of the client library are intentionally left out of the ``rcl`` |API| because the language idiomatic method should be used to implement those parts of the system. A good example of this is the execution model, which ``rcl`` does not address at all. Instead the client library should provide a language idiomatic solution like ``pthreads`` in C, ``std::thread`` in C++11, and ``threading.Thread`` in Python. Generally the ``rcl`` interface provides functions that are not specific to a language pattern and are not specific to a particular message type."


#: ../../source/Concepts/About-Internal-Interfaces.rst:122
msgid "The ``rcl`` |API| is located in the `ros2/rcl <https://github.com/ros2/rcl>`_ repository on |GitHub|_ and contains the interface as C headers. The ``rcl`` C implementation is provided by the ``rcl`` |package| in the same repository. This implementation avoids direct contact with the middleware by instead using the ``rmw`` and ``rosidl`` |APIs|."
msgstr "The ``rcl`` |API| is located in the `ros2/rcl <https://github.com/ros2/rcl>`_ repository on |GitHub|_ and contains the interface as C headers. The ``rcl`` C implementation is provided by the ``rcl`` |package| in the same repository. This implementation avoids direct contact with the middleware by instead using the ``rmw`` and ``rosidl`` |APIs|."


#: ../../source/Concepts/About-Internal-Interfaces.rst:126
msgid "For a complete definition of the ``rcl`` |API|, see `the rcl docs <http://docs.ros.org/en/humble/p/rcl/>`_."
msgstr "For a complete definition of the ``rcl`` |API|, see `the rcl docs <http://docs.ros.org/en/humble/p/rcl/>`_."


#: ../../source/Concepts/About-Internal-Interfaces.rst:129
msgid "The ``rmw`` Repository"
msgstr "The ``rmw`` Repository"


#: ../../source/Concepts/About-Internal-Interfaces.rst:131
msgid "The ROS middleware interface (``rmw`` |API|) is the minimal set of primitive middleware capabilities needed to build ROS on top. Providers of different middleware implementations must implement this interface in order to support the entire ROS stack on top. Currently all of the middleware implementations are for different DDS vendors."
msgstr "The ROS middleware interface (``rmw`` |API|) is the minimal set of primitive middleware capabilities needed to build ROS on top. Providers of different middleware implementations must implement this interface in order to support the entire ROS stack on top. Currently all of the middleware implementations are for different DDS vendors."


#: ../../source/Concepts/About-Internal-Interfaces.rst:135
msgid "The ``rmw`` |API| is located in the `ros2/rmw <https://github.com/ros2/rmw>`_ repository. The ``rmw`` |package| contains the C headers which define the interface, the implementation of which is provided by the various |packages| of rmw implementations for different DDS vendors."
msgstr "The ``rmw`` |API| is located in the `ros2/rmw <https://github.com/ros2/rmw>`_ repository. The ``rmw`` |package| contains the C headers which define the interface, the implementation of which is provided by the various |packages| of rmw implementations for different DDS vendors."


#: ../../source/Concepts/About-Internal-Interfaces.rst:138
msgid "For a definition of the ``rmw`` |API|, see `the rmw docs <http://docs.ros.org/en/humble/p/rmw/>`_."
msgstr "For a definition of the ``rmw`` |API|, see `the rmw docs <http://docs.ros.org/en/humble/p/rmw/>`_."


#: ../../source/Concepts/About-Internal-Interfaces.rst:142
msgid "The ``rosidl`` Repository"
msgstr "The ``rosidl`` Repository"


#: ../../source/Concepts/About-Internal-Interfaces.rst:144
msgid "The ``rosidl`` |API| consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages. The generated message code specified in the |API| will be language specific, but may or may not reuse generated code for other languages. The generated message code specified in the |API| contains things like the message data structure, functions for construction, destruction, etc. The |API| will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type."
msgstr "The ``rosidl`` |API| consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages. The generated message code specified in the |API| will be language specific, but may or may not reuse generated code for other languages. The generated message code specified in the |API| contains things like the message data structure, functions for construction, destruction, etc. The |API| will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type."


#: ../../source/Concepts/About-Internal-Interfaces.rst:149
msgid "There are several repositories that play a role in the ``rosidl`` |API| and implementation."
msgstr "There are several repositories that play a role in the ``rosidl`` |API| and implementation."


#: ../../source/Concepts/About-Internal-Interfaces.rst:151
msgid "The ``rosidl`` repository, located on |GitHub|_ at `ros2/rosidl <https://github.com/ros2/rosidl>`_, defines the message IDL syntax, i.e. syntax of ``.msg`` files, ``.srv`` files, etc., and contains |packages| for parsing the files, for providing CMake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators. The repository contains these |packages|:"
msgstr "The ``rosidl`` repository, located on |GitHub|_ at `ros2/rosidl <https://github.com/ros2/rosidl>`_, defines the message IDL syntax, i.e. syntax of ``.msg`` files, ``.srv`` files, etc., and contains |packages| for parsing the files, for providing CMake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators. The repository contains these |packages|:"


#: ../../source/Concepts/About-Internal-Interfaces.rst:154
msgid "``rosidl_cmake``: provides CMake functions and modules for generating code from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr "``rosidl_cmake``: provides CMake functions and modules for generating code from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."


#: ../../source/Concepts/About-Internal-Interfaces.rst:155
msgid "``rosidl_default_generators``: defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used."
msgstr "``rosidl_default_generators``: defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used."


#: ../../source/Concepts/About-Internal-Interfaces.rst:156
msgid "``rosidl_generator_c``: provides tools to generate C header files (``.h``) for ``rosidl`` files."
msgstr "``rosidl_generator_c``: provides tools to generate C header files (``.h``) for ``rosidl`` files."


#: ../../source/Concepts/About-Internal-Interfaces.rst:157
msgid "``rosidl_generator_cpp``: provides tools to generate C++ header files (``.hpp``) for ``rosidl`` files."
msgstr "``rosidl_generator_cpp``: provides tools to generate C++ header files (``.hpp``) for ``rosidl`` files."


#: ../../source/Concepts/About-Internal-Interfaces.rst:158
msgid "``rosidl_generator_py``: provides tools to generate Python modules for ``rosidl`` files."
msgstr "``rosidl_generator_py``: provides tools to generate Python modules for ``rosidl`` files."


#: ../../source/Concepts/About-Internal-Interfaces.rst:159
msgid "``rosidl_parser``: provides Python |API| for parsing ``rosidl`` files."
msgstr "``rosidl_parser``: provides Python |API| for parsing ``rosidl`` files."


#: ../../source/Concepts/About-Internal-Interfaces.rst:161
msgid "Generators for other languages, e.g. ``rosidl_generator_java``, are hosted externally (in different repositories) but would use the same mechanism that the above generators use to \"register\" themselves as a ``rosidl`` generator."
msgstr "Generators for other languages, e.g. ``rosidl_generator_java``, are hosted externally (in different repositories) but would use the same mechanism that the above generators use to \"register\" themselves as a ``rosidl`` generator."


#: ../../source/Concepts/About-Internal-Interfaces.rst:163
msgid "In addition to the aforementioned |packages| for parsing and generating headers for the ``rosidl`` files, the ``rosidl`` repository also contains |packages| concerned with \"type support\" for the message types defined in the files. Type support refers to the ability to interpret and manipulate the information represented by ROS message instances of particular types (publishing the messages, for example). Type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the ``rosidl`` file, e.g. the ``.msg`` or ``.srv`` file, and the data received, by introspecting the data. In the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ROS 2 can be agnostic to the rmw implementation. The packages that provide this type support through introspection of the data are:"
msgstr "In addition to the aforementioned |packages| for parsing and generating headers for the ``rosidl`` files, the ``rosidl`` repository also contains |packages| concerned with \"type support\" for the message types defined in the files. Type support refers to the ability to interpret and manipulate the information represented by ROS message instances of particular types (publishing the messages, for example). Type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the ``rosidl`` file, e.g. the ``.msg`` or ``.srv`` file, and the data received, by introspecting the data. In the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ROS 2 can be agnostic to the rmw implementation. The packages that provide this type support through introspection of the data are:"


#: ../../source/Concepts/About-Internal-Interfaces.rst:169
msgid "``rosidl_typesupport_introspection_c``: provides tools for generating C code for supporting ``rosidl`` message data types."
msgstr "``rosidl_typesupport_introspection_c``: provides tools for generating C code for supporting ``rosidl`` message data types."


#: ../../source/Concepts/About-Internal-Interfaces.rst:170
msgid "``rosidl_typesupport_introspection_cpp``: provides tools for generating C++ code for supporting ``rosidl`` message data types."
msgstr "``rosidl_typesupport_introspection_cpp``: provides tools for generating C++ code for supporting ``rosidl`` message data types."


#: ../../source/Concepts/About-Internal-Interfaces.rst:172
msgid "In the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used. This is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the DDS vendor in order for the DDS implementation to make use of it. See the :ref:`Type Specific Interfaces` section above for more details."
msgstr "In the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used. This is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the DDS vendor in order for the DDS implementation to make use of it. See the :ref:`Type Specific Interfaces` section above for more details."


#: ../../source/Concepts/About-Internal-Interfaces.rst:176
msgid "For more information on what exactly is in the ``rosidl`` |API| (static and generated) see this page:"
msgstr "For more information on what exactly is in the ``rosidl`` |API| (static and generated) see this page:"


#: ../../source/Concepts/About-Internal-Interfaces.rst:180
msgid "TODO: link to definition of ``rosidl`` |APIs|"
msgstr "TODO: link to definition of ``rosidl`` |APIs|"


#: ../../source/Concepts/About-Internal-Interfaces.rst:183
msgid "The ``rcutils`` Repository"
msgstr "The ``rcutils`` Repository"


#: ../../source/Concepts/About-Internal-Interfaces.rst:185
msgid "ROS 2 C Utilities (``rcutils``) is a C |API| composed of macros, functions, and data structures used throughout the ROS 2 codebase. These are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both."
msgstr "ROS 2 C Utilities (``rcutils``) is a C |API| composed of macros, functions, and data structures used throughout the ROS 2 codebase. These are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both."


#: ../../source/Concepts/About-Internal-Interfaces.rst:188
msgid "The ``rcutils`` |API| and implementation are located in the `ros2/rcutils <https://github.com/ros2/rcutils>`_ repository on |GitHub|_ which contains the interface as C headers."
msgstr "The ``rcutils`` |API| and implementation are located in the `ros2/rcutils <https://github.com/ros2/rcutils>`_ repository on |GitHub|_ which contains the interface as C headers."


#: ../../source/Concepts/About-Internal-Interfaces.rst:190
msgid "For a complete definition of the ``rcutils`` |API|, see `the rcutils docs <https://docs.ros.org/en/humble/p/rcutils/>`_."
msgstr "For a complete definition of the ``rcutils`` |API|, see `the rcutils docs <https://docs.ros.org/en/humble/p/rcutils/>`_."


#: ../../source/Concepts/About-Logging.rst:6
msgid "About logging and logger configuration"
msgstr "About logging and logger configuration"


#: ../../source/Concepts/About-Logging.rst:16
msgid "The logging subsystem in ROS 2 aims to deliver logging messages to a variety of targets, including:"
msgstr "The logging subsystem in ROS 2 aims to deliver logging messages to a variety of targets, including:"


#: ../../source/Concepts/About-Logging.rst:18
msgid "To the console (if one is attached)"
msgstr "To the console (if one is attached)"


#: ../../source/Concepts/About-Logging.rst:19
msgid "To log files on disk (if local storage is available)"
msgstr "To log files on disk (if local storage is available)"


#: ../../source/Concepts/About-Logging.rst:20
msgid "To the ``/rosout`` topic on the ROS 2 network"
msgstr "To the ``/rosout`` topic on the ROS 2 network"


#: ../../source/Concepts/About-Logging.rst:22
msgid "By default, log messages in ROS 2 nodes will go out to the console (on stderr), to log files on disk, and to the ``/rosout`` topic on the ROS 2 network. All of the targets can be individually enabled or disabled on a per-node basis."
msgstr "By default, log messages in ROS 2 nodes will go out to the console (on stderr), to log files on disk, and to the ``/rosout`` topic on the ROS 2 network. All of the targets can be individually enabled or disabled on a per-node basis."


#: ../../source/Concepts/About-Logging.rst:25
msgid "The rest of this document will go over some of the ideas behind the logging subsystem."
msgstr "The rest of this document will go over some of the ideas behind the logging subsystem."


#: ../../source/Concepts/About-Logging.rst:28
msgid "Severity level"
msgstr "Severity level"


#: ../../source/Concepts/About-Logging.rst:30
msgid "Log messages have a severity level associated with them: ``DEBUG``, ``INFO``, ``WARN``, ``ERROR`` or ``FATAL``, in ascending order."
msgstr "Log messages have a severity level associated with them: ``DEBUG``, ``INFO``, ``WARN``, ``ERROR`` or ``FATAL``, in ascending order."


#: ../../source/Concepts/About-Logging.rst:32
msgid "A logger will only process log messages with severity at or higher than a specified level chosen for the logger."
msgstr "A logger will only process log messages with severity at or higher than a specified level chosen for the logger."


#: ../../source/Concepts/About-Logging.rst:34
msgid "Each node has a logger associated with it that automatically includes the node's name and namespace. If the node's name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name. Non-node loggers can also be created that use a specific name."
msgstr "Each node has a logger associated with it that automatically includes the node's name and namespace. If the node's name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name. Non-node loggers can also be created that use a specific name."


#: ../../source/Concepts/About-Logging.rst:38
msgid "Logger names represent a hierarchy. If the level of a logger named \"abc.def\" is unset, it will defer to the level of its parent named \"abc\", and if that level is also unset, the default logger level will be used. When the level of logger \"abc\" is changed, all of its descendants (e.g. \"abc.def\", \"abc.ghi.jkl\") will have their level impacted unless their level has been explicitly set."
msgstr "Logger names represent a hierarchy. If the level of a logger named \"abc.def\" is unset, it will defer to the level of its parent named \"abc\", and if that level is also unset, the default logger level will be used. When the level of logger \"abc\" is changed, all of its descendants (e.g. \"abc.def\", \"abc.ghi.jkl\") will have their level impacted unless their level has been explicitly set."


#: ../../source/Concepts/About-Logging.rst:43
msgid "APIs"
msgstr "APIs"


#: ../../source/Concepts/About-Logging.rst:45
msgid "These are the APIs that end users of the ROS 2 logging infrastructure should use, split up by client library."
msgstr "These are the APIs that end users of the ROS 2 logging infrastructure should use, split up by client library."


#: ../../source/Concepts/About-Logging.rst:51
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - output the given printf-style message every time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - output the given printf-style message every time this line is hit"


#: ../../source/Concepts/About-Logging.rst:52
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - output the given printf-style message only the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - output the given printf-style message only the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:53
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - output the given printf-style message only if the given expression is true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - output the given printf-style message only if the given expression is true"


#: ../../source/Concepts/About-Logging.rst:54
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - output the given printf-style message only if the given function returns true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - output the given printf-style message only if the given function returns true"


#: ../../source/Concepts/About-Logging.rst:55
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - output the given printf-style message all but the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - output the given printf-style message all but the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:56
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds"


#: ../../source/Concepts/About-Logging.rst:57
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first"


#: ../../source/Concepts/About-Logging.rst:58
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - output the given C++ stream-style message every time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - output the given C++ stream-style message every time this line is hit"


#: ../../source/Concepts/About-Logging.rst:59
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - output the given C++ stream-style message only the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - output the given C++ stream-style message only the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:60
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - output the given C++ stream-style message only if the given expression is true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - output the given C++ stream-style message only if the given expression is true"


#: ../../source/Concepts/About-Logging.rst:61
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - output the given C++ stream-style message only if the given function returns true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - output the given C++ stream-style message only if the given function returns true"


#: ../../source/Concepts/About-Logging.rst:62
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - output the given C++ stream-style message all but the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - output the given C++ stream-style message all but the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:63
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds"


#: ../../source/Concepts/About-Logging.rst:64
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds, but skip the first"


#: ../../source/Concepts/About-Logging.rst:66
msgid "Each of the above APIs takes an ``rclcpp::Logger`` object as the first argument. This can be pulled from the node API by calling ``node->get_logger()`` (recommended), or by constructing a stand-alone ``rclcpp::Logger`` object."
msgstr "Each of the above APIs takes an ``rclcpp::Logger`` object as the first argument. This can be pulled from the node API by calling ``node->get_logger()`` (recommended), or by constructing a stand-alone ``rclcpp::Logger`` object."


#: ../../source/Concepts/About-Logging.rst:69
msgid "``rcutils_logging_set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr "``rcutils_logging_set_logger_level`` - Set the logging level for a particular logger name to the given severity level"


#: ../../source/Concepts/About-Logging.rst:70
msgid "``rcutils_logging_get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr "``rcutils_logging_get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"


#: ../../source/Concepts/About-Logging.rst:74
msgid "``logger.{debug,info,warning,error,fatal}`` - output the given Python string to the logging infrastructure.  The calls accept the following keyword args to control behavior:"
msgstr "``logger.{debug,info,warning,error,fatal}`` - output the given Python string to the logging infrastructure.  The calls accept the following keyword args to control behavior:"


#: ../../source/Concepts/About-Logging.rst:76
msgid "``throttle_duration_sec`` - if not None, the duration of the throttle interval in floating-point seconds"
msgstr "``throttle_duration_sec`` - if not None, the duration of the throttle interval in floating-point seconds"


#: ../../source/Concepts/About-Logging.rst:77
msgid "``skip_first`` - if True, output the message all but the first time this line is hit"
msgstr "``skip_first`` - if True, output the message all but the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:78
msgid "``once`` - if True, only output the message the first time this line is hit"
msgstr "``once`` - if True, only output the message the first time this line is hit"


#: ../../source/Concepts/About-Logging.rst:80
msgid "``rclpy.logging.set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr "``rclpy.logging.set_logger_level`` - Set the logging level for a particular logger name to the given severity level"


#: ../../source/Concepts/About-Logging.rst:81
msgid "``rclpy.logging.get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr "``rclpy.logging.get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"


#: ../../source/Concepts/About-Logging.rst:84
msgid "Configuration"
msgstr "配置"


#: ../../source/Concepts/About-Logging.rst:86
msgid "Since ``rclcpp`` and ``rclpy`` use the same underlying logging infrastructure, the configuration options are the same."
msgstr "Since ``rclcpp`` and ``rclpy`` use the same underlying logging infrastructure, the configuration options are the same."


#: ../../source/Concepts/About-Logging.rst:89
msgid "Environment variables"
msgstr "Environment variables"


#: ../../source/Concepts/About-Logging.rst:91
msgid "The following environment variables control some aspects of the ROS 2 loggers. For each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process."
msgstr "The following environment variables control some aspects of the ROS 2 loggers. For each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process."


#: ../../source/Concepts/About-Logging.rst:94
msgid "``ROS_LOG_DIR`` - Control the logging directory that is used for writing logging messages to disk (if that is enabled).  If non-empty, use the exact directory as specified in this variable.  If empty, use the contents of the ``ROS_HOME`` environment variable to construct a path of the form ``$ROS_HOME/.log``.  In all cases, the ``~`` character is expanded to the user's HOME directory."
msgstr "``ROS_LOG_DIR`` - Control the logging directory that is used for writing logging messages to disk (if that is enabled).  If non-empty, use the exact directory as specified in this variable.  If empty, use the contents of the ``ROS_HOME`` environment variable to construct a path of the form ``$ROS_HOME/.log``.  In all cases, the ``~`` character is expanded to the user's HOME directory."


#: ../../source/Concepts/About-Logging.rst:95
msgid "``ROS_HOME`` - Control the home directory that is used for various ROS files, including logging and config files.  In the context of logging, this variable is used to construct a path to a directory for log files.  If non-empty, use the contents of this variable for the ROS_HOME path.  In all cases, the ``~`` character is expanded to the users's HOME directory."
msgstr "``ROS_HOME`` - Control the home directory that is used for various ROS files, including logging and config files.  In the context of logging, this variable is used to construct a path to a directory for log files.  If non-empty, use the contents of this variable for the ROS_HOME path.  In all cases, the ``~`` character is expanded to the users's HOME directory."


#: ../../source/Concepts/About-Logging.rst:96
msgid "``RCUTILS_LOGGING_USE_STDOUT`` - Control what stream output messages go to.  If this is unset or 0, use stderr.  If this is 1, use stdout."
msgstr "``RCUTILS_LOGGING_USE_STDOUT`` - Control what stream output messages go to.  If this is unset or 0, use stderr.  If this is 1, use stdout."


#: ../../source/Concepts/About-Logging.rst:97
msgid "``RCUTILS_LOGGING_BUFFERED_STREAM`` - Control whether the logging stream (as configured in ``RCUTILS_LOGGING_USE_STDOUT``) should be line buffered or unbuffered.  If this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr).  If this is 0, force the stream to be unbuffered.  If this is 1, force the stream to be line buffered."
msgstr "``RCUTILS_LOGGING_BUFFERED_STREAM`` - Control whether the logging stream (as configured in ``RCUTILS_LOGGING_USE_STDOUT``) should be line buffered or unbuffered.  If this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr).  If this is 0, force the stream to be unbuffered.  If this is 1, force the stream to be line buffered."


#: ../../source/Concepts/About-Logging.rst:98
msgid "``RCUTILS_COLORIZED_OUTPUT`` - Control whether colors are used when outputting messages.  If unset, automatically determine based on the platform and whether the console is a TTY.  If 0, force disable using colors for output.  If 1, force enable using colors for output."
msgstr "``RCUTILS_COLORIZED_OUTPUT`` - Control whether colors are used when outputting messages.  If unset, automatically determine based on the platform and whether the console is a TTY.  If 0, force disable using colors for output.  If 1, force enable using colors for output."


#: ../../source/Concepts/About-Logging.rst:99
msgid "``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - Control the fields that are output for each log message.  The available fields are:"
msgstr "``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - Control the fields that are output for each log message.  The available fields are:"


#: ../../source/Concepts/About-Logging.rst:101
msgid "``{severity}`` - The severity level."
msgstr "``{severity}`` - The severity level."


#: ../../source/Concepts/About-Logging.rst:102
msgid "``{name}`` - The name of the logger (may be empty)."
msgstr "``{name}`` - The name of the logger (may be empty)."


#: ../../source/Concepts/About-Logging.rst:103
msgid "``{message}`` - The log message (may be empty)."
msgstr "``{message}`` - The log message (may be empty)."


#: ../../source/Concepts/About-Logging.rst:104
msgid "``{function_name}`` - The function name this was called from (may be empty)."
msgstr "``{function_name}`` - The function name this was called from (may be empty)."


#: ../../source/Concepts/About-Logging.rst:105
msgid "``{file_name}`` - The file name this was called from (may be empty)."
msgstr "``{file_name}`` - The file name this was called from (may be empty)."


#: ../../source/Concepts/About-Logging.rst:106
msgid "``{time}`` - The time in seconds since the epoch."
msgstr "``{time}`` - The time in seconds since the epoch."


#: ../../source/Concepts/About-Logging.rst:107
msgid "``{time_as_nanoseconds}`` - The time in nanoseconds since the epoch."
msgstr "``{time_as_nanoseconds}`` - The time in nanoseconds since the epoch."


#: ../../source/Concepts/About-Logging.rst:108
msgid "``{line_number}`` - The line number this was called from (may be empty)."
msgstr "``{line_number}`` - The line number this was called from (may be empty)."


#: ../../source/Concepts/About-Logging.rst:110
msgid "If no format is given, a default of ``[{severity}] [{time}] [{name}]: {message}`` is used."
msgstr "If no format is given, a default of ``[{severity}] [{time}] [{name}]: {message}`` is used."


#: ../../source/Concepts/About-Logging.rst:114
msgid "Node creation"
msgstr "Node creation"


#: ../../source/Concepts/About-Logging.rst:116
msgid "When initializing a ROS 2 node, it is possible to control some aspects of the behavior via node options. Since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process."
msgstr "When initializing a ROS 2 node, it is possible to control some aspects of the behavior via node options. Since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process."


#: ../../source/Concepts/About-Logging.rst:119
msgid "``log_levels`` - The log level to use for a component within this particular node.  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``"
msgstr "``log_levels`` - The log level to use for a component within this particular node.  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``"


#: ../../source/Concepts/About-Logging.rst:120
msgid "``external_log_config_file`` - The external file to use to configure the backend logger.  If it is NULL, the default configuration will be used.  Note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog).  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``"
msgstr "``external_log_config_file`` - The external file to use to configure the backend logger.  If it is NULL, the default configuration will be used.  Note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog).  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``"


#: ../../source/Concepts/About-Logging.rst:121
msgid "``log_stdout_disabled`` - Whether to disable writing log messages to the console.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``"
msgstr "``log_stdout_disabled`` - Whether to disable writing log messages to the console.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``"


#: ../../source/Concepts/About-Logging.rst:122
msgid "``log_rosout_disabled`` - Whether to disable writing log messages out to ``/rosout``.  This can significantly save on network bandwidth, but external observers will not be able to monitor logging.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``"
msgstr "``log_rosout_disabled`` - Whether to disable writing log messages out to ``/rosout``.  This can significantly save on network bandwidth, but external observers will not be able to monitor logging.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``"


#: ../../source/Concepts/About-Logging.rst:123
msgid "``log_ext_lib_disabled`` - Whether to completely disable the use of an external logger.  This may be faster in some cases, but means that logs will not be written to disk.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``"
msgstr "``log_ext_lib_disabled`` - Whether to completely disable the use of an external logger.  This may be faster in some cases, but means that logs will not be written to disk.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``"


#: ../../source/Concepts/About-Logging.rst:126
msgid "Logging subsystem design"
msgstr "Logging subsystem design"


#: ../../source/Concepts/About-Logging.rst:128
msgid "The image below shows the five main pieces to the logging subsystem and how they interact."
msgstr "The image below shows the five main pieces to the logging subsystem and how they interact."


msgid "ROS 2 logging architecture"
msgstr "ROS 2 logging architecture"


#: ../../source/Concepts/About-Logging.rst:136
msgid "rcutils"
msgstr "rcutils"


#: ../../source/Concepts/About-Logging.rst:138
msgid "``rcutils`` has a logging implementation that can format log messages according to a certain format (see ``Configuration`` above), and output those log messages to a console. ``rcutils`` implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model. This will become more evident when we talk about the ``rcl`` layer below."
msgstr "``rcutils`` has a logging implementation that can format log messages according to a certain format (see ``Configuration`` above), and output those log messages to a console. ``rcutils`` implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model. This will become more evident when we talk about the ``rcl`` layer below."


#: ../../source/Concepts/About-Logging.rst:142
msgid "Note that this is a *per-process* logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes."
msgstr "Note that this is a *per-process* logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes."


#: ../../source/Concepts/About-Logging.rst:145
msgid "rcl_logging_spdlog"
msgstr "rcl_logging_spdlog"


#: ../../source/Concepts/About-Logging.rst:147
msgid "``rcl_logging_spdlog`` implements the ``rcl_logging_interface`` API, and thus provides external logging services to the ``rcl`` layer. In particular, the ``rcl_logging_spdlog`` implementation takes formatted log messages and writes them out to log files on disk using the ``spdlog`` library, typically within ``~/.ros/log`` (though this is configurable; see ``Configuration`` above)."
msgstr "``rcl_logging_spdlog`` implements the ``rcl_logging_interface`` API, and thus provides external logging services to the ``rcl`` layer. In particular, the ``rcl_logging_spdlog`` implementation takes formatted log messages and writes them out to log files on disk using the ``spdlog`` library, typically within ``~/.ros/log`` (though this is configurable; see ``Configuration`` above)."


#: ../../source/Concepts/About-Logging.rst:151
msgid "rcl"
msgstr "rcl"


#: ../../source/Concepts/About-Logging.rst:153
msgid "The logging subsystem in ``rcl`` uses ``rcutils`` and ``rcl_logging_spdlog`` to provide the bulk of the ROS 2 logging services. When log messages come in, ``rcl`` decides where to send them. There are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled:"
msgstr "The logging subsystem in ``rcl`` uses ``rcutils`` and ``rcl_logging_spdlog`` to provide the bulk of the ROS 2 logging services. When log messages come in, ``rcl`` decides where to send them. There are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled:"


#: ../../source/Concepts/About-Logging.rst:157
msgid "To the console via the ``rcutils`` layer"
msgstr "To the console via the ``rcutils`` layer"


#: ../../source/Concepts/About-Logging.rst:158
msgid "To disk via the ``rcl_logging_spdlog`` layer"
msgstr "To disk via the ``rcl_logging_spdlog`` layer"


#: ../../source/Concepts/About-Logging.rst:159
msgid "To the ``/rosout`` topic on the ROS 2 network via the RMW layer"
msgstr "To the ``/rosout`` topic on the ROS 2 network via the RMW layer"


#: ../../source/Concepts/About-Logging.rst:162
msgid "rclcpp"
msgstr "rclcpp"


#: ../../source/Concepts/About-Logging.rst:164
msgid "This is the main ROS 2 C++ API which sits atop the ``rcl`` API. In the context of logging, ``rclcpp`` provides the ``RCLCPP_`` logging macros; see ``APIs`` above for a complete list. When one of the ``RCLCPP_`` macros runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. Note that ``rclcpp`` uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded."
msgstr "This is the main ROS 2 C++ API which sits atop the ``rcl`` API. In the context of logging, ``rclcpp`` provides the ``RCLCPP_`` logging macros; see ``APIs`` above for a complete list. When one of the ``RCLCPP_`` macros runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. Note that ``rclcpp`` uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded."


#: ../../source/Concepts/About-Logging.rst:172
msgid "rclpy"
msgstr "rclpy"


#: ../../source/Concepts/About-Logging.rst:174
msgid "This is the main ROS 2 Python API which sits atop the ``rcl`` API. In the context of logging, ``rclpy`` provides the ``logger.debug``-style functions; see ``APIs`` above for a complete list. When one of the ``logger.debug`` functions runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured."
msgstr "This is the main ROS 2 Python API which sits atop the ``rcl`` API. In the context of logging, ``rclpy`` provides the ``logger.debug``-style functions; see ``APIs`` above for a complete list. When one of the ``logger.debug`` functions runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured."


#: ../../source/Concepts/About-Logging.rst:181
msgid "Logging usage"
msgstr "Logging usage"


#: ../../source/Concepts/About-Logging.rst:187
msgid "See the `rclcpp logging demo <https://github.com/ros2/demos/tree/humble/logging_demo>`_ for some simple examples."
msgstr "See the `rclcpp logging demo <https://github.com/ros2/demos/tree/humble/logging_demo>`_ for some simple examples."


#: ../../source/Concepts/About-Logging.rst:188
msgid "See the :doc:`logging demo <../Tutorials/Demos/Logging-and-logger-configuration>` for example usage."
msgstr "See the :doc:`logging demo <../Tutorials/Demos/Logging-and-logger-configuration>` for example usage."


#: ../../source/Concepts/About-Logging.rst:189
msgid "See the `rclcpp documentation <https://docs.ros2.org/latest/api/rclcpp/logging_8hpp.html>`__ for an extensive list of functionality."
msgstr "See the `rclcpp documentation <https://docs.ros2.org/latest/api/rclcpp/logging_8hpp.html>`__ for an extensive list of functionality."


#: ../../source/Concepts/About-Logging.rst:193
msgid "See the `rclpy examples <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ for example usage of a node's logger."
msgstr "See the `rclpy examples <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ for example usage of a node's logger."


#: ../../source/Concepts/About-Logging.rst:194
msgid "See the `rclpy tests <https://github.com/ros2/rclpy/blob/humble/rclpy/test/test_logging.py>`__ for example usage of keyword arguments (e.g. ``skip_first``, ``once``)."
msgstr "See the `rclpy tests <https://github.com/ros2/rclpy/blob/humble/rclpy/test/test_logging.py>`__ for example usage of keyword arguments (e.g. ``skip_first``, ``once``)."


#: ../../source/Concepts/About-Middleware-Implementations.rst:3
msgid "About ROS 2 middleware implementations"
msgstr "About ROS 2 middleware implementations"


#: ../../source/Concepts/About-Middleware-Implementations.rst:7
msgid "ROS middleware implementations are sets of |packages| that implement some of the internal ROS interfaces, e.g. the ``rmw``, ``rcl``, and ``rosidl`` |APIs|."
msgstr "ROS middleware implementations are sets of |packages| that implement some of the internal ROS interfaces, e.g. the ``rmw``, ``rcl``, and ``rosidl`` |APIs|."


#: ../../source/Concepts/About-Middleware-Implementations.rst:10
msgid "Common Packages for DDS Middleware Packages"
msgstr "Common Packages for DDS Middleware Packages"


#: ../../source/Concepts/About-Middleware-Implementations.rst:12
msgid "All of the current ROS middleware implementations are based on full or partial DDS implementations. For example, there is a middleware implementation that uses RTI's Connext DDS and an implementation which uses eProsima's Fast DDS. Because of this, there are some shared |packages| amongst most DDS based middleware implementations."
msgstr "All of the current ROS middleware implementations are based on full or partial DDS implementations. For example, there is a middleware implementation that uses RTI's Connext DDS and an implementation which uses eProsima's Fast DDS. Because of this, there are some shared |packages| amongst most DDS based middleware implementations."


#: ../../source/Concepts/About-Middleware-Implementations.rst:16
msgid "In the `ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_ repository on |GitHub|_, there is the following |package|:"
msgstr "In the `ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_ repository on |GitHub|_, there is the following |package|:"


#: ../../source/Concepts/About-Middleware-Implementations.rst:18
msgid "``rosidl_generator_dds_idl``: provides tools to generate DDS ``.idl`` files from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr "``rosidl_generator_dds_idl``: provides tools to generate DDS ``.idl`` files from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."


#: ../../source/Concepts/About-Middleware-Implementations.rst:20
msgid "The ``rosidl_generator_dds_idl`` |package| generates a DDS ``.idl`` file for each ``rosidl`` file, e.g. ``.msg`` file, defined by |packages| containing messages. Currently DDS based ROS middleware implementations make use of this generator's output ``.idl`` files to generate pre-compiled type support that is vendor specific."
msgstr "The ``rosidl_generator_dds_idl`` |package| generates a DDS ``.idl`` file for each ``rosidl`` file, e.g. ``.msg`` file, defined by |packages| containing messages. Currently DDS based ROS middleware implementations make use of this generator's output ``.idl`` files to generate pre-compiled type support that is vendor specific."


#: ../../source/Concepts/About-Middleware-Implementations.rst:24
msgid "Structure of ROS Middleware Implementations"
msgstr "Structure of ROS Middleware Implementations"


#: ../../source/Concepts/About-Middleware-Implementations.rst:26
msgid "A ROS middleware implementation is typically made up of a few |packages| in a single repository:"
msgstr "A ROS middleware implementation is typically made up of a few |packages| in a single repository:"


#: ../../source/Concepts/About-Middleware-Implementations.rst:28
msgid "``<implementation_name>_cmake_module``: contains CMake Module for discovering and exposing required dependencies"
msgstr "``<implementation_name>_cmake_module``: contains CMake Module for discovering and exposing required dependencies"


#: ../../source/Concepts/About-Middleware-Implementations.rst:29
msgid "``rmw_<implementation_name>_<language>``: contains the implementation of the ``rmw`` |API| in a particular language, typically C++"
msgstr "``rmw_<implementation_name>_<language>``: contains the implementation of the ``rmw`` |API| in a particular language, typically C++"


#: ../../source/Concepts/About-Middleware-Implementations.rst:30
msgid "``rosidl_typesupport_<implementation_name>_<language>``: contains tools to generate static type support code for ``rosidl`` files, tailored to the implementation in a particular language, typically C or C++"
msgstr "``rosidl_typesupport_<implementation_name>_<language>``: contains tools to generate static type support code for ``rosidl`` files, tailored to the implementation in a particular language, typically C or C++"


#: ../../source/Concepts/About-Middleware-Implementations.rst:32
msgid "The ``<implementation_name>_cmake_module`` |package| contains any CMake Modules and functions needed to find the supporting dependencies for the middleware implementation. For example, ``rti_connext_dds_cmake_module`` provides wrapper logic around the CMake Module shipped with RTI Connext DDS to make sure that all packages that depend on it will select the same installation of RTI Connext DDS. Similarly, ``fastrtps_cmake_module`` includes a CMake Module to find eProsima's Fast DDS and ``gurumdds_cmake_module`` includes a CMake Module to find GurumNetworks GurumDDS. Not all implementations will have a package like this: for example, Eclipe's Cyclone DDS already provides a CMake Module which is used directly by its RMW implementation without the need of additional wrappers."
msgstr "The ``<implementation_name>_cmake_module`` |package| contains any CMake Modules and functions needed to find the supporting dependencies for the middleware implementation. For example, ``rti_connext_dds_cmake_module`` provides wrapper logic around the CMake Module shipped with RTI Connext DDS to make sure that all packages that depend on it will select the same installation of RTI Connext DDS. Similarly, ``fastrtps_cmake_module`` includes a CMake Module to find eProsima's Fast DDS and ``gurumdds_cmake_module`` includes a CMake Module to find GurumNetworks GurumDDS. Not all implementations will have a package like this: for example, Eclipe's Cyclone DDS already provides a CMake Module which is used directly by its RMW implementation without the need of additional wrappers."


#: ../../source/Concepts/About-Middleware-Implementations.rst:37
msgid "The ``rmw_<implementation_name>_<language>`` |package| implements the ``rmw`` C |API| in a particular language. The implementation itself can be C++, it just must expose the header's symbols as ``extern \"C\"`` so that C applications can link against it."
msgstr "The ``rmw_<implementation_name>_<language>`` |package| implements the ``rmw`` C |API| in a particular language. The implementation itself can be C++, it just must expose the header's symbols as ``extern \"C\"`` so that C applications can link against it."


#: ../../source/Concepts/About-Middleware-Implementations.rst:40
msgid "The ``rosidl_typesupport_<implementation_name>_<language>`` |package| provides a generator which generates DDS code in a particular language. This is done using the ``.idl`` files generated by the ``rosidl_generator_dds_idl`` |package| and the DDS IDL code generator provided by the DDS vendor. It also generates code for converting ROS message structures to and from DDS message structures. This generator is also responsible for creating a shared library for the message package it is being used in, which is specific to the messages in the message package and to the DDS vendor being used."
msgstr "The ``rosidl_typesupport_<implementation_name>_<language>`` |package| provides a generator which generates DDS code in a particular language. This is done using the ``.idl`` files generated by the ``rosidl_generator_dds_idl`` |package| and the DDS IDL code generator provided by the DDS vendor. It also generates code for converting ROS message structures to and from DDS message structures. This generator is also responsible for creating a shared library for the message package it is being used in, which is specific to the messages in the message package and to the DDS vendor being used."


#: ../../source/Concepts/About-Middleware-Implementations.rst:45
msgid "As mentioned above, the ``rosidl_typesupport_introspection_<language>`` may be used instead of a vendor specific type support package if an rmw implementation supports runtime interpretation of messages. This ability to programmatically send and receive types over topics without generating code beforehand is achieved by supporting the `DDS X-Types Dynamic Data standard <http://www.omg.org/spec/DDS-XTypes>`_. As such, rmw implementations may provide support for the X-Types standard, and/or provide a package for type support generated at compile time specific to their DDS implementation."
msgstr "As mentioned above, the ``rosidl_typesupport_introspection_<language>`` may be used instead of a vendor specific type support package if an rmw implementation supports runtime interpretation of messages. This ability to programmatically send and receive types over topics without generating code beforehand is achieved by supporting the `DDS X-Types Dynamic Data standard <http://www.omg.org/spec/DDS-XTypes>`_. As such, rmw implementations may provide support for the X-Types standard, and/or provide a package for type support generated at compile time specific to their DDS implementation."


#: ../../source/Concepts/About-Middleware-Implementations.rst:49
msgid "As an example of an rmw implementation repository, the ``Eclipse Cyclone DDS`` ROS middleware implementation is on |GitHub|_ at `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_."
msgstr "As an example of an rmw implementation repository, the ``Eclipse Cyclone DDS`` ROS middleware implementation is on |GitHub|_ at `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_."


#: ../../source/Concepts/About-Middleware-Implementations.rst:51
msgid "The rmw implementation for ``Fast DDS`` is on |GitHub|_ at `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_."
msgstr "The rmw implementation for ``Fast DDS`` is on |GitHub|_ at `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_."


#: ../../source/Concepts/About-Middleware-Implementations.rst:53
msgid "The rmw implementation for ``Connext DDS`` is on |GitHub|_ at `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_."
msgstr "The rmw implementation for ``Connext DDS`` is on |GitHub|_ at `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_."


#: ../../source/Concepts/About-Middleware-Implementations.rst:55
msgid "The rmw implementation for ``GurumDDS`` is on |GitHub|_ at `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_."
msgstr "The rmw implementation for ``GurumDDS`` is on |GitHub|_ at `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_."


#: ../../source/Concepts/About-Middleware-Implementations.rst:57
msgid "To learn more about what is required to create a new middleware implementation for ROS see this page:"
msgstr "To learn more about what is required to create a new middleware implementation for ROS see this page:"


#: ../../source/Concepts/About-Middleware-Implementations.rst:61
msgid "TODO: Link to more detailed middleware implementation docs and/or tutorial."
msgstr "TODO: Link to more detailed middleware implementation docs and/or tutorial."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:6
msgid "About Quality of Service settings"
msgstr "About Quality of Service settings"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:12
msgid "ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes. With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between. Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines."
msgstr "ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes. With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between. Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:16
msgid "A set of QoS “policies” combine to form a QoS “profile”. Given the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common use cases (e.g. sensor data). At the same time, developers are given the flexibility to control specific policies of the QoS profiles."
msgstr "A set of QoS “policies” combine to form a QoS “profile”. Given the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common use cases (e.g. sensor data). At the same time, developers are given the flexibility to control specific policies of the QoS profiles."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:20
msgid "QoS profiles can be specified for publishers, subscriptions, service servers and clients. A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages."
msgstr "QoS profiles can be specified for publishers, subscriptions, service servers and clients. A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:25
msgid "QoS policies"
msgstr "QoS policies"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:27
msgid "The base QoS profile currently includes settings for the following policies:"
msgstr "The base QoS profile currently includes settings for the following policies:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:29
msgid "History"
msgstr "History"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:31
msgid "*Keep last*: only store up to N samples, configurable via the queue depth option."
msgstr "*Keep last*: only store up to N samples, configurable via the queue depth option."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:32
msgid "*Keep all*: store all samples, subject to the configured resource limits of the underlying middleware."
msgstr "*Keep all*: store all samples, subject to the configured resource limits of the underlying middleware."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:34
msgid "Depth"
msgstr "Depth"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:36
msgid "*Queue size*: only honored if the “history” policy was set to “keep last”."
msgstr "*Queue size*: only honored if the “history” policy was set to “keep last”."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:38
msgid "Reliability"
msgstr "Reliability"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:40
msgid "*Best effort*: attempt to deliver samples, but may lose them if the network is not robust."
msgstr "*Best effort*: attempt to deliver samples, but may lose them if the network is not robust."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:41
msgid "*Reliable*: guarantee that samples are delivered, may retry multiple times."
msgstr "*Reliable*: guarantee that samples are delivered, may retry multiple times."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:43
msgid "Durability"
msgstr "Durability"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:45
msgid "*Transient local*: the publisher becomes responsible for persisting samples for “late-joining” subscriptions."
msgstr "*Transient local*: the publisher becomes responsible for persisting samples for “late-joining” subscriptions."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:46
msgid "*Volatile*: no attempt is made to persist samples."
msgstr "*Volatile*: no attempt is made to persist samples."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:48
msgid "Deadline"
msgstr "Deadline"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:50
msgid "*Duration*: the expected maximum amount of time between subsequent messages being published to a topic"
msgstr "*Duration*: the expected maximum amount of time between subsequent messages being published to a topic"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:52
msgid "Lifespan"
msgstr "Lifespan"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:54
msgid "*Duration*: the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received)."
msgstr "*Duration*: the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received)."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:56
msgid "Liveliness"
msgstr "Liveliness"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:58
msgid "*Automatic*: the system will consider all of the node’s publishers to be alive for another “lease duration” when any one of its publishers has published a message."
msgstr "*Automatic*: the system will consider all of the node’s publishers to be alive for another “lease duration” when any one of its publishers has published a message."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:59
msgid "*Manual by topic*: the system will consider the publisher to be alive for another “lease duration” if it manually asserts that it is still alive (via a call to the publisher API)."
msgstr "*Manual by topic*: the system will consider the publisher to be alive for another “lease duration” if it manually asserts that it is still alive (via a call to the publisher API)."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:61
msgid "Lease Duration"
msgstr "Lease Duration"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:63
msgid "*Duration*: the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure)."
msgstr "*Duration*: the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure)."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:65
msgid "For each of the policies that is not a duration, there is also the option of “system default”, which uses the default of the underlying middleware. For each of the policies that is a duration, there also exists a “default” option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration."
msgstr "For each of the policies that is not a duration, there is also the option of “system default”, which uses the default of the underlying middleware. For each of the policies that is a duration, there also exists a “default” option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:69 ../../source/Concepts/About-Quality-of-Service-Settings.rst:265 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:119 ../../source/Concepts/About-Topic-Statistics.rst:75
msgid "Comparison to ROS 1"
msgstr "Comparison to ROS 1"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:71
msgid "The “history” and “depth” policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1."
msgstr "The “history” and “depth” policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:73
msgid "The “reliability” policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for “best effort”, or TCPROS (ROS 1 default) for “reliable”. Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate."
msgstr "The “reliability” policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for “best effort”, or TCPROS (ROS 1 default) for “reliable”. Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:76
msgid "The “durability” policy “transient local”, combined with any depth, provides functionality similar to that of “latching” publishers. The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect. It is possible that in the future, even more QoS policies will be available in ROS 2."
msgstr "The “durability” policy “transient local”, combined with any depth, provides functionality similar to that of “latching” publishers. The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect. It is possible that in the future, even more QoS policies will be available in ROS 2."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:82
msgid "QoS profiles"
msgstr "QoS profiles"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:84
msgid "Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case."
msgstr "Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:87
msgid "The currently defined QoS profiles are:"
msgstr "The currently defined QoS profiles are:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:89
msgid "Default QoS settings for publishers and subscriptions"
msgstr "Default QoS settings for publishers and subscriptions"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:91
msgid "In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable. By default, publishers and subscriptions in ROS 2 have “keep last” for history with a queue size of 10, “reliable” for reliability, “volatile” for durability, and “system default” for liveliness. Deadline, lifespan, and lease durations are also all set to “default”."
msgstr "In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable. By default, publishers and subscriptions in ROS 2 have “keep last” for history with a queue size of 10, “reliable” for reliability, “volatile” for durability, and “system default” for liveliness. Deadline, lifespan, and lease durations are also all set to “default”."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:95
msgid "Services"
msgstr "服务"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:97
msgid "In the same vein as publishers and subscriptions, services are reliable. It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests."
msgstr "In the same vein as publishers and subscriptions, services are reliable. It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:101
msgid "Sensor data"
msgstr "Sensor data"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:103
msgid "For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. For that reason the sensor data profile uses best effort reliability and a smaller queue size."
msgstr "For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. For that reason the sensor data profile uses best effort reliability and a smaller queue size."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:107 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:31
msgid "Parameters"
msgstr "参数"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:109
msgid "Parameters in ROS 2 are based on services, and as such have a similar profile. The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server."
msgstr "Parameters in ROS 2 are based on services, and as such have a similar profile. The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:112
msgid "System default"
msgstr "System default"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:114
msgid "This uses the RMW implementation’s default values for all of the policies. Different RMW implementations may have different defaults."
msgstr "This uses the RMW implementation’s default values for all of the policies. Different RMW implementations may have different defaults."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:117
msgid "`Click here <https://github.com/ros2/rmw/blob/humble/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles. The settings in these profiles are subject to further tweaks, based on the feedback from the community."
msgstr "`Click here <https://github.com/ros2/rmw/blob/humble/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles. The settings in these profiles are subject to further tweaks, based on the feedback from the community."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:122
msgid "QoS compatibilities"
msgstr "QoS compatibilities"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:124
msgid "**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner."
msgstr "**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:126
msgid "QoS profiles may be configured for publishers and subscriptions independently. A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles."
msgstr "QoS profiles may be configured for publishers and subscriptions independently. A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:129
msgid "QoS profile compatibility is determined based on a “Request vs Offered” model. Subscriptions *request* a QoS profile that is the “minimum quality” that it is willing to accept, and publishers *offer* a QoS profile that is the “maximum quality” that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile. Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different. The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions."
msgstr "QoS profile compatibility is determined based on a “Request vs Offered” model. Subscriptions *request* a QoS profile that is the “minimum quality” that it is willing to accept, and publishers *offer* a QoS profile that is the “maximum quality” that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile. Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different. The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:135
msgid "The following tables show the compatibility of the different policy settings and the result:"
msgstr "The following tables show the compatibility of the different policy settings and the result:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:137
msgid "*Compatibility of reliability QoS policies:*"
msgstr "*Compatibility of reliability QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:142 ../../source/Concepts/About-Quality-of-Service-Settings.rst:163 ../../source/Concepts/About-Quality-of-Service-Settings.rst:186 ../../source/Concepts/About-Quality-of-Service-Settings.rst:213 ../../source/Concepts/About-Quality-of-Service-Settings.rst:236
msgid "Publisher"
msgstr "Publisher"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:143 ../../source/Concepts/About-Quality-of-Service-Settings.rst:164 ../../source/Concepts/About-Quality-of-Service-Settings.rst:187 ../../source/Concepts/About-Quality-of-Service-Settings.rst:214 ../../source/Concepts/About-Quality-of-Service-Settings.rst:237
msgid "Subscription"
msgstr "Subscription"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:144 ../../source/Concepts/About-Quality-of-Service-Settings.rst:165 ../../source/Concepts/About-Quality-of-Service-Settings.rst:188 ../../source/Concepts/About-Quality-of-Service-Settings.rst:215 ../../source/Concepts/About-Quality-of-Service-Settings.rst:238
msgid "Compatible"
msgstr "Compatible"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:145 ../../source/Concepts/About-Quality-of-Service-Settings.rst:146 ../../source/Concepts/About-Quality-of-Service-Settings.rst:148 ../../source/Concepts/About-Quality-of-Service-Settings.rst:152
msgid "Best effort"
msgstr "Best effort"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:147 ../../source/Concepts/About-Quality-of-Service-Settings.rst:153 ../../source/Concepts/About-Quality-of-Service-Settings.rst:156 ../../source/Concepts/About-Quality-of-Service-Settings.rst:168 ../../source/Concepts/About-Quality-of-Service-Settings.rst:174 ../../source/Concepts/About-Quality-of-Service-Settings.rst:177 ../../source/Concepts/About-Quality-of-Service-Settings.rst:191 ../../source/Concepts/About-Quality-of-Service-Settings.rst:197 ../../source/Concepts/About-Quality-of-Service-Settings.rst:200 ../../source/Concepts/About-Quality-of-Service-Settings.rst:203 ../../source/Concepts/About-Quality-of-Service-Settings.rst:218 ../../source/Concepts/About-Quality-of-Service-Settings.rst:224 ../../source/Concepts/About-Quality-of-Service-Settings.rst:227 ../../source/Concepts/About-Quality-of-Service-Settings.rst:241 ../../source/Concepts/About-Quality-of-Service-Settings.rst:247 ../../source/Concepts/About-Quality-of-Service-Settings.rst:250 ../../source/Concepts/About-Quality-of-Service-Settings.rst:253
msgid "Yes"
msgstr "Yes"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:149 ../../source/Concepts/About-Quality-of-Service-Settings.rst:151 ../../source/Concepts/About-Quality-of-Service-Settings.rst:154 ../../source/Concepts/About-Quality-of-Service-Settings.rst:155
msgid "Reliable"
msgstr "Reliable"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:150 ../../source/Concepts/About-Quality-of-Service-Settings.rst:171 ../../source/Concepts/About-Quality-of-Service-Settings.rst:194 ../../source/Concepts/About-Quality-of-Service-Settings.rst:206 ../../source/Concepts/About-Quality-of-Service-Settings.rst:221 ../../source/Concepts/About-Quality-of-Service-Settings.rst:244 ../../source/Concepts/About-Quality-of-Service-Settings.rst:256
msgid "No"
msgstr "No"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:158
msgid "*Compatibility of durability QoS policies:*"
msgstr "*Compatibility of durability QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:166 ../../source/Concepts/About-Quality-of-Service-Settings.rst:167 ../../source/Concepts/About-Quality-of-Service-Settings.rst:169 ../../source/Concepts/About-Quality-of-Service-Settings.rst:173
msgid "Volatile"
msgstr "Volatile"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:170 ../../source/Concepts/About-Quality-of-Service-Settings.rst:172 ../../source/Concepts/About-Quality-of-Service-Settings.rst:175 ../../source/Concepts/About-Quality-of-Service-Settings.rst:176
msgid "Transient local"
msgstr "Transient local"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:179
msgid "*Compatibility of deadline QoS policies:*"
msgstr "*Compatibility of deadline QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:181 ../../source/Concepts/About-Quality-of-Service-Settings.rst:231
msgid "Assume *x* and *y* are arbitrary valid duration values."
msgstr "Assume *x* and *y* are arbitrary valid duration values."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:189 ../../source/Concepts/About-Quality-of-Service-Settings.rst:190 ../../source/Concepts/About-Quality-of-Service-Settings.rst:192 ../../source/Concepts/About-Quality-of-Service-Settings.rst:196 ../../source/Concepts/About-Quality-of-Service-Settings.rst:239 ../../source/Concepts/About-Quality-of-Service-Settings.rst:240 ../../source/Concepts/About-Quality-of-Service-Settings.rst:242 ../../source/Concepts/About-Quality-of-Service-Settings.rst:246
msgid "Default"
msgstr "Default"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:193 ../../source/Concepts/About-Quality-of-Service-Settings.rst:195 ../../source/Concepts/About-Quality-of-Service-Settings.rst:198 ../../source/Concepts/About-Quality-of-Service-Settings.rst:199 ../../source/Concepts/About-Quality-of-Service-Settings.rst:201 ../../source/Concepts/About-Quality-of-Service-Settings.rst:204 ../../source/Concepts/About-Quality-of-Service-Settings.rst:243 ../../source/Concepts/About-Quality-of-Service-Settings.rst:245 ../../source/Concepts/About-Quality-of-Service-Settings.rst:248 ../../source/Concepts/About-Quality-of-Service-Settings.rst:249 ../../source/Concepts/About-Quality-of-Service-Settings.rst:251 ../../source/Concepts/About-Quality-of-Service-Settings.rst:254
msgid "*x*"
msgstr "*x*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:202 ../../source/Concepts/About-Quality-of-Service-Settings.rst:252
msgid "*y* (where *y* > *x*)"
msgstr "*y* (where *y* > *x*)"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:205 ../../source/Concepts/About-Quality-of-Service-Settings.rst:255
msgid "*y* (where *y* < *x*)"
msgstr "*y* (where *y* < *x*)"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:208
msgid "*Compatibility of liveliness QoS policies:*"
msgstr "*Compatibility of liveliness QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:216 ../../source/Concepts/About-Quality-of-Service-Settings.rst:217 ../../source/Concepts/About-Quality-of-Service-Settings.rst:219 ../../source/Concepts/About-Quality-of-Service-Settings.rst:223
msgid "Automatic"
msgstr "Automatic"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:220 ../../source/Concepts/About-Quality-of-Service-Settings.rst:222 ../../source/Concepts/About-Quality-of-Service-Settings.rst:225 ../../source/Concepts/About-Quality-of-Service-Settings.rst:226
msgid "Manual by topic"
msgstr "Manual by topic"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:229
msgid "*Compatibility of lease duration QoS policies:*"
msgstr "*Compatibility of lease duration QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:258
msgid "In order for a connection to be made, all of the policies that affect compatibility must be compatible. For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made."
msgstr "In order for a connection to be made, all of the policies that affect compatibility must be compatible. For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:261
msgid "When connections are not made, no messages will be passed between the publisher and subscription. There are mechanisms to detect this situation, which will be covered in a later section."
msgstr "When connections are not made, no messages will be passed between the publisher and subscription. There are mechanisms to detect this situation, which will be covered in a later section."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:267
msgid "Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected. The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2."
msgstr "Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected. The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:272
msgid "QoS events"
msgstr "QoS events"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:274
msgid "Some QoS policies have possible events related to them. Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled."
msgstr "Some QoS policies have possible events related to them. Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:277
msgid "Developers may subscribe to the following QoS events that are associated with a publisher:"
msgstr "Developers may subscribe to the following QoS events that are associated with a publisher:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:279
msgid "Offered deadline missed"
msgstr "Offered deadline missed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:281
msgid "The publisher has not published a message within the expected duration that was set out by the deadline QoS policy."
msgstr "The publisher has not published a message within the expected duration that was set out by the deadline QoS policy."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:283
msgid "Liveliness lost"
msgstr "Liveliness lost"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:285
msgid "The publisher has failed to indicate its liveliness within the lease duration."
msgstr "The publisher has failed to indicate its liveliness within the lease duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:287
msgid "Offered incompatible QoS"
msgstr "Offered incompatible QoS"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:289
msgid "The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription."
msgstr "The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:291
msgid "Developers may subscribe to the following QoS events that are associated with a subscription:"
msgstr "Developers may subscribe to the following QoS events that are associated with a subscription:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:293
msgid "Requested deadline missed"
msgstr "Requested deadline missed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:295
msgid "The subscription has not received a message within the expected duration that was set out by the deadline QoS policy."
msgstr "The subscription has not received a message within the expected duration that was set out by the deadline QoS policy."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:297
msgid "Liveliness changed"
msgstr "Liveliness changed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:299
msgid "The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration."
msgstr "The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:301
msgid "Requested incompatible QoS"
msgstr "Requested incompatible QoS"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:303
msgid "The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher."
msgstr "The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:10
msgid "About ROS 2 client libraries"
msgstr "About ROS 2 client libraries"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:18
msgid "Client libraries are the APIs that allow users to implement their ROS code. Using client libraries, users gain access to ROS concepts such as nodes, topics, services, etc. Client libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application. For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++."
msgstr "Client libraries are the APIs that allow users to implement their ROS code. Using client libraries, users gain access to ROS concepts such as nodes, topics, services, etc. Client libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application. For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:23
msgid "Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language."
msgstr "Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:25
msgid "In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”. For example, here is a list of functionality that can typically be accessed through a client library:"
msgstr "In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”. For example, here is a list of functionality that can typically be accessed through a client library:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:29
msgid "Names and namespaces"
msgstr "Names and namespaces"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:30
msgid "Time (real or simulated)"
msgstr "Time (real or simulated)"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:32
msgid "Console logging"
msgstr "Console logging"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:33
msgid "Threading model"
msgstr "Threading model"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:34
msgid "Intra-process communication"
msgstr "Intra-process communication"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:37
msgid "Supported client libraries"
msgstr "Supported client libraries"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:39
msgid "The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in the RCL."
msgstr "The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in the RCL."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:42
msgid "The ``rclcpp`` Package"
msgstr "The ``rclcpp`` Package"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:44
msgid "The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions. ``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``."
msgstr "The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions. ``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:47
msgid "``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|."
msgstr "``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:49
msgid "The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``. The generated |API| documentation is here:"
msgstr "The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``. The generated |API| documentation is here:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:52
msgid "`api/rclcpp/index.html <http://docs.ros.org/en/humble/p/rclcpp>`_"
msgstr "`api/rclcpp/index.html <http://docs.ros.org/en/humble/p/rclcpp>`_"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:55
msgid "The ``rclpy`` Package"
msgstr "The ``rclpy`` Package"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:57
msgid "The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library. Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation. The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects. By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior. In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|."
msgstr "The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library. Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation. The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects. By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior. In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:63
msgid "Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message. All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|. This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python."
msgstr "Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message. All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|. This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:67
msgid "The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``. The generated |API| documentation is here:"
msgstr "The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``. The generated |API| documentation is here:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:70
msgid "`api/rclpy/index.html <http://docs.ros2.org/foxy/api/rclpy/index.html>`_"
msgstr "`api/rclpy/index.html <http://docs.ros2.org/foxy/api/rclpy/index.html>`_"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:74
msgid "Community-maintained"
msgstr "Community-maintained"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:76
msgid "While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:"
msgstr "While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:78
msgid "`Ada <https://github.com/ada-ros/ada4ros2>`__ Ada binding and tools for ROS 2 - workspace overlay."
msgstr "`Ada <https://github.com/ada-ros/ada4ros2>`__ Ada binding and tools for ROS 2 - workspace overlay."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:79
msgid "`C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials."
msgstr "`C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:80
msgid "`JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2."
msgstr "`JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:81
msgid "`.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard."
msgstr "`.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:82
msgid "`Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming."
msgstr "`Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:83
msgid "`Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust."
msgstr "`Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:85
msgid "Older, unmaintained client libraries are:"
msgstr "Older, unmaintained client libraries are:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:87
msgid "`C# <https://github.com/firesurfer/rclcs>`__"
msgstr "`C# <https://github.com/firesurfer/rclcs>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:88
msgid "`Objective C and iOS <https://github.com/esteve/ros2_objc>`__"
msgstr "`Objective C and iOS <https://github.com/esteve/ros2_objc>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:92
msgid "Common functionality: the RCL"
msgstr "Common functionality: the RCL"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:94
msgid "Most of the functionality found in a client library is not specific to the programming language of the client library. For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific. As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces. This keeps client libraries thinner and easier to develop. For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap."
msgstr "Most of the functionality found in a client library is not specific to the programming language of the client library. For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific. As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces. This keeps client libraries thinner and easier to develop. For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:101
msgid "In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected. Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes."
msgstr "In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected. Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:105
msgid "`The API documentation for the RCL can be found here. <https://docs.ros2.org/latest/api/rcl/>`__"
msgstr "`The API documentation for the RCL can be found here. <https://docs.ros2.org/latest/api/rcl/>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:108
msgid "Language-specific functionality"
msgstr "Language-specific functionality"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:110
msgid "Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library. For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library."
msgstr "Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library. For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:114
msgid "Demo"
msgstr "Demo"


#, python-format
msgid "For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__)."
msgstr "For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__)."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:121
msgid "In ROS 1, all client libraries are developed \"from the ground up\". This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code. However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS)."
msgstr "In ROS 1, all client libraries are developed \"from the ground up\". This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code. However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS)."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:126
msgid "Summary"
msgstr "摘要"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:128
msgid "By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior."
msgstr "By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:8
msgid "About parameters in ROS 2"
msgstr "About parameters in ROS 2"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:16
msgid "Parameters in ROS are associated with individual nodes. Parameters are used to configure nodes at startup (and during runtime), without changing the code. The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart)."
msgstr "Parameters in ROS are associated with individual nodes. Parameters are used to configure nodes at startup (and during runtime), without changing the code. The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart)."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:20
msgid "Parameters are addressed by node name, node namespace, parameter name, and parameter namespace. Providing a parameter namespace is optional."
msgstr "Parameters are addressed by node name, node namespace, parameter name, and parameter namespace. Providing a parameter namespace is optional."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:23
msgid "Each parameter consists of a key, a value, and a descriptor. The key is a string and the value is one of the following types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints."
msgstr "Each parameter consists of a key, a value, and a descriptor. The key is a string and the value is one of the following types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:27
msgid "For an hands-on tutorial with ROS parameters see :doc:`../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`."
msgstr "For an hands-on tutorial with ROS parameters see :doc:`../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:30
msgid "Parameters background"
msgstr "Parameters background"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:33
msgid "Declaring parameters"
msgstr "Declaring parameters"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:35
msgid "By default, a node needs to *declare* all of the parameters that it will accept during its lifetime. This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. See :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node."
msgstr "By default, a node needs to *declare* all of the parameters that it will accept during its lifetime. This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. See :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:39
msgid "For some types of nodes, not all of the parameters will be known ahead of time. In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared."
msgstr "For some types of nodes, not all of the parameters will be known ahead of time. In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:43
msgid "Parameter types"
msgstr "Parameter types"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:45
msgid "Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview. By default, attempts to change the type of a declared parameter at runtime will fail. This prevents common mistakes, such as putting a boolean value into an integer parameter."
msgstr "Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview. By default, attempts to change the type of a declared parameter at runtime will fail. This prevents common mistakes, such as putting a boolean value into an integer parameter."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:49
msgid "If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``."
msgstr "If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:53
msgid "Parameter callbacks"
msgstr "Parameter callbacks"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:55
msgid "A ROS 2 node can register two different types of callbacks to be informed when changes are happening to parameters. The reason that there are two types of callbacks is to have a chance to intervene before the parameter change happens, and to have a chance to react after the parameter change happens. A node can register for both, either, or none of the callback types. Both types are described below."
msgstr "A ROS 2 node can register two different types of callbacks to be informed when changes are happening to parameters. The reason that there are two types of callbacks is to have a chance to intervene before the parameter change happens, and to have a chance to react after the parameter change happens. A node can register for both, either, or none of the callback types. Both types are described below."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:60
msgid "The first type is known as a \"set parameter\" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API. The callback should accept a list of ``Parameter`` objects, and return an ``rcl_interfaces/msg/SetParametersResult``. This callback will be called before a parameter is declared or changed on a node. The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change."
msgstr "The first type is known as a \"set parameter\" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API. The callback should accept a list of ``Parameter`` objects, and return an ``rcl_interfaces/msg/SetParametersResult``. This callback will be called before a parameter is declared or changed on a node. The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:66
msgid "It is important that \"set parameter\" callbacks have no side-effects. Since multiple \"set parameter\" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. To get a callback *after* a parameter has been successfully changed, see the next type of callback below."
msgstr "It is important that \"set parameter\" callbacks have no side-effects. Since multiple \"set parameter\" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. To get a callback *after* a parameter has been successfully changed, see the next type of callback below."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:71
msgid "The second type of callback is known as an \"on parameter event\" callback, and can be set by calling ``on_parameter_event`` from one of the parameter client APIs. The callback should accept an ``rcl_interfaces/msg/ParameterEvent`` object, and return nothing. This callback will be called after all parameters in the input event have been declared, changed, or deleted. The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted."
msgstr "The second type of callback is known as an \"on parameter event\" callback, and can be set by calling ``on_parameter_event`` from one of the parameter client APIs. The callback should accept an ``rcl_interfaces/msg/ParameterEvent`` object, and return nothing. This callback will be called after all parameters in the input event have been declared, changed, or deleted. The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:77
msgid "Interacting with parameters"
msgstr "Interacting with parameters"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:79
msgid "ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`. External processes can perform parameter operations via parameter services that are created by default when a node is instantiated. The services that are created by default are:"
msgstr "ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`. External processes can perform parameter operations via parameter services that are created by default when a node is instantiated. The services that are created by default are:"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:83
msgid "/node_name/describe_parameters: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``. Given a list of parameter names, returns a list of descriptors associated with the parameters."
msgstr "/node_name/describe_parameters: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``. Given a list of parameter names, returns a list of descriptors associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:85
msgid "/node_name/get_parameter_types: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``. Given a list of parameter names, returns a list of parameter types associated with the parameters."
msgstr "/node_name/get_parameter_types: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``. Given a list of parameter names, returns a list of parameter types associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:87
msgid "/node_name/get_parameters: Uses a service type of ``rcl_interfaces/srv/GetParameters``. Given a list of parameter names, returns a list of parameter values associated with the parameters."
msgstr "/node_name/get_parameters: Uses a service type of ``rcl_interfaces/srv/GetParameters``. Given a list of parameter names, returns a list of parameter values associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:89
msgid "/node_name/list_parameters: Uses a service type of ``rcl_interfaces/srv/ListParameters``. Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters."
msgstr "/node_name/list_parameters: Uses a service type of ``rcl_interfaces/srv/ListParameters``. Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:91
msgid "/node_name/set_parameters: Uses a service type of ``rcl_interfaces/srv/SetParameters``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed."
msgstr "/node_name/set_parameters: Uses a service type of ``rcl_interfaces/srv/SetParameters``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:93
msgid "/node_name/set_parameters_atomically: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed."
msgstr "/node_name/set_parameters_atomically: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:97
msgid "Setting initial parameter values when running a node"
msgstr "Setting initial parameter values when running a node"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:99
msgid "Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files. See :ref:`NodeArgsParameters` for examples on how to set initial parameter values."
msgstr "Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files. See :ref:`NodeArgsParameters` for examples on how to set initial parameter values."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:103
msgid "Setting initial parameter values when launching nodes"
msgstr "Setting initial parameter values when launching nodes"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:105
msgid "Initial parameter values can also be set when running the node through the ROS 2 launch facility. See :doc:`this document <../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch."
msgstr "Initial parameter values can also be set when running the node through the ROS 2 launch facility. See :doc:`this document <../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:109
msgid "Manipulating parameter values at runtime"
msgstr "Manipulating parameter values at runtime"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:111
msgid "The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running. ``ros2 param`` uses the parameter service API as described above to perform the various operations. See :doc:`this how-to guide <../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``."
msgstr "The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running. ``ros2 param`` uses the parameter service API as described above to perform the various operations. See :doc:`this how-to guide <../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:116
msgid "Migrating from ROS 1"
msgstr "Migrating from ROS 1"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:118
msgid "The :doc:`Launch file migration guide <../How-To-Guides/Launch-files-migration-guide>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2."
msgstr "The :doc:`Launch file migration guide <../How-To-Guides/Launch-files-migration-guide>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:120
msgid "The :doc:`YAML parameter file migration guide <../How-To-Guides/Parameters-YAML-files-migration-guide>` explains how to migrate parameter files from ROS 1 to ROS 2."
msgstr "The :doc:`YAML parameter file migration guide <../How-To-Guides/Parameters-YAML-files-migration-guide>` explains how to migrate parameter files from ROS 1 to ROS 2."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:122
msgid "In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters. Since there is no central ``roscore`` in ROS 2, that functionality no longer exists. The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them. If a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ROS 2 ships with one in the ``ros-humble-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:"
msgstr "In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters. Since there is no central ``roscore`` in ROS 2, that functionality no longer exists. The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them. If a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ROS 2 ships with one in the ``ros-humble-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:132
msgid "The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__."
msgstr "The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__."


#: ../../source/Concepts/About-ROS-Interfaces.rst:8
msgid "About ROS 2 interfaces"
msgstr "About ROS 2 interfaces"


#: ../../source/Concepts/About-ROS-Interfaces.rst:14
msgid "1. Background"
msgstr "1. Background"


#: ../../source/Concepts/About-ROS-Interfaces.rst:16
msgid "ROS applications typically communicate through interfaces of one of three types: messages, services and actions. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages."
msgstr "ROS applications typically communicate through interfaces of one of three types: messages, services and actions. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages."


#: ../../source/Concepts/About-ROS-Interfaces.rst:20
msgid "In this document we will describe the supported types:"
msgstr "In this document we will describe the supported types:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:22
msgid "msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages."
msgstr "msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages."


#: ../../source/Concepts/About-ROS-Interfaces.rst:23
msgid "srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations."
msgstr "srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations."


#: ../../source/Concepts/About-ROS-Interfaces.rst:24
msgid "action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself."
msgstr "action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself."


#: ../../source/Concepts/About-ROS-Interfaces.rst:29
msgid "2. Message description specification"
msgstr "2. Message description specification"


#: ../../source/Concepts/About-ROS-Interfaces.rst:31
msgid "Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package. ``.msg`` files are composed of two parts: fields and constants."
msgstr "Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package. ``.msg`` files are composed of two parts: fields and constants."


#: ../../source/Concepts/About-ROS-Interfaces.rst:35
msgid "2.1 Fields"
msgstr "2.1 Fields"


#: ../../source/Concepts/About-ROS-Interfaces.rst:37
msgid "Each field consists of a type and a name, separated by a space, i.e:"
msgstr "Each field consists of a type and a name, separated by a space, i.e:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:45 ../../source/Concepts/About-ROS-Interfaces.rst:194 ../../source/Concepts/About-ROS-Interfaces.rst:218
msgid "For example:"
msgstr "For example:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:53
msgid "2.1.1 Field types"
msgstr "2.1.1 Field types"


#: ../../source/Concepts/About-ROS-Interfaces.rst:55
msgid "Field types can be:"
msgstr "Field types can be:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:58
msgid "a built-in-type"
msgstr "a built-in-type"


#: ../../source/Concepts/About-ROS-Interfaces.rst:59
msgid "names of Message descriptions defined on their own, such as \"geometry_msgs/PoseStamped\""
msgstr "names of Message descriptions defined on their own, such as \"geometry_msgs/PoseStamped\""


#: ../../source/Concepts/About-ROS-Interfaces.rst:61
msgid "*Built-in-types currently supported:*"
msgstr "*Built-in-types currently supported:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:66 ../../source/Concepts/About-ROS-Interfaces.rst:137
msgid "Type name"
msgstr "Type name"


#: ../../source/Concepts/About-ROS-Interfaces.rst:67 ../../source/Concepts/About-ROS-Interfaces.rst:138
msgid "`C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__"
msgstr "`C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:68 ../../source/Concepts/About-ROS-Interfaces.rst:139
msgid "`Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__"
msgstr "`Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:69 ../../source/Concepts/About-ROS-Interfaces.rst:140
msgid "`DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__"
msgstr "`DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:70 ../../source/Concepts/About-ROS-Interfaces.rst:71
msgid "bool"
msgstr "bool"


#: ../../source/Concepts/About-ROS-Interfaces.rst:72
msgid "builtins.bool"
msgstr "builtins.bool"


#: ../../source/Concepts/About-ROS-Interfaces.rst:73
msgid "boolean"
msgstr "boolean"


#: ../../source/Concepts/About-ROS-Interfaces.rst:74
msgid "byte"
msgstr "byte"


#: ../../source/Concepts/About-ROS-Interfaces.rst:75 ../../source/Concepts/About-ROS-Interfaces.rst:95
msgid "uint8_t"
msgstr "uint8_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:76
msgid "builtins.bytes*"
msgstr "builtins.bytes*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:77 ../../source/Concepts/About-ROS-Interfaces.rst:93 ../../source/Concepts/About-ROS-Interfaces.rst:97
msgid "octet"
msgstr "octet"


#: ../../source/Concepts/About-ROS-Interfaces.rst:78 ../../source/Concepts/About-ROS-Interfaces.rst:79 ../../source/Concepts/About-ROS-Interfaces.rst:81
msgid "char"
msgstr "char"


#: ../../source/Concepts/About-ROS-Interfaces.rst:80 ../../source/Concepts/About-ROS-Interfaces.rst:155
msgid "builtins.str*"
msgstr "builtins.str*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:82
msgid "float32"
msgstr "float32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:83 ../../source/Concepts/About-ROS-Interfaces.rst:85
msgid "float"
msgstr "float"


#: ../../source/Concepts/About-ROS-Interfaces.rst:84 ../../source/Concepts/About-ROS-Interfaces.rst:88
msgid "builtins.float*"
msgstr "builtins.float*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:86
msgid "float64"
msgstr "float64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:87 ../../source/Concepts/About-ROS-Interfaces.rst:89
msgid "double"
msgstr "double"


#: ../../source/Concepts/About-ROS-Interfaces.rst:90
msgid "int8"
msgstr "int8"


#: ../../source/Concepts/About-ROS-Interfaces.rst:91
msgid "int8_t"
msgstr "int8_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:92 ../../source/Concepts/About-ROS-Interfaces.rst:96 ../../source/Concepts/About-ROS-Interfaces.rst:100 ../../source/Concepts/About-ROS-Interfaces.rst:104 ../../source/Concepts/About-ROS-Interfaces.rst:108 ../../source/Concepts/About-ROS-Interfaces.rst:112 ../../source/Concepts/About-ROS-Interfaces.rst:116 ../../source/Concepts/About-ROS-Interfaces.rst:120
msgid "builtins.int*"
msgstr "builtins.int*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:94
msgid "uint8"
msgstr "uint8"


#: ../../source/Concepts/About-ROS-Interfaces.rst:98
msgid "int16"
msgstr "int16"


#: ../../source/Concepts/About-ROS-Interfaces.rst:99
msgid "int16_t"
msgstr "int16_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:101
msgid "short"
msgstr "short"


#: ../../source/Concepts/About-ROS-Interfaces.rst:102
msgid "uint16"
msgstr "uint16"


#: ../../source/Concepts/About-ROS-Interfaces.rst:103
msgid "uint16_t"
msgstr "uint16_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:105
msgid "unsigned short"
msgstr "unsigned short"


#: ../../source/Concepts/About-ROS-Interfaces.rst:106
msgid "int32"
msgstr "int32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:107
msgid "int32_t"
msgstr "int32_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:109
msgid "long"
msgstr "long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:110
msgid "uint32"
msgstr "uint32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:111
msgid "uint32_t"
msgstr "uint32_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:113
msgid "unsigned long"
msgstr "unsigned long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:114
msgid "int64"
msgstr "int64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:115
msgid "int64_t"
msgstr "int64_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:117
msgid "long long"
msgstr "long long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:118
msgid "uint64"
msgstr "uint64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:119
msgid "uint64_t"
msgstr "uint64_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:121
msgid "unsigned long long"
msgstr "unsigned long long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:122 ../../source/Concepts/About-ROS-Interfaces.rst:125 ../../source/Concepts/About-ROS-Interfaces.rst:156
msgid "string"
msgstr "string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:123 ../../source/Concepts/About-ROS-Interfaces.rst:154
msgid "std::string"
msgstr "std::string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:124 ../../source/Concepts/About-ROS-Interfaces.rst:128
msgid "builtins.str"
msgstr "builtins.str"


#: ../../source/Concepts/About-ROS-Interfaces.rst:126 ../../source/Concepts/About-ROS-Interfaces.rst:129
msgid "wstring"
msgstr "wstring"


#: ../../source/Concepts/About-ROS-Interfaces.rst:127
msgid "std::u16string"
msgstr "std::u16string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:132
msgid "*Every built-in-type can be used to define arrays:*"
msgstr "*Every built-in-type can be used to define arrays:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:141
msgid "static array"
msgstr "static array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:142
msgid "std::array<T, N>"
msgstr "std::array<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:143 ../../source/Concepts/About-ROS-Interfaces.rst:151
msgid "builtins.list*"
msgstr "builtins.list*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:144
msgid "T[N]"
msgstr "T[N]"


#: ../../source/Concepts/About-ROS-Interfaces.rst:145
msgid "unbounded dynamic array"
msgstr "unbounded dynamic array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:146
msgid "std::vector"
msgstr "std::vector"


#: ../../source/Concepts/About-ROS-Interfaces.rst:147
msgid "builtins.list"
msgstr "builtins.list"


#: ../../source/Concepts/About-ROS-Interfaces.rst:148
msgid "sequence"
msgstr "sequence"


#: ../../source/Concepts/About-ROS-Interfaces.rst:149
msgid "bounded dynamic array"
msgstr "bounded dynamic array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:150
msgid "custom_class<T, N>"
msgstr "custom_class<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:152
msgid "sequence<T, N>"
msgstr "sequence<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:153
msgid "bounded string"
msgstr "bounded string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:159
msgid "All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software"
msgstr "All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software"


#: ../../source/Concepts/About-ROS-Interfaces.rst:161
msgid "*Example of message definition using arrays and bounded types:*"
msgstr "*Example of message definition using arrays and bounded types:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:177
msgid "2.1.2 Field names"
msgstr "2.1.2 Field names"


#: ../../source/Concepts/About-ROS-Interfaces.rst:179
msgid "Field names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores."
msgstr "Field names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores."


#: ../../source/Concepts/About-ROS-Interfaces.rst:183
msgid "2.1.3 Field default value"
msgstr "2.1.3 Field default value"


#: ../../source/Concepts/About-ROS-Interfaces.rst:185
msgid "Default values can be set to any field in the message type. Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages)."
msgstr "Default values can be set to any field in the message type. Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:188
msgid "Defining a default value is done by adding a third element to the field definition line, i.e:"
msgstr "Defining a default value is done by adding a third element to the field definition line, i.e:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:203
msgid "Note:"
msgstr "Note:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:206
msgid "string values must be defined in single ``'`` or double ``\"`` quotes"
msgstr "string values must be defined in single ``'`` or double ``\"`` quotes"


#: ../../source/Concepts/About-ROS-Interfaces.rst:207
msgid "currently string values are not escaped"
msgstr "currently string values are not escaped"


#: ../../source/Concepts/About-ROS-Interfaces.rst:210
msgid "2.2 Constants"
msgstr "2.2 Constants"


#: ../../source/Concepts/About-ROS-Interfaces.rst:212
msgid "Each constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal '=' sign, e.g."
msgstr "Each constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal '=' sign, e.g."


#: ../../source/Concepts/About-ROS-Interfaces.rst:229
msgid "Constants names have to be UPPERCASE"
msgstr "Constants names have to be UPPERCASE"


#: ../../source/Concepts/About-ROS-Interfaces.rst:232
msgid "3. Service description specification"
msgstr "3. Service description specification"


#: ../../source/Concepts/About-ROS-Interfaces.rst:234
msgid "Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package."
msgstr "Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package."


#: ../../source/Concepts/About-ROS-Interfaces.rst:236
msgid "A service description file consists of a request and a response msg type, separated by ``---``. Any two ``.msg`` files concatenated with a ``---`` are a legal service description."
msgstr "A service description file consists of a request and a response msg type, separated by ``---``. Any two ``.msg`` files concatenated with a ``---`` are a legal service description."


#: ../../source/Concepts/About-ROS-Interfaces.rst:239
msgid "Here is a very simple example of a service that takes in a string and returns a string:"
msgstr "Here is a very simple example of a service that takes in a string and returns a string:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:247
msgid "We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):"
msgstr "We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):"


#: ../../source/Concepts/About-ROS-Interfaces.rst:265
msgid "You cannot embed another service inside of a service."
msgstr "You cannot embed another service inside of a service."


#: ../../source/Concepts/About-ROS-Interfaces.rst:268
msgid "4. New features in ROS 2 interfaces"
msgstr "4. New features in ROS 2 interfaces"


#: ../../source/Concepts/About-ROS-Interfaces.rst:270
msgid "The ROS 2 IDL is closely related to the `ROS 1 IDL <https://wiki.ros.org/msg>`__. Most existing ROS 1 ``.msg`` and ``.srv`` files should be usable as-is with ROS 2. Atop ROS 1's existing feature set, the ROS 2 IDL introduces some new features, namely:"
msgstr "The ROS 2 IDL is closely related to the `ROS 1 IDL <https://wiki.ros.org/msg>`__. Most existing ROS 1 ``.msg`` and ``.srv`` files should be usable as-is with ROS 2. Atop ROS 1's existing feature set, the ROS 2 IDL introduces some new features, namely:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:275
msgid "**bounded arrays**: Whereas the ROS 1 IDL allows unbounded arrays (e.g., ``int32[] foo``) and fixed-size arrays (e.g., ``int32[5] bar``), the ROS 2 IDL further allows bounded arrays (e.g., ``int32[<=5] bat``). There are use cases in which it's important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution)."
msgstr "**bounded arrays**: Whereas the ROS 1 IDL allows unbounded arrays (e.g., ``int32[] foo``) and fixed-size arrays (e.g., ``int32[5] bar``), the ROS 2 IDL further allows bounded arrays (e.g., ``int32[<=5] bat``). There are use cases in which it's important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:277
msgid "**bounded strings**: Whereas the ROS 1 IDL allows unbounded strings (e.g., ``string foo``), the ROS 2 IDL further allows bounded strings (e.g., ``string<=5 bar``)."
msgstr "**bounded strings**: Whereas the ROS 1 IDL allows unbounded strings (e.g., ``string foo``), the ROS 2 IDL further allows bounded strings (e.g., ``string<=5 bar``)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:278
msgid "**default values**: Whereas the ROS 1 IDL allows constant fields (e.g., ``int32 X=123``), the ROS 2 IDL further allows default values to be specified (e.g., ``int32 X 123``). The default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field. You can also specify default values for action parts."
msgstr "**default values**: Whereas the ROS 1 IDL allows constant fields (e.g., ``int32 X=123``), the ROS 2 IDL further allows default values to be specified (e.g., ``int32 X 123``). The default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field. You can also specify default values for action parts."


#: ../../source/Concepts/About-RQt.rst:9
msgid "Overview and usage of RQt"
msgstr "Overview and usage of RQt"


#: ../../source/Concepts/About-RQt.rst:18
msgid "RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout."
msgstr "RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout."


#: ../../source/Concepts/About-RQt.rst:22
msgid "You can run any RQt tools/plugins easily by:"
msgstr "You can run any RQt tools/plugins easily by:"


#: ../../source/Concepts/About-RQt.rst:28
msgid "This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Python Console:"
msgstr "This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Python Console:"


#: ../../source/Concepts/About-RQt.rst:36
msgid "Users can create their own plugins for RQt with either ``Python`` or ``C++``. To see what RQt plugins are available for your system, run:"
msgstr "Users can create their own plugins for RQt with either ``Python`` or ``C++``. To see what RQt plugins are available for your system, run:"


#: ../../source/Concepts/About-RQt.rst:43
msgid "And then look for packages that start with ``rqt_``."
msgstr "And then look for packages that start with ``rqt_``."


#: ../../source/Concepts/About-RQt.rst:46
msgid "System setup"
msgstr "System setup"


#: ../../source/Concepts/About-RQt.rst:49
msgid "Installing From Debian"
msgstr "Installing From Debian"


#: ../../source/Concepts/About-RQt.rst:57
msgid "Building From Source"
msgstr "从源代码构建"


#: ../../source/Concepts/About-RQt.rst:59
msgid "See :doc:`Building RQt from Source <../How-To-Guides/RQt-Source-Install>`."
msgstr "See :doc:`Building RQt from Source <../How-To-Guides/RQt-Source-Install>`."


#: ../../source/Concepts/About-RQt.rst:62
msgid "RQt Components Structure"
msgstr "RQt Components Structure"


#: ../../source/Concepts/About-RQt.rst:64
msgid "RQt consists of two metapackages:"
msgstr "RQt consists of two metapackages:"


#: ../../source/Concepts/About-RQt.rst:66
msgid "*rqt* - core infrastucture modules."
msgstr "*rqt* - core infrastucture modules."


#: ../../source/Concepts/About-RQt.rst:67
msgid "*rqt_common_plugins* - Commonly useful debugging tools."
msgstr "*rqt_common_plugins* - Commonly useful debugging tools."


#: ../../source/Concepts/About-RQt.rst:70
msgid "Advantage of RQt framework"
msgstr "Advantage of RQt framework"


#: ../../source/Concepts/About-RQt.rst:72
msgid "Compared to building your own GUIs from scratch:"
msgstr "Compared to building your own GUIs from scratch:"


#: ../../source/Concepts/About-RQt.rst:74
msgid "Standardized common procedures for GUI (start-shutdown hook, restore previous states)."
msgstr "Standardized common procedures for GUI (start-shutdown hook, restore previous states)."


#: ../../source/Concepts/About-RQt.rst:75
msgid "Multiple widgets can be docked in a single window."
msgstr "Multiple widgets can be docked in a single window."


#: ../../source/Concepts/About-RQt.rst:76
msgid "Easily turn your existing Qt widgets into RQt plugins."
msgstr "Easily turn your existing Qt widgets into RQt plugins."


#: ../../source/Concepts/About-RQt.rst:77
msgid "Expect support at `ROS Answers <https://answers.ros.org>`__ (ROS community website for the questions)."
msgstr "Expect support at `ROS Answers <https://answers.ros.org>`__ (ROS community website for the questions)."


#: ../../source/Concepts/About-RQt.rst:79
msgid "From system architecture's perspective:"
msgstr "From system architecture's perspective:"


#: ../../source/Concepts/About-RQt.rst:81
msgid "Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``)."
msgstr "Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``)."


#: ../../source/Concepts/About-RQt.rst:82
msgid "Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier."
msgstr "Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier."


#: ../../source/Concepts/About-RQt.rst:86
msgid "Further Reading"
msgstr "进一步阅读"


#: ../../source/Concepts/About-RQt.rst:88
msgid "ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)"
msgstr "ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)"


#: ../../source/Concepts/About-RQt.rst:89
msgid "`RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__"
msgstr "`RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__"


#: ../../source/Concepts/About-RQt.rst:90
msgid "Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)"
msgstr "Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)"


#: ../../source/Concepts/About-Security.rst:4
msgid "About ROS 2 Security"
msgstr "About ROS 2 Security"


#: ../../source/Concepts/About-Security.rst:13
msgid "Built-in ROS 2 security features enable control over communications throughout the ROS graph. This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls."
msgstr "Built-in ROS 2 security features enable control over communications throughout the ROS graph. This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls."


#: ../../source/Concepts/About-Security.rst:16
msgid "ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes. DDS vendors provide open source and commercial DDS implementations that work with ROS. However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_. ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control. DDS and ROS security is enabled through predefined configuration files and environment variables."
msgstr "ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes. DDS vendors provide open source and commercial DDS implementations that work with ROS. However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_. ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control. DDS and ROS security is enabled through predefined configuration files and environment variables."


#: ../../source/Concepts/About-Security.rst:24
msgid "The Security Enclave"
msgstr "The Security Enclave"


#: ../../source/Concepts/About-Security.rst:26
msgid "A security enclave encapsulates a single policy for protecting ROS communications. The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices. Security enclaves can be flexibly mapped to processes, users, or devices at deployment. Adjusting this default behavior becomes important for optimizing communications and for complex systems. See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details."
msgstr "A security enclave encapsulates a single policy for protecting ROS communications. The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices. Security enclaves can be flexibly mapped to processes, users, or devices at deployment. Adjusting this default behavior becomes important for optimizing communications and for complex systems. See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details."


#: ../../source/Concepts/About-Security.rst:34
msgid "Security Files"
msgstr "Security Files"


#: ../../source/Concepts/About-Security.rst:36
msgid "A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification. Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave. All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave."
msgstr "A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification. Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave. All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave."


#: ../../source/Concepts/About-Security.rst:41
msgid "Enclave Identity"
msgstr "Enclave Identity"


#: ../../source/Concepts/About-Security.rst:43
msgid "The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants. Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``. Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate. This valid certificate exchange allows the enclave to securely establish trusted communications with other participants. The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing."
msgstr "The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants. Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``. Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate. This valid certificate exchange allows the enclave to securely establish trusted communications with other participants. The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing."


#: ../../source/Concepts/About-Security.rst:50
msgid "Enclave Permissions"
msgstr "Enclave Permissions"


#: ../../source/Concepts/About-Security.rst:52
msgid "The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves. This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies. Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA. Domain members use a copy of the permissions CA to validate these signed files and grant the requested access."
msgstr "The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves. This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies. Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA. Domain members use a copy of the permissions CA to validate these signed files and grant the requested access."


#: ../../source/Concepts/About-Security.rst:57
msgid "Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority."
msgstr "Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority."


#: ../../source/Concepts/About-Security.rst:60
msgid "Private Keys"
msgstr "Private Keys"


#: ../../source/Concepts/About-Security.rst:62
msgid "The identity and permissions certificates also have associated private key files. Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key. Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key."
msgstr "The identity and permissions certificates also have associated private key files. Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key. Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key."


#: ../../source/Concepts/About-Security.rst:68
msgid "Security Environment Variables"
msgstr "Security Environment Variables"


#: ../../source/Concepts/About-Security.rst:70
msgid "The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master \"on/off\" switch for ROS 2 security features. Security has been turned off by default, so security features will not be enabled even when the proper security files are present. In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive)."
msgstr "The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master \"on/off\" switch for ROS 2 security features. Security has been turned off by default, so security features will not be enabled even when the proper security files are present. In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive)."


#: ../../source/Concepts/About-Security.rst:74
msgid "Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants. Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features. In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive)."
msgstr "Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants. Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features. In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive)."


#: ../../source/Concepts/About-Security.rst:78
msgid "Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_. These variables generally assist ROS in managing enclaves and locating the security files."
msgstr "Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_. These variables generally assist ROS in managing enclaves and locating the security files."


#: ../../source/Concepts/About-Security.rst:83
msgid "Learn More"
msgstr "Learn More"


#: ../../source/Concepts/About-Security.rst:85
msgid "For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../Tutorials/Advanced/Security/Introducing-ros2-security`."
msgstr "For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../Tutorials/Advanced/Security/Introducing-ros2-security`."


#: ../../source/Concepts/About-Tf2.rst:4
msgid "About tf2"
msgstr "About tf2"


#: ../../source/Concepts/About-Tf2.rst:13
msgid "tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time."
msgstr "tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time."


#: ../../source/Concepts/About-Tf2.rst:19
msgid "Properties of tf2"
msgstr "Properties of tf2"


#: ../../source/Concepts/About-Tf2.rst:21
msgid "A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:"
msgstr "A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:"


#: ../../source/Concepts/About-Tf2.rst:24
msgid "Where was the head frame relative to the world frame 5 seconds ago?"
msgstr "Where was the head frame relative to the world frame 5 seconds ago?"


#: ../../source/Concepts/About-Tf2.rst:25
msgid "What is the pose of the object in my gripper relative to my base?"
msgstr "What is the pose of the object in my gripper relative to my base?"


#: ../../source/Concepts/About-Tf2.rst:26
msgid "What is the current pose of the base frame in the map frame?"
msgstr "What is the current pose of the base frame in the map frame?"


#: ../../source/Concepts/About-Tf2.rst:28
msgid "tf2 can operate in a distributed system. This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system. tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information."
msgstr "tf2 can operate in a distributed system. This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system. tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information."


#: ../../source/Concepts/About-Tf2.rst:33
msgid "Tutorials"
msgstr "教程"


#: ../../source/Concepts/About-Tf2.rst:35
msgid "We created a set of :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step. You can get started on the :doc:`introduction to tf2 <../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial. For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` page."
msgstr "We created a set of :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step. You can get started on the :doc:`introduction to tf2 <../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial. For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` page."


#: ../../source/Concepts/About-Tf2.rst:39
msgid "There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms."
msgstr "There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms."


#: ../../source/Concepts/About-Tf2.rst:41
msgid "If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms. What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames. Check out the \"Writing a listener\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more."
msgstr "If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms. What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames. Check out the \"Writing a listener\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more."


#: ../../source/Concepts/About-Tf2.rst:45
msgid "To extend the capabilities of a robot, you will need to start broadcasting transforms. Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system. A system can have many broadcasters that each provide information about a different part of the robot. Check out the \"Writing a broadcaster\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more."
msgstr "To extend the capabilities of a robot, you will need to start broadcasting transforms. Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system. A system can have many broadcasters that each provide information about a different part of the robot. Check out the \"Writing a broadcaster\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more."


#: ../../source/Concepts/About-Tf2.rst:50
msgid "In addition to that, tf2 can broadcast static transforms that do not change over time. This mainly saves storage and lookup time, but also reduces the publishing overhead. You should note that static transforms are published once and assumed to not change, so no history is stored. If you want to define static transforms in your tf2 tree, take a look at the \"Writing a static broadcaster\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial."
msgstr "In addition to that, tf2 can broadcast static transforms that do not change over time. This mainly saves storage and lookup time, but also reduces the publishing overhead. You should note that static transforms are published once and assumed to not change, so no history is stored. If you want to define static transforms in your tf2 tree, take a look at the \"Writing a static broadcaster\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial."


#: ../../source/Concepts/About-Tf2.rst:55
msgid "You can also learn how to add fixed and dynamic frames to your tf2 tree in the \"Adding a frame\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial."
msgstr "You can also learn how to add fixed and dynamic frames to your tf2 tree in the \"Adding a frame\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial."


#: ../../source/Concepts/About-Tf2.rst:57
msgid "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time :doc:`(Python) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2."
msgstr "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time :doc:`(Python) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2."


#: ../../source/Concepts/About-Tf2.rst:62
msgid "Paper"
msgstr "Paper"


#: ../../source/Concepts/About-Tf2.rst:64
msgid "There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_."
msgstr "There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_."


#: ../../source/Concepts/About-Topic-Statistics.rst:8
msgid "About topic statistics"
msgstr "About topic statistics"


#: ../../source/Concepts/About-Topic-Statistics.rst:16
msgid "ROS 2 provides integrated measurement of statistics for messages received by any subscription. Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues."
msgstr "ROS 2 provides integrated measurement of statistics for messages received by any subscription. Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues."


#: ../../source/Concepts/About-Topic-Statistics.rst:21
msgid "The measurements provided are the received message age and received message period. For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count. These statistics are calculated in a moving window."
msgstr "The measurements provided are the received message age and received message period. For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count. These statistics are calculated in a moving window."


#: ../../source/Concepts/About-Topic-Statistics.rst:26
msgid "How statistics are calculated"
msgstr "How statistics are calculated"


#: ../../source/Concepts/About-Topic-Statistics.rst:28
msgid "Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package. When a new message is received by a subscription, this is a new sample for calculation in the current measurement window. The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__. The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__."
msgstr "Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package. When a new message is received by a subscription, this is a new sample for calculation in the current measurement window. The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__. The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__."


#: ../../source/Concepts/About-Topic-Statistics.rst:41
msgid "Types of statistics calculated"
msgstr "Types of statistics calculated"


#: ../../source/Concepts/About-Topic-Statistics.rst:43
msgid "Received message period"
msgstr "Received message period"


#: ../../source/Concepts/About-Topic-Statistics.rst:45 ../../source/Concepts/About-Topic-Statistics.rst:50
msgid "Units: milliseconds"
msgstr "Units: milliseconds"


#: ../../source/Concepts/About-Topic-Statistics.rst:46
msgid "Uses the system clock to measure the period between received messages"
msgstr "Uses the system clock to measure the period between received messages"


#: ../../source/Concepts/About-Topic-Statistics.rst:48
msgid "Received message age"
msgstr "Received message age"


#: ../../source/Concepts/About-Topic-Statistics.rst:51
msgid "Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher"
msgstr "Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher"


#: ../../source/Concepts/About-Topic-Statistics.rst:54
msgid "Behavior"
msgstr "Behavior"


#: ../../source/Concepts/About-Topic-Statistics.rst:56
msgid "By default, Topic Statistics measurements are not enabled. After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription."
msgstr "By default, Topic Statistics measurements are not enabled. After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription."


#: ../../source/Concepts/About-Topic-Statistics.rst:60
msgid "The data is published as a `statistics_msg/msg/MetricsMessage <https://github.com/ros2/rcl_interfaces/blob/humble/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``). Note that the publishing period also serves as the sample collection window period."
msgstr "The data is published as a `statistics_msg/msg/MetricsMessage <https://github.com/ros2/rcl_interfaces/blob/humble/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``). Note that the publishing period also serves as the sample collection window period."


#: ../../source/Concepts/About-Topic-Statistics.rst:65
msgid "Since received message period requires a message timestamp in a header field, empty data is published. That is, all statistics values are NaN if no timestamp is found. Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made."
msgstr "Since received message period requires a message timestamp in a header field, empty data is published. That is, all statistics values are NaN if no timestamp is found. Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made."


#: ../../source/Concepts/About-Topic-Statistics.rst:70
msgid "The first sample of each window for the received message period statistic does not yield a measurement. This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements."
msgstr "The first sample of each window for the received message period statistic does not yield a measurement. This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements."


#: ../../source/Concepts/About-Topic-Statistics.rst:77
msgid "Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side. Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided."
msgstr "Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side. Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided."


#: ../../source/Concepts/About-Topic-Statistics.rst:82
msgid "Support"
msgstr "Support"


#: ../../source/Concepts/About-Topic-Statistics.rst:84
msgid "This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp). Future work and improvements, such as Python support, can be found `here <https://github.com/ros2/ros2/issues/917>`__."
msgstr "This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp). Future work and improvements, such as Python support, can be found `here <https://github.com/ros2/ros2/issues/917>`__."

