# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 Documentation: Humble package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 Documentation: Humble \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-15 19:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"


#: ../../source/Concepts.rst:4
msgid "Concepts"
msgstr "概念"


#: ../../source/Concepts.rst:6
msgid "Conceptual overviews provide relatively high-level, general background information about key aspects of ROS 2."
msgstr "概念概述提供了与ROS 2的关键方面有关的相对高级的、一般性的背景信息。"


#: ../../source/Concepts.rst:29
msgid "The Core Stack Developer Concepts are much more detailed conceptual articles intended for developers who plan modify or contribute to the ROS 2 core:"
msgstr "核心堆栈开发者概念是针对计划修改或为ROS 2核心做出贡献的开发者的更加详细的概念性文章："


#: ../../source/Concepts.rst:40
msgid "Quick overview of ROS 2 Concepts"
msgstr "ROS 2概念快速概述"


#: ../../source/Concepts.rst:45
msgid "ROS 2 is a middleware based on an anonymous publish/subscribe mechanism that allows for message passing between different ROS processes."
msgstr "ROS 2是基于匿名发布/订阅机制的中间件，允许在不同的ROS进程之间传递消息。"


#: ../../source/Concepts.rst:47
msgid "At the heart of any ROS 2 system is the ROS graph. The ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate."
msgstr "在任何ROS 2系统的核心是ROS图。ROS图指的是ROS系统中节点的网络以及它们之间的连接，通过这些连接它们进行通信。"


#: ../../source/Concepts.rst:51
msgid "Graph Concepts"
msgstr "图概念"


#: ../../source/Concepts.rst:54
msgid "Nodes: A node is an entity that uses ROS to communicate with other nodes."
msgstr "节点：节点是使用ROS与其他节点进行通信的实体。"


#: ../../source/Concepts.rst:55
msgid "Messages: ROS data type used when subscribing or publishing to a topic."
msgstr "消息：在订阅或发布主题时使用的ROS数据类型。"


#: ../../source/Concepts.rst:56
msgid "Topics: Nodes can publish messages to a topic as well as subscribe to a topic to receive messages."
msgstr "主题：节点可以向主题发布消息，也可以订阅主题以接收消息。"


#: ../../source/Concepts.rst:57
msgid "Discovery: The automatic process through which nodes determine how to talk to each other."
msgstr "发现：自动处理过程，节点确定如何相互通信。"


#: ../../source/Concepts.rst:60
msgid "Nodes"
msgstr "节点"


#: ../../source/Concepts.rst:62
msgid "A node is a participant in the ROS graph. ROS nodes use a ROS client library to communicate with other nodes. Nodes can publish or subscribe to Topics. Nodes can also provide or use Services and Actions. There are configurable Parameters associated with a node. Connections between nodes are established through a distributed discovery process. Nodes may be located in the same process, in different processes, or on different machines. These concepts will be described in more detail in the sections that follow."
msgstr "节点是ROS图中的参与者。ROS节点使用ROS客户端库与其他节点通信。节点可以发布或订阅主题（Topics）。节点还可以提供或使用服务（Services）和动作（Actions）。与节点相关联的参数（Parameters）是可配置的。节点之间的连接通过分布式发现过程建立。节点可以位于同一进程、不同进程或不同机器上。这些概念将在接下来的章节中详细描述。"


#: ../../source/Concepts.rst:72
msgid "Client Libraries"
msgstr "客户端库"


#: ../../source/Concepts.rst:74
msgid "ROS client libraries allow nodes written in different programming languages to communicate. There is a core ROS client library (RCL) that implements common functionality needed for the ROS APIs of different languages. This makes it so that language-specific client libraries are easier to write and that they have more consistent behavior."
msgstr "ROS客户端库允许使用不同编程语言编写的节点进行通信。有一个核心ROS客户端库（RCL），实现了不同语言的ROS API所需的常用功能。这样可以更轻松地编写特定语言的客户端库，并使其行为更加一致。"


#: ../../source/Concepts.rst:78
msgid "The following client libraries are maintained by the ROS 2 team:"
msgstr "以下客户端库由ROS 2团队维护："


#: ../../source/Concepts.rst:81
msgid "rclcpp = C++ client library"
msgstr "rclcpp = C++ 客户端库"


#: ../../source/Concepts.rst:82
msgid "rclpy = Python client library"
msgstr "rclpy = Python 客户端库"


#: ../../source/Concepts.rst:84
msgid "Additionally, other client libraries have been developed by the ROS community. See the :doc:`ROS 2 Client Libraries <Concepts/About-ROS-2-Client-Libraries>` article for more details."
msgstr "此外，ROS 社区还开发了其他客户端库。有关详细信息，请参阅 :doc:`ROS 2 客户端库 <Concepts/About-ROS-2-Client-Libraries>` 文章。"


#: ../../source/Concepts.rst:88
msgid "Discovery"
msgstr "发现"


#: ../../source/Concepts.rst:90
msgid "Discovery of nodes happens automatically through the underlying middleware of ROS 2. It can be summarized as follows:"
msgstr "节点的发现通过 ROS 2 的底层中间件自动进行。其过程可以总结如下："


#: ../../source/Concepts.rst:93
msgid "When a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable). Nodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate."
msgstr "当启动一个节点时，它会向在同一 ROS 域（使用 ROS_DOMAIN_ID 环境变量设置）上的其他节点广告自己的存在。节点会对此广告进行响应，并提供有关自身的信息，以便建立适当的连接并进行通信。"


#: ../../source/Concepts.rst:95
msgid "Nodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period."
msgstr "节点定期广播其存在，以便在初始发现期之后能够与新发现的实体建立连接。"


#: ../../source/Concepts.rst:96
msgid "Nodes advertise to other nodes when they go offline."
msgstr "节点在离线时向其他节点进行广播。"


#: ../../source/Concepts.rst:98
msgid "Nodes will only establish connections with other nodes if they have compatible :doc:`Quality of Service <../Tutorials/Demos/Quality-of-Service>` settings."
msgstr "节点仅在具有兼容的 :doc:`服务质量 <../Tutorials/Demos/Quality-of-Service>` 设置的情况下与其他节点建立连接。"


#: ../../source/Concepts.rst:100
msgid "Take the :ref:`talker-listener demo <talker-listener>` for example. Running the C++ talker node in one terminal will publish messages on a topic, and the Python listener node running in another terminal  will subscribe to messages on the same topic."
msgstr "以 :ref:`talker-listener demo <talker-listener>` 为例。在一个终端中运行 C++ talker 节点会发布消息到一个主题上，而在另一个终端中运行的 Python listener 节点会订阅相同主题上的消息。"


#: ../../source/Concepts.rst:104
msgid "You should see that these nodes discover each other automatically, and begin to exchange messages."
msgstr "你应该看到这些节点会自动发现彼此，并开始交换消息。"


#: ../../source/Concepts.rst:107
msgid "Security"
msgstr "安全性"


#: ../../source/Concepts.rst:109
msgid "ROS 2 includes the ability to secure communications among nodes within the ROS 2 computational graph. Similar to discovery, security happens through the underlying ROS 2 middleware (provided it has support for the corresponding security plugins). No additional software installation is needed to enable security; however, the middleware requires configuration files for each ROS graph participant. These files enable encryption and authentication, and define policies both for individual nodes and for the overall ROS graph. ROS 2 also adds a master \"on/off\" switch to control security behavior."
msgstr "ROS 2 包含在 ROS 2 计算图中的节点之间进行通信安全的能力。与发现类似，安全性是通过底层的 ROS 2 中间件实现的（前提是中间件支持相应的安全插件）。启用安全性不需要额外的软件安装，但中间件需要为每个 ROS 图参与者配置文件。这些文件用于启用加密和身份验证，并为各个节点和整个 ROS 图定义策略。ROS 2 还添加了一个主要的“开/关”开关来控制安全行为。"


#: ../../source/Concepts.rst:115
msgid "ROS utilities can create the authoritative `trust anchor <https://en.wikipedia.org/wiki/Trust_anchor>`_ for a ROS application, or an external certificate authority can be used."
msgstr "ROS 实用工具可以为 ROS 应用程序创建权威的 `信任锚点 <https://en.wikipedia.org/wiki/Trust_anchor>`_，或者可以使用外部证书机构。"


#: ../../source/Concepts.rst:117
msgid "See the :doc:`ROS 2 Security <Concepts/About-Security>` article for additional details or ROS security features."
msgstr "有关详细信息或 ROS 安全功能，请参阅 :doc:`ROS 2 安全 <Concepts/About-Security>` 文章。"


#: ../../source/Concepts.rst:121
msgid "Related Content"
msgstr "相关内容"


#: ../../source/Concepts.rst:123
msgid ":doc:`See the ROS 2 citations <Citations>` for more explanation of concepts and citable resources."
msgstr "有关概念和可引用资源的更多解释，请参阅 :doc:`ROS 2 引用 <Citations>`。"


#: ../../source/Concepts.rst:125
msgid "For a brief video introduction to ROS 2, see this community contributed content:"
msgstr "要了解 ROS 2 的简介视频，请参阅社区贡献的内容："


#: ../../source/Concepts.rst:127
msgid "`Getting started with ROS Part 1: Nodes, Parameters and Topics <https://youtu.be/46TPAKXBOF8>`_"
msgstr "`ROS入门第一部分：节点、参数和话题 <https://youtu.be/46TPAKXBOF8>`_"


#: ../../source/Concepts.rst:128
msgid "`Getting started with ROS Part 2: Services and Actions <https://youtu.be/keZAJ83eEoM>`_"
msgstr "`ROS入门第二部分：服务和动作 <https://youtu.be/keZAJ83eEoM>`_"


#: ../../source/Concepts/About-Build-System.rst:2
msgid "About the build system"
msgstr "关于构建系统"


#: ../../source/Concepts/About-Build-System.rst:6
msgid "Under everything is the build system. Iterating on ``catkin`` from ROS 1, we have created a set of |packages| under the moniker ``ament``. Some of the reasons for changing the name to ``ament`` are that we wanted it to not collide with ``catkin`` (in case we want to mix them at some point) and to prevent confusion with existing ``catkin`` documentation. ``ament``'s primary responsibility is to make it easier to develop and maintain ROS 2 core |packages|. However, this responsibility extends to any user who is willing to make use of our build system conventions and tools. Additionally it should make |packages| conventional, such that developers should be able to pick up any ``ament`` based |package| and make some assumptions about how it works, how to introspect it, and how to build or use it."
msgstr "在所有东西的底层是构建系统。我们在ROS 1的基础上迭代了``catkin``，创建了一组以``ament``为名称的|packages|。改名为``ament``的一些原因是我们希望它不会与``catkin``冲突（以防将来需要混合使用）并且防止与现有的``catkin``文档混淆。``ament``的主要责任是使开发和维护ROS 2核心|packages|更加容易。然而，这个责任也延伸到任何愿意使用我们的构建系统约定和工具的用户。此外，它还应该使|packages|具有常规性，使开发人员能够了解任何基于``ament``的|package|的工作原理、内省方式以及如何构建或使用它。"


#: ../../source/Concepts/About-Build-System.rst:13
msgid "``ament`` consists of a few important repositories which are all in the ``ament`` `GitHub organization <https://github.com/ament>`_:"
msgstr "``ament``由一些重要的存储库组成，它们都位于``ament``的 `GitHub组织 <https://github.com/ament>`_ 中："


#: ../../source/Concepts/About-Build-System.rst:20
msgid "The ``ament_package`` Package"
msgstr "``ament_package``包"


#: ../../source/Concepts/About-Build-System.rst:22
msgid "Located on |GitHub|_ at `ament/ament_package <https://github.com/ament/ament_package>`_, this repository contains a single :term:`ament Python package` that provides various utilities for |ament packages|, e.g. templates for environment hooks."
msgstr "该仓库位于 |GitHub|_ 的 `ament/ament_package <https://github.com/ament/ament_package>`_，其中包含一个单独的 :term:`ament Python package`，为 |ament packages| 提供各种实用工具，例如环境钩子的模板。"


#: ../../source/Concepts/About-Build-System.rst:24
msgid "All |ament packages| must contain a single :term:`package.xml` file at the root of the package regardless of their underlying build system. The :term:`package.xml` \"manifest\" file contains information that is required in order to process and operate on a |package|. This |package| information includes things like the |package|'s name, which is globally unique, and the package's dependencies. The :term:`package.xml` file also serves as the marker file which indicates the location of the |package| on the file system."
msgstr "所有的 |ament packages| 都必须在包的根目录下包含一个名为 :term:`package.xml` 的文件，而与其底层构建系统无关。:term:`package.xml` \"清单\"文件包含了处理和操作 |package| 所需的信息。该 |package| 信息包括全局唯一的 |package| 名称和包的依赖项。:term:`package.xml` 文件还充当标记文件，指示 |package| 在文件系统中的位置。"


#: ../../source/Concepts/About-Build-System.rst:29
msgid "Parsing of the :term:`package.xml` files is provided by ``catkin_pkg`` (as in ROS 1), while functionality to locate |packages| by searching the file system for these :term:`package.xml` files is provided by build tools such as ``colcon``."
msgstr "解析 :term:`package.xml` 文件的功能由 ``catkin_pkg`` 提供（与 ROS 1 中的情况相同），而通过搜索文件系统中的这些 :term:`package.xml` 文件来定位 |packages| 的功能则由构建工具（如 ``colcon``）提供。"


#: ../../source/Concepts/About-Build-System.rst:32
msgid "package.xml"
msgstr "package.xml"


#: ../../source/Concepts/About-Build-System.rst:34
msgid "Package manifest file which marks the root of a :term:`package` and contains meta information about the :term:`package` including its name, version, description, maintainer, license, dependencies, and more. The contents of the manifest are in machine readable XML format and the contents are described in the |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ and `140 <http://www.ros.org/reps/rep-0140.html>`_, with the possibility of further modifications in future |REPs|."
msgstr "包清单文件，标记了 :term:`package` 的根目录，并包含有关 :term:`package` 的元信息，包括名称、版本、描述、维护者、许可证、依赖关系等。清单的内容以机器可读的 XML 格式呈现，内容在 |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ 和 `140 <http://www.ros.org/reps/rep-0140.html>`_ 中进行了描述，并有可能在未来的 |REPs| 中进行进一步的修改。"


#: ../../source/Concepts/About-Build-System.rst:37
msgid "So anytime some |package| is referred to as an :term:`ament package`, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using a :term:`package.xml` manifest file."
msgstr "因此，每当某个 |package| 被称为 :term:`ament package` 时，这意味着它是一个单一的软件单元（源代码、构建文件、测试、文档和其他资源），使用 :term:`package.xml` 清单文件进行描述。"


#: ../../source/Concepts/About-Build-System.rst:40
msgid "ament package"
msgstr "ament 包"


#: ../../source/Concepts/About-Build-System.rst:42
msgid "Any |package| which contains a :term:`package.xml` and follows the packaging guidelines of ``ament``, regardless of the underlying build system."
msgstr "任何包含 :term:`package.xml` 并遵循 ``ament`` 的打包准则的 |package|，不论其底层构建系统如何。"


#: ../../source/Concepts/About-Build-System.rst:44
msgid "Since the term :term:`ament package` is build system agnostic, there can be different kinds of |ament packages|, e.g. :term:`ament CMake package`, :term:`ament Python package`, etc."
msgstr "由于术语 :term:`ament package` 不依赖于构建系统，可以存在不同类型的 |ament 包|，例如 :term:`ament CMake package`，:term:`ament Python package` 等。"


#: ../../source/Concepts/About-Build-System.rst:46
msgid "Here is a list of common package types that you might run into in this software stack:"
msgstr "以下是您可能在此软件堆栈中遇到的常见包类型的列表:"


#: ../../source/Concepts/About-Build-System.rst:49
msgid "CMake package"
msgstr "CMake 包"


#: ../../source/Concepts/About-Build-System.rst:51
msgid "Any |package| containing a plain CMake project and a :term:`package.xml` manifest file."
msgstr "包含纯 CMake 项目和 :term:`package.xml` 清单文件的 |package|。"


#: ../../source/Concepts/About-Build-System.rst:52
msgid "ament CMake package"
msgstr "ament CMake package"


#: ../../source/Concepts/About-Build-System.rst:54
msgid "A :term:`CMake package` that also follows the ``ament`` packaging guidelines."
msgstr "一个遵循``ament``打包指南的:term:`CMake package`。"


#: ../../source/Concepts/About-Build-System.rst:55
msgid "Python package"
msgstr "Python package"


#: ../../source/Concepts/About-Build-System.rst:57
msgid "Any |package| containing a `setuptools <https://pypi.org/project/setuptools/>`_ based Python project and a :term:`package.xml` manifest file."
msgstr "包含基于`setuptools <https://pypi.org/project/setuptools/>`_的Python项目和一个:term:`package.xml`清单文件的任何|package|。"


#: ../../source/Concepts/About-Build-System.rst:58
msgid "ament Python package"
msgstr "ament Python package"


#: ../../source/Concepts/About-Build-System.rst:60
msgid "A :term:`Python package` that also follows the ``ament`` packaging guidelines."
msgstr "一个遵循``ament``打包指南的:term:`Python package`。"


#: ../../source/Concepts/About-Build-System.rst:63
msgid "The ``ament_cmake`` Repository"
msgstr "``ament_cmake`` 仓库"


#: ../../source/Concepts/About-Build-System.rst:65
msgid "Located on |GitHub|_ at `ament/ament_cmake <https://github.com/ament/ament_cmake>`_, this repository contains many \"ament CMake\" and pure CMake packages which provide the infrastructure in CMake that is required to create \"ament CMake\" packages. In this context \"ament CMake\" packages means: ``ament`` packages that are built using CMake. So the |packages| in this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more \"ament CMake\" (or ``ament_cmake``) packages. Packages of this type are identified with the ``<build_type>ament_cmake</build_type>`` tag in the ``<export>`` tag of the :term:`package.xml` file."
msgstr "该仓库位于 |GitHub|_ 上的 `ament/ament_cmake <https://github.com/ament/ament_cmake>`_，包含许多“ament CMake”和纯 CMake 包，提供了在 CMake 中创建“ament CMake”包所需的基础设施。在这个上下文中，“ament CMake”包的意思是：使用 CMake 构建的 ``ament`` 包。因此，这个仓库中的 |packages| 提供了必要的 CMake 函数/宏和 CMake 模块，以便更轻松地创建更多的“ament CMake”（或 ``ament_cmake``）包。这种类型的包在 :term:`package.xml` 文件的 ``<export>`` 标签中用 ``<build_type>ament_cmake</build_type>`` 标记识别。"


#: ../../source/Concepts/About-Build-System.rst:70
msgid "The |packages| in this repository are extremely modular, but there is a single \"bottleneck\" |package| called ``ament_cmake``. Anyone can depend on the ``ament_cmake`` |package| to get all of the aggregate functionality of the |packages| in this repository. Here a list of the |packages| in the repository along with a short description:"
msgstr "这个仓库中的 |packages| 非常模块化，但有一个单一的“瓶颈” |package|，名为 ``ament_cmake``。任何人都可以依赖于 ``ament_cmake`` |package|，以获取该仓库中所有 |packages| 的聚合功能。下面是仓库中的 |packages| 列表及其简短描述："


#: ../../source/Concepts/About-Build-System.rst:74
msgid "``ament_cmake``"
msgstr "``ament_cmake``"


#: ../../source/Concepts/About-Build-System.rst:76
msgid "aggregates all other |packages| in this repository, users need only to depend on this"
msgstr "聚合了该仓库中的所有其他 |packages|，用户只需依赖它"


#: ../../source/Concepts/About-Build-System.rst:78
msgid "``ament_cmake_auto``"
msgstr "``ament_cmake_auto``"


#: ../../source/Concepts/About-Build-System.rst:80
msgid "provides convenience CMake functions which automatically handle a lot of the tedious parts of writing a |package|'s ``CMakeLists.txt`` file"
msgstr "提供了方便的CMake函数，自动处理撰写|package|的``CMakeLists.txt``文件中的许多繁琐部分"


#: ../../source/Concepts/About-Build-System.rst:82
msgid "``ament_cmake_core``"
msgstr "``ament_cmake_core``"


#: ../../source/Concepts/About-Build-System.rst:84
msgid "provides all built-in core concepts for ``ament``, e.g. environment hooks, resource indexing, symbolic linking install and others"
msgstr "提供了``ament``的所有内置核心概念，例如环境钩子、资源索引、符号链接安装等"


#: ../../source/Concepts/About-Build-System.rst:86
msgid "``ament_cmake_gmock``"
msgstr "``ament_cmake_gmock``"


#: ../../source/Concepts/About-Build-System.rst:88
msgid "adds convenience functions for making gmock based unit tests"
msgstr "添加了方便的函数，用于创建基于gmock的单元测试"


#: ../../source/Concepts/About-Build-System.rst:90
msgid "``ament_cmake_gtest``"
msgstr "``ament_cmake_gtest``"


#: ../../source/Concepts/About-Build-System.rst:92
msgid "adds convenience functions for making gtest based automated tests"
msgstr "为使用 gtest 进行自动化测试提供了方便的函数"


#: ../../source/Concepts/About-Build-System.rst:94
msgid "``ament_cmake_nose``"
msgstr "``ament_cmake_nose``"


#: ../../source/Concepts/About-Build-System.rst:96
msgid "adds convenience functions for making nosetests based python automated tests"
msgstr "为使用 nosetests 进行 Python 自动化测试提供了方便的函数"


#: ../../source/Concepts/About-Build-System.rst:98
msgid "``ament_cmake_python``"
msgstr "``ament_cmake_python``"


#: ../../source/Concepts/About-Build-System.rst:100
msgid "provides CMake functions for |packages| that contain Python code"
msgstr "为包含 Python 代码的 |packages| 提供了 CMake 函数"


#: ../../source/Concepts/About-Build-System.rst:101
msgid "see the :doc:`ament_cmake_python user documentation <../How-To-Guides/Ament-CMake-Python-Documentation>`"
msgstr "请参阅 :doc:`ament_cmake_python 用户文档 <../How-To-Guides/Ament-CMake-Python-Documentation>`"


#: ../../source/Concepts/About-Build-System.rst:103
msgid "``ament_cmake_test``"
msgstr "``ament_cmake_test``"


#: ../../source/Concepts/About-Build-System.rst:105
msgid "aggregates different kinds of tests, e.g. gtest and nosetests, under a single target using `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_"
msgstr "聚合不同类型的测试，例如 gtest 和 nosetests，在一个目标下使用 `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_"


#: ../../source/Concepts/About-Build-System.rst:107
msgid "The ``ament_cmake_core`` |package| contains a lot of the CMake infrastructure that makes it possible to cleanly pass information between |packages| using conventional interfaces. This makes the |packages| have more decoupled build interfaces with other |packages|, promoting their reuse and encouraging conventions in the build systems of different |packages|. For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies between |packages| so that consumers of this information can access this information in a conventional way."
msgstr "``ament_cmake_core`` |package| 包含了许多 CMake 基础设施，通过传统的接口，在 |packages| 之间清晰地传递信息成为可能。这使得 |packages| 具有更加解耦的构建接口，促进了它们之间的重用，并在不同 |packages| 的构建系统中鼓励约定。例如，它提供了一种标准的方式来在 |packages| 之间传递包含目录、库、定义和依赖关系，以便使用者可以以常规方式访问这些信息。"


#: ../../source/Concepts/About-Build-System.rst:111
msgid "The ``ament_cmake_core`` |package| also provides features of the ``ament`` build system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them. This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect. This feature essentially replaces the \"devel space\" from ``catkin`` because it has most of the advantages with few of the complications or drawbacks."
msgstr "``ament_cmake_core`` |package| 还提供了 ``ament`` 构建系统的功能，如符号链接安装。它允许您从源空间或构建空间中的文件以符号链接的方式链接到安装空间，而不是复制它们。这样，您可以安装一次，然后编辑非生成的资源，如 Python 代码和配置文件，而无需重新运行安装步骤使其生效。这个特性本质上取代了 ``catkin`` 中的“devel space”，因为它具有大部分优势，却没有太多复杂性或缺点。"


#: ../../source/Concepts/About-Build-System.rst:115
msgid "Another feature provided by ``ament_cmake_core`` is the |package| resource indexing which is a way for |packages| to indicate that they contain a resource of some type. The design of this feature makes it much more efficient to answer simple questions like what |packages| are in this prefix (e.g. ``/usr/local``) because it only requires that you list the files in a single possible location under that prefix. You can read more about this feature in the `design docs <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`_ for the resource index."
msgstr "``ament_cmake_core`` 还提供了另一个特性，即 |package| 资源索引，它是一种让 |packages| 指示它们包含某种类型资源的方法。这个特性的设计使得回答简单问题变得更加高效，比如在这个前缀下有哪些 |packages|（例如 ``/usr/local``），因为它只需要列出该前缀下的一个可能位置的文件列表。您可以在 `设计文档 <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`_ 中了解更多关于这个特性的信息。"


#: ../../source/Concepts/About-Build-System.rst:119
msgid "Like ``catkin``, ``ament_cmake_core`` also provides environment setup files and |package| specific environment hooks. The environment setup files, often named something like ``setup.bash``, are a place for |package| developers to define changes to the environment that are needed to utilize their |package|. The developers are able to do this using an \"environment hook\" which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc... This feature is how, for example, ROS 1 set the ``ROS_DISTRO`` environment variable without ``catkin`` knowing anything about the ROS distribution."
msgstr "和 ``catkin`` 类似，``ament_cmake_core`` 还提供了环境设置文件和 |package| 特定的环境钩子。环境设置文件通常命名为 ``setup.bash`` 等，是 |package| 开发者定义更改环境以利用他们的 |package| 的地方。开发者可以使用 \"环境钩子\" 来实现这一点，它基本上是一段任意的 shell 代码，可以设置或修改环境变量，定义 shell 函数，设置自动补全规则等等。例如，这个特性是 ROS 1 在不需要 ``catkin`` 知道 ROS 分发的情况下设置 `"


#: ../../source/Concepts/About-Build-System.rst:125
msgid "The ``ament_lint`` Repository"
msgstr "``ament_lint`` 仓库"


#: ../../source/Concepts/About-Build-System.rst:127
msgid "Located on |GitHub|_ at `ament/ament_lint <https://github.com/ament/ament_lint>`_, this repository provides several |packages| which provide linting and testing services in a convenient and consistent manner. Currently there are |packages| to support C++ style linting using ``uncrustify``, static C++ code checks using ``cppcheck``, checking for copyright in source code, Python style linting using ``pep8``, and other things. The list of helper packages will likely grow in the future."
msgstr "位于 |GitHub|_ 上的 `ament/ament_lint <https://github.com/ament/ament_lint>`_，该仓库提供了多个 |packages|，以便以便捷且一致的方式提供代码检查和测试服务。目前有 |packages| 支持使用 ``uncrustify`` 进行 C++ 代码风格检查，使用 ``cppcheck`` 进行静态 C++ 代码检查，检查源代码中的版权问题，使用 ``pep8`` 进行 Python 代码风格检查，以及其他功能。未来可能会增加更多辅助包的列表。"


#: ../../source/Concepts/About-Build-System.rst:132
msgid "Build tools"
msgstr "构建工具"


#: ../../source/Concepts/About-Build-System.rst:134
msgid "A build tool performs the task of building a workspace of packages together at once with a single invocation. For ROS 2 releases up to Ardent, the build tool providing this functionality is called ``ament_tools``. As of ROS 2 Bouncy, ``ament_tools`` has been superseded by ``colcon``, as described in `the universal build tool article <http://design.ros2.org/articles/build_tool.html>`_."
msgstr "构建工具可以一次性构建一个包工作空间中的多个包。对于 ROS 2 的版本，从 Ardent 版本开始，提供这一功能的构建工具叫做 ``ament_tools``。从 ROS 2 Bouncy 版本开始，``ament_tools`` 已经被 ``colcon`` 取代，详见 `通用构建工具文章 <http://design.ros2.org/articles/build_tool.html>`_。"


#: ../../source/Concepts/About-Catment.rst:6
msgid "On the mixing of ament and catkin (catment)"
msgstr "关于 ament 和 catkin 的混合 (catment)"


#: ../../source/Concepts/About-Catment.rst:8
msgid "**All that follows is experimental and speculative.**"
msgstr "**下面的内容都是实验性和推测性的。**"


#: ../../source/Concepts/About-Catment.rst:12 ../../source/Concepts/About-Command-Line-Tools.rst:11 ../../source/Concepts/About-Composition.rst:6 ../../source/Concepts/About-Executors.rst:7 ../../source/Concepts/About-Logging.rst:11 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:13 ../../source/Concepts/About-ROS-2-Parameters.rst:11 ../../source/Concepts/About-ROS-Interfaces.rst:11 ../../source/Concepts/About-RQt.rst:13 ../../source/Concepts/About-Security.rst:8 ../../source/Concepts/About-Tf2.rst:8 ../../source/Concepts/About-Topic-Statistics.rst:11
msgid "Table of Contents"
msgstr "目录"


#: ../../source/Concepts/About-Catment.rst:15
msgid "Background"
msgstr "背景"


#: ../../source/Concepts/About-Catment.rst:17
msgid "There once was a thing called ``rosbuild``. Then came a thing called ``catkin``, which largely replaced ``rosbuild``. Recently introduced is a thing called ``ament``, which may one day replace ``catkin``."
msgstr "曾经有一个叫做 ``rosbuild`` 的东西。然后出现了一个叫做 ``catkin`` 的东西，它在很大程度上取代了 ``rosbuild``。最近引入了一个叫做 ``ament`` 的东西，有朝一日可能会取代 ``catkin``。"


#: ../../source/Concepts/About-Catment.rst:21
msgid "All three tools can be considered \"meta-build systems\". They sit atop other build systems (e.g. CMake, Python setuptools) and provide extra functionality that's intended to make those build systems easier to use, especially when managing dependencies across multiple packages and when building multiple packages in a single workspace."
msgstr "这三个工具都可以被称为“元构建系统”。它们位于其他构建系统之上（例如 CMake、Python setuptools），并提供额外的功能，旨在使这些构建系统更易于使用，特别是在管理多个软件包之间的依赖关系和在单个工作空间中构建多个软件包时。"


#: ../../source/Concepts/About-Catment.rst:24
msgid "Each of these meta-build systems does two things:"
msgstr "每个元构建系统都有两个功能："


#: ../../source/Concepts/About-Catment.rst:28
msgid "Adds an API to the underlying build system (e.g. CMake) that can be used to simplify common tasks (e.g. supplying all the flags exported by depended-upon packages when building an executable). There are usually hooks to allow injection of extra APIs by packages outside of the core meta-build system."
msgstr "1. 向底层构建系统（如 CMake）添加一个 API，用于简化常见任务（例如，在构建可执行文件时提供由依赖包导出的所有标志）。通常可以通过核心元构建系统之外的软件包注入额外的 API。"


#: ../../source/Concepts/About-Catment.rst:32
msgid "``rosbuild``: ``mk/cmake.mk``, ``rosbuild_init()``, ``rosbuild_add_executable()``, etc."
msgstr "``rosbuild``：``mk/cmake.mk``、``rosbuild_init()``、``rosbuild_add_executable()`` 等。"


#: ../../source/Concepts/About-Catment.rst:33
msgid "``catkin``: ``catkin_package()``, ``catkin_install_python()``, etc."
msgstr "``catkin``：``catkin_package()``、``catkin_install_python()`` 等。"


#: ../../source/Concepts/About-Catment.rst:34
msgid "``ament``: ``ament_target_dependencies()``, ``ament_export_dependencies()``, ``ament_package()``, etc."
msgstr "``ament``: ``ament_target_dependencies()``, ``ament_export_dependencies()``, ``ament_package()``, 等等。"


#: ../../source/Concepts/About-Catment.rst:37
msgid "Provides a tool that can be used to iterate in dependency order over a workspace full of packages, building and perhaps installing each one."
msgstr "提供了一个工具，可以按照依赖顺序遍历一个包含多个软件包的工作空间，构建并可能安装每个软件包。"


#: ../../source/Concepts/About-Catment.rst:40
msgid "``rosbuild``: ``rosmake``"
msgstr "``rosbuild``: ``rosmake``"


#: ../../source/Concepts/About-Catment.rst:41
msgid "``catkin``: ``catkin build``, ``catkin_make``, ``catkin_make_isolated``, etc."
msgstr "``catkin``: ``catkin build``, ``catkin_make``, ``catkin_make_isolated``，等等。"


#: ../../source/Concepts/About-Catment.rst:42
msgid "``ament``: ``ament build``"
msgstr "``ament``: ``ament build``"


#: ../../source/Concepts/About-Catment.rst:44
msgid "The common thread that ties all of these systems together is the division of the code into **packages**\\ , with each package containing a manifest file (``manifest.xml`` or ``package.xml``). This manifest is required (with some exceptions) for both parts of the meta-build system (API and build tool) to function."
msgstr "将所有这些系统联系在一起的共同线索是将代码划分为**包**，每个包包含一个清单文件（``manifest.xml`` 或 ``package.xml``）。这个清单文件对于元构建系统的两个部分（API 和构建工具）都是必需的（有一些例外），以便其正常运行。"


#: ../../source/Concepts/About-Catment.rst:48
msgid "Postulates"
msgstr "假设"


#: ../../source/Concepts/About-Catment.rst:51
msgid "**While we usually consider the two aspects of a meta-build system to be coupled, they needn't be.** The API used inside a package and the tool that iterates over the packages can be considered largely independent, with the package manifest forming the interface between them. There's no reason in principle why, for example, ``rosmake`` couldn't be modified to iterate over a workspace filled with ``catkin`` packages, stepping into them in dependency order and doing the usual ``mkdir build; cd build; cmake ..; make install`` routine for each one (with appropriate flags passed to ``cmake`` and ``make``)."
msgstr "**尽管我们通常认为元构建系统的两个方面是耦合在一起的，但它们并不一定是。**包内部使用的API和迭代包的工具可以被认为是相互独立的，而包清单则形成了它们之间的接口。原则上没有理由不这样做，例如，“rosmake”可以被修改为在一个充满“catkin”包的工作空间中进行迭代，按照依赖顺序进入每个包，并对每个包执行通常的“mkdir build; cd build; cmake ..; make install”例程（同时向“cmake”和“make”传递适当的标志）"


#: ../../source/Concepts/About-Catment.rst:55
msgid "**The effort required to migrate from one meta-build system to another should be minimized.** The mass migration from ``rosbuild`` to ``catkin`` was difficult and remains a sore point for many in the community. While it's reasonable to ask developers to make changes in exchange for getting access to new functionality, the changes that are required should be as small as possible without sacrificing the effectiveness of the new system. This is especially true when the old system is in widespread use."
msgstr "**将从一个元构建系统迁移到另一个的工作量应该最小化。**从“rosbuild”迁移到“catkin”的大规模迁移对社区的许多人来说都是困难的，仍然是一个痛点。虽然要求开发者做出改变以获得新功能是合理的，但所需的改变应该尽可能小，而不会牺牲新系统的有效性。当旧系统被广泛使用时，这一点尤为重要"


#: ../../source/Concepts/About-Catment.rst:61
msgid "Corollary: **Migration to a new meta-build system should not be required without a very good reason.** If a developer doesn't want the functionality offered by the new system, then they shouldn't be coerced into migrating from the old system unless there's something irrevocably broken about the old system (e.g. ``rosbuild``\\ 's in-source build pattern and lack of an \"install\" step)."
msgstr "推论：**除非有非常充分的理由，否则不应要求迁移到新的元构建系统。**如果开发者不需要新系统提供的功能，那么除非旧系统出现了不可挽回的问题（例如，“rosbuild”的源代码构建模式和缺乏“install”步骤），否则不应强制他们从旧系统迁移"


#: ../../source/Concepts/About-Catment.rst:65
msgid "**Interoperability is a good thing.** Whenever possible (not all combinations will be practical), developers should be able to mix and match meta-build systems, including mixing their different aspects (i.e., use the building tool from one system and the API from another). Such mixing and matching is especially important when developers want to combine a large existing codebase using one meta-build system (e.g. ROS with ``catkin``) with new libraries and tools offered by a codebase using another meta-build system (e.g. ROS 2 with ``ament``). Ideally, that kind of combination can be done without requiring changes to the API used by either codebase and without telling the developer which builder tool to use."
msgstr "**互操作性是一件好事。**只要可能（并非所有组合都是实际可行的），开发者应该能够混合和匹配元构建系统，包括混合使用它们的不同方面（即，使用一个系统的构建工具和另一个系统的API）。当开发者想要将使用一个元构建系统（如ROS与“catkin”）的大型现有代码库与使用另一个元构建系统（如ROS 2与“ament”）的代码库提供的新库和工具结合起来时，这种混合和匹配尤其重要。理想情况下，这种组合可以在不要求任何代码库使用的API进行更改的情况下完成，也不会告诉开发者使用哪个构建工具"


#: ../../source/Concepts/About-Catment.rst:71
msgid "Corollary: **Workspaces needn't be homogeneous.** There's no reason that we shouldn't be able to freely mix, say, ``catkin`` and ``ament`` packages in one workspace, with dependencies going in both directions, so long as the builder tool in use knows how to build them both. The primary interface between packages (at least, CMake-controlled packages) is their CMake configuration file. So long as that configuration file follows the standard protocol (setting ``foo_LIBRARIES``, etc.), then it shouldn't matter who wrote the file. It could be auto-generated by ``catkin`` or ``ament``, or even manually crafted by a developer who wants to use plain CMake in their package, but still have that package depended-upon by ``catkin`` or ``ament`` packages."
msgstr "推论：**工作空间不需要是同构的。**只要正在使用的构建工具知道如何构建它们，我们就没有理由不允许在一个工作空间中自由混合使用“catkin”和“amen"


#: ../../source/Concepts/About-Catment.rst:78
msgid "Use cases, with experimental implementations"
msgstr "使用案例和实验性实现"


#: ../../source/Concepts/About-Catment.rst:81
msgid "Adding ROS packages to a ROS 2 workspace and building with ``ament build``"
msgstr "将ROS包添加到ROS 2工作空间并使用``ament build``进行构建"


#: ../../source/Concepts/About-Catment.rst:83
msgid "Let's say that you want to add some existing ROS packages to your ROS 2 workspace and don't want to migrate the ROS packages from ``catkin`` to ``ament`` (or vice versa). Here are two patches that let you do that:"
msgstr "假设您想将一些现有的ROS包添加到您的ROS 2工作空间，并且不想将ROS包从``catkin``迁移到``ament``（或反之亦然）。以下是两个补丁，可以实现此功能："


#: ../../source/Concepts/About-Catment.rst:86
msgid "`ament_package <https://github.com/ament/ament_package/compare/catkin?expand=1>`__: Adds support for format 1 package manifests, instead of requiring format 2. This change isn't strictly related to ``catkin`` vs. ``ament``, because format 2 has been around for a while and ``catkin`` supports it, so developers could already update their manifests to format 2. But there's a ton of ROS code out there that uses format 1, so we should support it. This implementation could be improved, e.g. by reasoning over the various flavors of depend tags and how they differ between formats 1 and 2."
msgstr "`ament_package <https://github.com/ament/ament_package/compare/catkin?expand=1>`__：添加对格式1包清单的支持，而不是要求格式2。此更改与``catkin``与``ament``的关系并不严格相关，因为格式2已经存在一段时间了，并且``catkin``也支持它，所以开发者已经可以将其清单更新为格式2。但是，有很多使用格式1的ROS代码存在，因此我们应该支持它。这个实现可以改进，例如通过推理各种依赖标签的不同之处，以及格式1和2之间的差异。"


#: ../../source/Concepts/About-Catment.rst:91
msgid "`ament_tools <https://github.com/ament/ament_tools/compare/catkin?expand=1>`__: Adds a new ``catkin`` build type to ``ament``. This implementation just treats ``catkin`` packages the same as plain ``cmake`` packages, which seems to work fine. It could be made more sophisticated."
msgstr "`ament_tools <https://github.com/ament/ament_tools/compare/catkin?expand=1>`__：向``ament``添加了一个新的``catkin``构建类型。该实现将``catkin``包与普通``cmake``包视为相同，似乎工作正常。可以使其更加复杂。"


#: ../../source/Concepts/About-Catment.rst:96
msgid "Example usage:"
msgstr "示例用法："


#: ../../source/Concepts/About-Catment.rst:99
msgid "Get the ROS 2 code as usual, using the branches mentioned above."
msgstr "按照通常的方式获取ROS 2代码，使用上述提到的分支。"


#: ../../source/Concepts/About-Catment.rst:100
msgid "Add to your workspace some ``catkin`` ROS packages, ensuring that all of their dependencies are satisfied (either present in the workspace or installed elsewhere with appropriate setup shell files sourced)."
msgstr "向您的工作空间中添加一些``catkin`` ROS软件包，确保它们的所有依赖项都得到满足（要么在工作空间中存在，要么通过适当的设置shell文件在其他位置安装）。"


#: ../../source/Concepts/About-Catment.rst:101
msgid "Build as usual (e.g. ``colcon build``)."
msgstr "像往常一样构建（例如``colcon build``）。"


#: ../../source/Concepts/About-Catment.rst:103
msgid "Voila: your existing code isn't suddenly broken just because there's a new build tool in use."
msgstr "完成了：由于使用了新的构建工具，您现有的代码不会突然中断。"


#: ../../source/Concepts/About-Catment.rst:106
msgid "Variation: Building ROS packages with ``ament build``"
msgstr "变种：使用``ament build``构建ROS软件包"


#: ../../source/Concepts/About-Catment.rst:108
msgid "Let's say that you love the new ``ament`` tool and want to use it to build your existing ROS packages that use ``catkin`` internally. Here's an example of how to do that, by doing a minimal installation of ``ament`` and then using it to build a workspace full of ROS ``catkin`` packages:"
msgstr "假设您喜欢新的``ament``工具，并希望使用它来构建使用``catkin``的现有ROS软件包。以下是一个示例，演示如何通过最小安装``ament``并使用它构建一个由ROS``catkin``软件包填充的工作空间："


#: ../../source/Concepts/About-Catment.rst:126
msgid "Now build the ROS packages:"
msgstr "现在构建ROS软件包："


#: ../../source/Concepts/About-Catment.rst:134
msgid "Voila: you used the ``ament`` build tool to build your ``catkin`` packages, without having to migrate them."
msgstr "看哪：你使用了``ament``构建工具来构建你的``catkin``软件包，而无需迁移它们。"


#: ../../source/Concepts/About-Catment.rst:137
msgid "Variation: Using the ``catkin`` API in a ROS 2 package"
msgstr "变化：在ROS 2软件包中使用``catkin`` API"


#: ../../source/Concepts/About-Catment.rst:139
msgid "Let's say that you're building on top of ROS 2, which internally uses the ``ament`` API, and you want to add a new package using the ``catkin`` API."
msgstr "假设你正在构建基于ROS 2的软件包，它在内部使用``ament`` API，并且你想要添加一个使用``catkin`` API的新软件包。"


#: ../../source/Concepts/About-Catment.rst:141
msgid "To make this work, you need a Python3 installation of ``catkin`` (the binary debians use Python2.7). Here's an example of doing that, installing to ``$HOME/catkin``:"
msgstr "为了使其工作，你需要一个Python 3安装的``catkin``（二进制Debian包使用Python 2.7）。这里是一个安装到``$HOME/catkin``的示例："


#: ../../source/Concepts/About-Catment.rst:160
msgid "To use that version of catkin, you just need to source the ``$HOME/catkin/setup.bash`` file."
msgstr "要使用那个版本的catkin，你只需要source ``$HOME/catkin/setup.bash``文件。"


#: ../../source/Concepts/About-Catment.rst:162
msgid "Let's assume that you have the usual ROS 2 workspace in ``~/ros2_ws``, and that you're on the ``catkin`` branches in ``ament_package`` and ``ament_tools``. Add to that workspace the ``image_tools_catkin`` package from https://github.com/gerkey/catment. It's a simple port of the ROS 2 ``image_tools`` package, taking it from the ``ament`` API to the ``catkin`` API. To build it:"
msgstr "假设您在``~/ros2_ws``中有一个常规的ROS 2工作空间，并且您在``ament_package``和``ament_tools``的``catkin``分支上。在该工作空间中添加来自https://github.com/gerkey/catment的``image_tools_catkin``包。它是ROS 2 ``image_tools``包的一个简单移植，将其从``ament`` API转换为``catkin`` API。要构建它："


#: ../../source/Concepts/About-Catment.rst:173
msgid "Voila: when adding new packages atop ROS 2, you're free to choose which CMake API you prefer inside your package."
msgstr "大功告成：在构建ROS 2上的新包时，您可以自由选择首选的CMake API来编写您的包。"


#: ../../source/Concepts/About-Catment.rst:176
msgid "**Caveat**: Requires commenting out the use of ``CATKIN_DEPENDS`` inside ``catkin_package()``, because somewhere somebody was getting upset that things like ``rclcpp`` aren't ``catkin`` packages. That constraint needs to be relaxed somehow."
msgstr "**注意**：需要在``catkin_package()``中注释掉对``CATKIN_DEPENDS``的使用，因为某个地方有人因为像``rclcpp``之类的不是``catkin``包而感到不满。需要以某种方式放宽这个约束。"


#: ../../source/Concepts/About-Catment.rst:178
msgid "**TODO**: The same demo but with an ``ament`` package that depends on a ``catkin`` package (this is easy)."
msgstr "**TODO**：使用依赖于``catkin``包的``ament``包进行相同的演示（这很容易）。"


#: ../../source/Concepts/About-Catment.rst:179
msgid "**TODO**: The same demo but with a package that has a vanilla ``CMakeLists.txt`` that uses neither ``ament`` nor ``catkin``, and provides a manually generated ``fooConfig.cmake`` file that exports the right stuff to make it look the same to outsiders."
msgstr "**TODO**：使用既不使用``ament``也不使用``catkin``的普通``CMakeLists.txt``的包进行相同的演示，并提供一个手动生成的``fooConfig.cmake``文件，向外部提供正确的内容以使其看起来与外部包相同。"


#: ../../source/Concepts/About-Catment.rst:182
msgid "Building ROS 2 packages with ``catkin_make_isolated``"
msgstr "使用``catkin_make_isolated``构建ROS 2包"


#: ../../source/Concepts/About-Catment.rst:184
msgid "Let's say that you're already familiar with ROS and ``catkin`` and you're excited to try ROS 2, but you're not in the mood to learn about ``ament``. You'd rather stick to what you know, such as using ``catkin_make_isolated`` to build everything. Here is a patch that allows you to do that:"
msgstr "假设您已经熟悉ROS和`catkin`，并且很想尝试ROS 2，但又不想学习关于`ament`的知识。您更愿意坚持您所了解的，比如使用`catkin_make_isolated`来构建所有内容。下面是一个补丁，可以让您这样做："


#: ../../source/Concepts/About-Catment.rst:189
msgid "`catkin <https://github.com/ros/catkin/compare/ament?expand=1>`__: Adds support for packages that declare themselves to have a build type of ``ament_*``. This implementation calls out to ``ament`` to build each such package. While ``ament_cmake`` packages can be treated as plain ``cmake`` packages (as we did when adding ``catkin`` support to ``ament``), ``ament_python`` packages require some gnarly invocations of Python. Instead of trying to replicate that logic in ``catkin``, it's easier to just let ``ament`` handle it. Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when building."
msgstr "`catkin <https://github.com/ros/catkin/compare/ament?expand=1>`__：为声明自己具有``ament_*``构建类型的软件包添加支持。此实现调用``ament``来构建每个此类软件包。尽管可以将``ament_cmake``软件包视为普通的``cmake``软件包（就像我们在为``ament``添加``catkin``支持时所做的那样），但是``ament_python``软件包需要一些复杂的Python调用。与其试图在``catkin``中复制该逻辑，不如让``ament``来处理会更容易。此外，在此补丁中，我们将``buildtool_export_depend``软件包添加到构建时考虑的软件包集合中。"


#: ../../source/Concepts/About-Catment.rst:195
msgid "`catkin_pkg <https://github.com/ros-infrastructure/catkin_pkg/compare/ament?expand=1>`__: Also in this patch, we add the ``buildtool_export_depend`` packages to the set that are considered when computing the topological order."
msgstr "`catkin_pkg <https://github.com/ros-infrastructure/catkin_pkg/compare/ament?expand=1>`__：在此补丁中，我们还将``buildtool_export_depend``软件包添加到计算拓扑顺序时考虑的集合中。"


#: ../../source/Concepts/About-Catment.rst:198
msgid "Because we're going to call out to ``ament build``, we will also need a minimal installation of ``ament``, as done in a previous example:"
msgstr "由于我们将调用``ament build``，我们还需要一个最小的``ament``安装，就像在之前的示例中一样："


#: ../../source/Concepts/About-Catment.rst:215
msgid "Then we need to install the modified version of catkin somewhere:"
msgstr "然后，我们需要将修改后的catkin版本安装在某个位置："


#: ../../source/Concepts/About-Catment.rst:233
msgid "Now build the ROS 2 packages:"
msgstr "现在构建ROS 2软件包："


#: ../../source/Concepts/About-Catment.rst:243
msgid "Voila: you've built ROS 2 using the tools that you're familiar with."
msgstr "瞧！你使用你熟悉的工具构建了ROS 2。"


#: ../../source/Concepts/About-Catment.rst:246
msgid "**Caveat**: we're ignoring the ``eProsima`` packages in the workspace because they lack ``package.xml`` files, which means that ``catkin`` can't see them. ``ament`` has some heuristics for handling such packages. Options: backport those heuristics to ``catkin``; switch to installing non-``package.xml``-containing packages outside of the workspace; or just add a ``package.xml`` to each of those packages (e.g. in our own fork)."
msgstr "**注意**：我们忽略了工作空间中的``eProsima``包，因为它们缺少``package.xml``文件，这意味着``catkin``无法识别它们。``ament``有一些处理此类包的启发式方法。选项：将这些启发式方法回溯到``catkin``；将不包含``package.xml``文件的包安装到工作空间之外；或者只需在这些包中添加``package.xml``（例如，在我们自己的分支中）。"


#: ../../source/Concepts/About-Catment.rst:251
msgid "Combining all of ROS and ROS 2 in one workspace and building it (TODO)"
msgstr "将ROS和ROS 2组合在一个工作空间中，并进行构建（待完成）。"


#: ../../source/Concepts/About-Catment.rst:253
msgid "This step will require sorting out some things, including at least:"
msgstr "这一步将需要解决一些问题，至少包括以下内容："


#: ../../source/Concepts/About-Catment.rst:255
msgid "Package name conflicts. We currently have ROS 2 versions of ROS message packages, as well as some stuff in ``geometry2``. Either the functionality needs to be merged into one package that can support both systems, or the new versions need different names."
msgstr "包名称冲突。我们目前有ROS消息包的ROS 2版本，以及``geometry2``中的一些内容。要么将功能合并到一个可以支持两个系统的包中，要么新版本需要有不同的名称。"


#: ../../source/Concepts/About-Catment.rst:258
msgid "Message generation. ROS and ROS 2 have different message generation steps, the output of which might or might not conflict. Something sophisticated needs to be done to allow generation of all the right artifacts from a single message package (or, as indicated above, the new message packages need different names)."
msgstr "消息生成。ROS和ROS 2有不同的消息生成步骤，其输出可能会发生冲突，也可能不会。需要进行一些复杂的处理，以允许从单个消息包生成所有正确的构件（或者如上所示，新的消息包需要有不同的名称）。"


#: ../../source/Concepts/About-Catment.rst:263
msgid "Using ``bloom`` to release ``ament`` packages (TODO)"
msgstr "使用 ``bloom`` 发布 ``ament`` 包（待办）"


#: ../../source/Concepts/About-Catment.rst:265
msgid "It seems like ``bloom`` ought be able to release packages that use the ``ament`` CMake API, and that the resulting releases should be able to be built on the farm. We can make changes to ``bloom`` and ``ros_buildfarm`` as needed to enable this use case."
msgstr "似乎 ``bloom`` 应该能够发布使用 ``ament`` CMake API 的包，并且生成的发布版本应该能够在 farm 上构建。我们可以根据需要对 ``bloom`` 和 ``ros_buildfarm`` 进行更改，以支持这种用例。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:7
msgid "Introspection with command line tools"
msgstr "使用命令行工具进行内省"


#: ../../source/Concepts/About-Command-Line-Tools.rst:13
msgid "ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system."
msgstr "ROS 2 包含一套命令行工具，用于内省 ROS 2 系统。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:16
msgid "Usage"
msgstr "用法"


#: ../../source/Concepts/About-Command-Line-Tools.rst:18
msgid "The main entry point for the tools is the command ``ros2``, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more."
msgstr "工具的主要入口点是命令 ``ros2``，它本身有各种子命令，用于内省和处理节点、主题、服务等。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:20
msgid "To see all available sub-commands run:"
msgstr "要查看所有可用的子命令，请运行："


#: ../../source/Concepts/About-Command-Line-Tools.rst:26
msgid "Examples of sub-commands that are available include:"
msgstr "可用的子命令示例包括："


#: ../../source/Concepts/About-Command-Line-Tools.rst:29
msgid "action: Introspect/interact with ROS actions"
msgstr "action: 检测/交互 ROS 动作"


#: ../../source/Concepts/About-Command-Line-Tools.rst:30
msgid "bag: Record/play a rosbag"
msgstr "bag: 记录/播放 rosbag"


#: ../../source/Concepts/About-Command-Line-Tools.rst:31
msgid "component: Manage component containers"
msgstr "component: 管理组件容器"


#: ../../source/Concepts/About-Command-Line-Tools.rst:32
msgid "daemon: Introspect/configure the ROS 2 daemon"
msgstr "daemon: 检测/配置 ROS 2 守护进程"


#: ../../source/Concepts/About-Command-Line-Tools.rst:33
msgid "doctor: Check ROS setup for potential issues"
msgstr "doctor: 检查ROS设置是否存在潜在问题"


#: ../../source/Concepts/About-Command-Line-Tools.rst:34
msgid "interface: Show information about ROS interfaces"
msgstr "interface: 显示关于ROS接口的信息"


#: ../../source/Concepts/About-Command-Line-Tools.rst:35
msgid "launch: Run/introspect a launch file"
msgstr "launch: 运行/检查启动文件"


#: ../../source/Concepts/About-Command-Line-Tools.rst:36
msgid "lifecycle: Introspect/manage nodes with managed lifecycles"
msgstr "lifecycle: 检查/管理具有托管生命周期的节点"


#: ../../source/Concepts/About-Command-Line-Tools.rst:37
msgid "node: Introspect ROS nodes"
msgstr "node: 检查ROS节点"


#: ../../source/Concepts/About-Command-Line-Tools.rst:38
msgid "param: Introspect/configure parameters on a node"
msgstr "param: 在节点上进行参数检查/配置"


#: ../../source/Concepts/About-Command-Line-Tools.rst:39
msgid "pkg: Introspect ROS packages"
msgstr "pkg：查看ROS软件包"


#: ../../source/Concepts/About-Command-Line-Tools.rst:40
msgid "run: Run ROS nodes"
msgstr "run：运行ROS节点"


#: ../../source/Concepts/About-Command-Line-Tools.rst:41
msgid "security: Configure security settings"
msgstr "security：配置安全设置"


#: ../../source/Concepts/About-Command-Line-Tools.rst:42
msgid "service: Introspect/call ROS services"
msgstr "service：查看/调用ROS服务"


#: ../../source/Concepts/About-Command-Line-Tools.rst:43
msgid "test: Run a ROS launch test"
msgstr "test：运行ROS启动测试"


#: ../../source/Concepts/About-Command-Line-Tools.rst:44
msgid "topic: Introspect/publish ROS topics"
msgstr "topic：查看/发布ROS主题"


#: ../../source/Concepts/About-Command-Line-Tools.rst:45
msgid "trace: Tracing tools to get information on ROS nodes execution (only available on Linux)"
msgstr "追踪：获取有关ROS节点执行的信息的工具（仅适用于Linux）"


#: ../../source/Concepts/About-Command-Line-Tools.rst:48
msgid "Example"
msgstr "示例"


#: ../../source/Concepts/About-Command-Line-Tools.rst:50
msgid "To produce the typical talker-listener example using command-line tools, the ``topic`` sub-command can be used to publish and echo messages on a topic."
msgstr "要使用命令行工具生成典型的发布者-订阅者示例，可以使用“topic”子命令在主题上发布和回显消息。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:52
msgid "Publish messages in one terminal with:"
msgstr "在一个终端中发布消息："


#: ../../source/Concepts/About-Command-Line-Tools.rst:62
msgid "Echo messages received in another terminal with:"
msgstr "在另一个终端中回显接收到的消息："


#: ../../source/Concepts/About-Command-Line-Tools.rst:72
msgid "Behind the scenes"
msgstr "幕后"


#: ../../source/Concepts/About-Command-Line-Tools.rst:74
msgid "ROS 2 uses a distributed discovery process for nodes to connect to each other. As this process purposefully does not use a centralized discovery mechanism (like the ROS Master in ROS 1), it can take time for ROS nodes to discover all other participants in the ROS graph. Because of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names."
msgstr "ROS 2使用分布式发现过程使节点彼此连接。由于这个过程有意不使用集中式发现机制（如ROS 1中的ROS主节点），因此ROS节点发现ROS图中所有其他参与者可能需要一些时间。因此，后台有一个长时间运行的守护程序，用于存储关于ROS图的信息，以提供更快的查询响应，例如节点名称列表。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:78
msgid "The daemon is automatically started when the relevant command-line tools are used for the first time. You can run ``ros2 daemon --help`` for more options for interacting with the daemon."
msgstr "当首次使用相关命令行工具时，守护程序将自动启动。您可以运行``ros2 daemon --help``获取与守护程序交互的更多选项。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:82
msgid "Implementation"
msgstr "实现"


#: ../../source/Concepts/About-Command-Line-Tools.rst:84
msgid "The source code for the ``ros2`` command is available at https://github.com/ros2/ros2cli."
msgstr "``ros2``命令的源代码可在https://github.com/ros2/ros2cli上获得。"


#: ../../source/Concepts/About-Command-Line-Tools.rst:86
msgid "The ``ros2`` tool has been implemented as a framework that can be extended via plugins. For example, the `sros2 <https://github.com/ros2/sros2>`__ package provides a ``security`` sub-command that is automatically detected by the ``ros2`` tool if the ``sros2`` package is installed."
msgstr "``ros2``工具已作为一个可通过插件进行扩展的框架实现。例如，如果安装了``sros2``包，则``ros2``工具会自动检测到`sros2 <https://github.com/ros2/sros2>`__包提供的``security``子命令。"


#: ../../source/Concepts/About-Composition.rst:2
msgid "About Composition"
msgstr "关于组合"


#: ../../source/Concepts/About-Composition.rst:9
msgid "ROS 1 - Nodes vs. Nodelets"
msgstr "ROS 1 - 节点 vs. Nodelets"


#: ../../source/Concepts/About-Composition.rst:11
msgid "In ROS 1 you can write your code either as a `ROS node <https://wiki.ros.org/Nodes>`__ or as a `ROS nodelet <https://wiki.ros.org/nodelet>`__. ROS 1 nodes are compiled into executables. ROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process."
msgstr "在ROS 1中，您可以将代码编写为 `ROS节点 <https://wiki.ros.org/Nodes>`__ 或 `ROS nodelet <https://wiki.ros.org/nodelet>`__。ROS 1节点被编译为可执行文件。另一方面，ROS 1 nodelet被编译为共享库，然后由容器进程在运行时加载。"


#: ../../source/Concepts/About-Composition.rst:16
msgid "ROS 2 - Unified API"
msgstr "ROS 2 - 统一API"


#: ../../source/Concepts/About-Composition.rst:18
msgid "In ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a ``Component``. This makes it easy to add common concepts to existing code, like a `life cycle <https://design.ros2.org/articles/node_lifecycle.html>`__. Having different APIs, which was the biggest drawback in ROS 1, is avoided in ROS 2 since both approaches use the same API."
msgstr "在ROS 2中，编写代码的推荐方式类似于nodelet - 我们称之为 ``Component``。这使得向现有代码添加常见概念变得容易，例如 `生命周期 <https://design.ros2.org/articles/node_lifecycle.html>`__。ROS 1中的最大缺点是具有不同的API，而在ROS 2中通过使用相同的API来避免了这个问题。"


#: ../../source/Concepts/About-Composition.rst:24
msgid "It is still possible to use the node-like style of \"writing your own main\" but for the common case it is not recommended."
msgstr "仍然可以使用类似节点的\"编写自己的main\"的方式，但对于常见情况，不建议这样做。"


#: ../../source/Concepts/About-Composition.rst:27
msgid "By making the process layout a deploy-time decision the user can choose between:"
msgstr "通过使进程布局成为部署时的决策，用户可以在以下选项之间进行选择："


#: ../../source/Concepts/About-Composition.rst:30
msgid "running multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and"
msgstr "以独立进程运行多个节点，具有进程/故障隔离的优点，以及更容易调试单个节点。"


#: ../../source/Concepts/About-Composition.rst:31
msgid "running multiple nodes in a single process with the lower overhead and optionally more efficient communication (see :doc:`Intra Process Communication <../Tutorials/Demos/Intra-Process-Communication>`)."
msgstr "在单个进程中运行多个节点，降低开销，并可选择更高效的通信方式（参见 :doc:`Intra Process Communication <../Tutorials/Demos/Intra-Process-Communication>`）。"


#: ../../source/Concepts/About-Composition.rst:33
msgid "Additionally ``ros2 launch`` can be used to automate these actions through specialized launch actions."
msgstr "此外，``ros2 launch`` 可以通过专门的启动操作来自动化这些操作。"


#: ../../source/Concepts/About-Composition.rst:37
msgid "Writing a Component"
msgstr "编写组件"


#: ../../source/Concepts/About-Composition.rst:39
msgid "Since a component is only built into a shared library, it doesn't have a ``main`` function (see `Talker source code <https://github.com/ros2/demos/blob/humble/composition/src/talker_component.cpp>`__). A component is commonly a subclass of ``rclcpp::Node``. Since it is not in control of the thread, it shouldn't perform any long running or blocking tasks in its constructor. Instead, it can use timers to get periodic notifications. Additionally, it can create publishers, subscriptions, servers, and clients."
msgstr "由于组件仅构建为共享库，因此它没有``main``函数（请参见 `Talker源代码 <https://github.com/ros2/demos/blob/humble/composition/src/talker_component.cpp>`__）。组件通常是 ``rclcpp::Node`` 的子类。由于它无法控制线程，因此不应在构造函数中执行任何长时间运行或阻塞的任务。相反，它可以使用计时器来获取周期性通知。此外，它还可以创建发布器、订阅器、服务器和客户端。"


#: ../../source/Concepts/About-Composition.rst:45
msgid "An important aspect of making such a class a component is that the class registers itself using macros from the package ``rclcpp_components`` (see the last line in the source code). This makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point."
msgstr "使此类成为组件的一个重要方面是，该类使用来自 ``rclcpp_components`` 包的宏进行注册（请参见源代码的最后一行）。这使得在将其库加载到正在运行的进程中时，组件可以被发现-它充当了一种入口点。"


#: ../../source/Concepts/About-Composition.rst:48
msgid "Additionally, once a component is created, it must be registered with the index to be discoverable by the tooling."
msgstr "另外，一旦创建了一个组件，它必须在索引中注册，以便工具能够发现它。"


#: ../../source/Concepts/About-Composition.rst:59
msgid "In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace."
msgstr "为了使组件容器能够找到所需的组件，必须在已经加载了相应工作空间的shell中执行或启动它。"


#: ../../source/Concepts/About-Composition.rst:64
msgid "Using Components"
msgstr "使用组件"


#: ../../source/Concepts/About-Composition.rst:66
msgid "The `composition <https://github.com/ros2/demos/tree/humble/composition>`__ package contains a couple of different approaches on how to use components. The three most common ones are:"
msgstr "`composition <https://github.com/ros2/demos/tree/humble/composition>`__ 包中包含了几种不同的使用组件的方法。最常见的三种方法是："


#: ../../source/Concepts/About-Composition.rst:70
msgid "Start a (`generic container process <https://github.com/ros2/rclcpp/blob/humble/rclcpp_components/src/component_container.cpp>`__) and call the ROS service `load_node <https://github.com/ros2/rcl_interfaces/blob/humble/composition_interfaces/srv/LoadNode.srv>`__ offered by the container. The ROS service will then load the component specified by the passed package name and library name and start executing it within the running process. Instead of calling the ROS service programmatically you can also use a `command line tool <https://github.com/ros2/ros2cli/tree/humble/ros2component>`__ to invoke the ROS service with the passed command line arguments"
msgstr "启动一个 (`generic container process <https://github.com/ros2/rclcpp/blob/humble/rclcpp_components/src/component_container.cpp>`__) 并调用容器提供的 ROS 服务 `load_node <https://github.com/ros2/rcl_interfaces/blob/humble/composition_interfaces/srv/LoadNode.srv>`__。ROS 服务将加载由传递的包名和库名指定的组件，并在运行的进程中开始执行它。除了通过编程方式调用 ROS 服务，您还可以使用 `command line tool <https://github.com/ros2/ros2cli/tree/humble/ros2component>`__ 来使用传递的命令行参数调用 ROS 服务。"


#: ../../source/Concepts/About-Composition.rst:73
msgid "Create a `custom executable <https://github.com/ros2/demos/blob/humble/composition/src/manual_composition.cpp>`__ containing multiple nodes which are known at compile time. This approach requires that each component has a header file (which is not strictly needed for the first case)."
msgstr "创建一个 `custom executable <https://github.com/ros2/demos/blob/humble/composition/src/manual_composition.cpp>`__，其中包含在编译时已知的多个节点。这种方法要求每个组件都有一个头文件（对于第一种情况并非严格需要）。"


#: ../../source/Concepts/About-Composition.rst:75
msgid "Create a launch file and use ``ros2 launch`` to create a container process with multiple components loaded."
msgstr "创建一个启动文件，并使用``ros2 launch``创建一个包含多个组件的容器进程。"


#: ../../source/Concepts/About-Composition.rst:78
msgid "Practical application"
msgstr "实际应用"


#: ../../source/Concepts/About-Composition.rst:80
msgid "Try the :doc:`Composition demos <../Tutorials/Intermediate/Composition>`."
msgstr "尝试使用:doc:`Composition演示 <../Tutorials/Intermediate/Composition>`。"


#: ../../source/Concepts/About-Cross-Compilation.rst:2
msgid "About Cross-compilation"
msgstr "关于交叉编译"


#: ../../source/Concepts/About-Cross-Compilation.rst:5 ../../source/Concepts/About-Domain-ID.rst:6 ../../source/Concepts/About-Executors.rst:10 ../../source/Concepts/About-Logging.rst:14 ../../source/Concepts/About-Quality-of-Service-Settings.rst:10 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:16 ../../source/Concepts/About-ROS-2-Parameters.rst:14 ../../source/Concepts/About-RQt.rst:16 ../../source/Concepts/About-Security.rst:11 ../../source/Concepts/About-Tf2.rst:11 ../../source/Concepts/About-Topic-Statistics.rst:14
msgid "Overview"
msgstr "概述"


#: ../../source/Concepts/About-Cross-Compilation.rst:10
msgid "Open Robotics provides pre-built ROS 2 packages for multiple platforms, but a number of developers still rely on `cross-compilation <https://en.wikipedia.org/wiki/Cross_compiler>`__ for different reasons such as:"
msgstr "Open Robotics为多个平台提供预构建的ROS 2软件包，但一些开发者仍然出于不同的原因依赖于`交叉编译 <https://en.wikipedia.org/wiki/Cross_compiler>`__，例如："


#: ../../source/Concepts/About-Cross-Compilation.rst:8
msgid "The development machine does not match the target system."
msgstr "开发机器与目标系统不匹配。"


#: ../../source/Concepts/About-Cross-Compilation.rst:9
msgid "Tuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3)."
msgstr "调整构建以适应特定的核心架构（例如，在为树莓派3构建时设置 -mcpu=cortex-a53 -mfpu=neon-fp-armv8）。"


#: ../../source/Concepts/About-Cross-Compilation.rst:10
msgid "Targeting a file system other than the ones supported by the pre-built images released by Open Robotics."
msgstr "针对Open Robotics发布的预构建映像不支持的文件系统进行定制。"


#: ../../source/Concepts/About-Cross-Compilation.rst:13
msgid "How does it work ?"
msgstr "它是如何工作的？"


#: ../../source/Concepts/About-Cross-Compilation.rst:15
msgid "Cross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain."
msgstr "交叉编译简单的软件（例如，没有依赖于外部库）相对简单，只需要使用交叉编译工具链代替本机工具链。"


#: ../../source/Concepts/About-Cross-Compilation.rst:20
msgid "There are a number of factors which make this process more complex:"
msgstr "有一些因素使这个过程更加复杂："


#: ../../source/Concepts/About-Cross-Compilation.rst:18
msgid "The software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code."
msgstr "正在构建的软件必须支持目标架构。根据目标架构，在构建过程中必须正确隔离和启用特定于架构的代码。例如，包括汇编代码。"


#: ../../source/Concepts/About-Cross-Compilation.rst:19
msgid "All dependencies (e.g. libraries) must be present, either as pre-built or cross-compiled packages, before the target software using them is cross-compiled."
msgstr "所有依赖项（例如库）在目标软件进行交叉编译之前必须存在，可以是预构建的或交叉编译的软件包。"


#: ../../source/Concepts/About-Cross-Compilation.rst:20
msgid "When building software stacks (as opposed to standalone software) using build tools (e.g. colcon), it is expected that the build tool provides a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each piece of software in the stack."
msgstr "在使用构建工具（例如colcon）构建软件堆栈（而不是独立软件）时，预计构建工具提供一种机制，允许开发人员在堆栈中每个软件所使用的底层构建系统上启用交叉编译。"


#: ../../source/Concepts/About-Cross-Compilation.rst:23
msgid "Cross-compiling ROS 2"
msgstr "ROS 2交叉编译"


#: ../../source/Concepts/About-Cross-Compilation.rst:25
msgid "The ROS 2 cross-compile tool is under shared ownership of Open Robotics and ROS Tooling Working Group. It is a Python script that compiles ROS 2 source files for supported target architectures using an emulator in a docker container. Detailed design of the tool can be found on `ROS 2 design <https://design.ros2.org/articles/cc_build_tools.html>`__. Instructions to use the tool are in the `cross_compile package <https://github.com/ros-tooling/cross_compile>`__."
msgstr "ROS 2交叉编译工具由Open Robotics和ROS Tooling工作组共同拥有。它是一个Python脚本，使用docker容器中的模拟器为支持的目标架构编译ROS 2源文件。有关该工具的详细设计，请参阅`ROS 2设计文档<https://design.ros2.org/articles/cc_build_tools.html>`__。使用该工具的说明在`cross_compile package <https://github.com/ros-tooling/cross_compile>`__中。"


#: ../../source/Concepts/About-Cross-Compilation.rst:30
msgid "If you are using an older version, please follow the :doc:`cross-compilation guide <../How-To-Guides/Cross-compilation>`."
msgstr "如果您使用的是旧版本，请参考 :doc:`交叉编译指南 <../How-To-Guides/Cross-compilation>`。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:6
msgid "About different ROS 2 DDS/RTPS vendors"
msgstr "关于不同的ROS 2 DDS/RTPS供应商"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:8
msgid "ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation. `This article <https://design.ros2.org/articles/ros_on_dds.html>`__ explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail. In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different \"Quality of Service\" options for the transportation."
msgstr "ROS 2构建在DDS/RTPS之上作为其中间件，它提供了发现、序列化和传输功能。`本文 <https://design.ros2.org/articles/ros_on_dds.html>`__详细解释了使用DDS实现或DDS的RTPS传输协议的动机。简而言之，DDS是一种端到端中间件，提供了与ROS系统相关的功能，例如分布式发现（不像ROS 1那样集中化）以及对传输的不同“服务质量”选项的控制。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:12
msgid "`DDS <https://www.omg.org/omg-dds-portal>`__ is an industry standard which is implemented by a range of vendors, such as RTI's `Connext DDS <https://www.rti.com/products/>`__, eProsima's `Fast DDS <https://fast-dds.docs.eprosima.com/>`__, Eclipse's `Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__, or GurumNetworks's `GurumDDS <https://gurum.cc/index_eng>`__. RTPS (a.k.a. `DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\\ ) is the wire protocol used by DDS to communicate over the network."
msgstr "`DDS <https://www.omg.org/omg-dds-portal>`__是一个行业标准，由许多供应商实现，例如RTI的`Connext DDS <https://www.rti.com/products/>`__，eProsima的`Fast DDS <https://fast-dds.docs.eprosima.com/>`__，Eclipse的`Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__或GurumNetworks的`GurumDDS <https://gurum.cc/index_eng>`__。RTPS（也称为`DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\\ ）是DDS在网络上通信的传输协议。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:15
msgid "ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily \"one size fits all\" when it comes to choosing a vendor/implementation. There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint. Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs. For example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time)."
msgstr "ROS 2支持多个DDS/RTPS实现，因为在选择供应商/实现时，并不一定是“一刀切”。在选择中间件实现时，可能会考虑多个因素：例如许可证等物流考虑因素，平台可用性或计算资源占用等技术考虑因素。供应商可能会提供多个针对满足不同需求的DDS或RTPS实现。例如，RTI有几个Connext实现的变体，用途不同，比如专门针对微控制器的一种，以及针对需要特殊安全认证的应用程序的另一种（目前我们仅支持其标准桌面版本）。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:20
msgid "In order to use a DDS/RTPS implementation with ROS 2, a \"\\ **R**\\ OS **M**\\ iddle\\ **w**\\ are interface\" (a.k.a. ``rmw`` interface or just ``rmw``\\ ) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation's API and tools. It's a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project's needs."
msgstr "为了在ROS 2中使用DDS/RTPS实现，需要创建一个“ROS中间件接口”（也称为``rmw``接口或仅称为``rmw``）包，该包使用DDS或RTPS实现的API和工具来实现抽象的ROS中间件接口。为了支持DDS实现而实现和维护RMW包是一项繁重的工作，但至少支持几个实现对于确保ROS 2代码库不与任何特定实现绑定是重要的，因为用户可能希望根据项目需求切换实现。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:24
msgid "Supported RMW implementations"
msgstr "支持的RMW实现"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:29
msgid "Product name"
msgstr "产品名称"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:30
msgid "License"
msgstr "许可证"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:31
msgid "RMW implementation"
msgstr "RMW实现"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:32
msgid "Status"
msgstr "状态"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:33
msgid "eProsima *Fast DDS*"
msgstr "eProsima *Fast DDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:34
msgid "Apache 2"
msgstr "Apache 2"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:35
msgid "``rmw_fastrtps_cpp``"
msgstr "``rmw_fastrtps_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:36
msgid "Full support. Default RMW. Packaged with binary releases."
msgstr "完全支持。默认RMW。与二进制发行版一起打包。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:37
msgid "Eclipse *Cyclone DDS*"
msgstr "Eclipse *Cyclone DDS*"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:38
msgid "Eclipse Public License v2.0"
msgstr "Eclipse公共许可证v2.0"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:39
msgid "``rmw_cyclonedds_cpp``"
msgstr "``rmw_cyclonedds_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:40
msgid "Full support. Packaged with binary releases."
msgstr "完全支持。与二进制发行版一起打包。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:41
msgid "RTI *Connext DDS*"
msgstr "RTI *Connext DDS*（商业、研究）"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:42
msgid "commercial, research"
msgstr "commercial（商业）、research（研究）"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:43
msgid "``rmw_connextdds``"
msgstr "``rmw_connextdds``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:44
msgid "Full support. Support included in binaries, but Connext installed separately."
msgstr "完全支持。支持已包含在二进制文件中，但Connext需单独安装。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:45
msgid "GurumNetworks *GurumDDS*"
msgstr "GurumNetworks *GurumDDS*（商业）"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:46
msgid "commercial"
msgstr "商业"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:47
msgid "``rmw_gurumdds_cpp``"
msgstr "``rmw_gurumdds_cpp``"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:48
msgid "Community support. Support included in binaries, but GurumDDS installed separately."
msgstr "社区支持。支持包含在二进制文件中，但GurumDDS需要单独安装。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:50
msgid "For practical information on working with multiple RMW implementations, see the :doc:`\"Working with multiple RMW implementations\" <../How-To-Guides/Working-with-multiple-RMW-implementations>` tutorial."
msgstr "有关使用多个RMW实现的实用信息，请参阅 :doc:`\"使用多个RMW实现\" <../How-To-Guides/Working-with-multiple-RMW-implementations>` 教程。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:53
msgid "Multiple RMW implementations"
msgstr "多个RMW实现"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:55
msgid "The ROS 2 binary releases for currently active distros have built-in support for several RMW implementations out of the box (Fast DDS, RTI Connext Pro, Eclipse Cyclone DDS, GurumNetworks GurumDDS). The default is Fast DDS, which works without any additional installation steps because we distribute it with our binary packages."
msgstr "当前活跃的ROS 2二进制发布版本已经内置了对多个RMW实现的支持（Fast DDS、RTI Connext Pro、Eclipse Cyclone DDS、GurumNetworks GurumDDS）。默认使用的是Fast DDS，因为我们将其与二进制包一起分发，所以无需进行任何额外的安装步骤。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:58
msgid "Other RMWs like Cyclone DDS, Connext or GurumDDS can be enabled by :doc:`installing additional packages <../Installation/DDS-Implementations>`, but without having to rebuild anything or replace any existing packages."
msgstr "其他像Cyclone DDS、Connext或GurumDDS这样的RMW可以通过:doc:`安装附加包 <../Installation/DDS-Implementations>`进行启用，但无需重新构建任何内容或替换任何现有包。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:60
msgid "A ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously. While the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured. For example, if the code for the `RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__ is in the workspace, it will be built if an installation of RTI's Connext Pro can also be found."
msgstr "从源代码构建的ROS 2工作空间可以同时构建和安装多个RMW实现。在编译核心ROS 2代码时，如果发现了任何RMW实现，并且相关的DDS/RTPS实现已经正确安装并配置了相关的环境变量，那么这些RMW实现将会被构建。例如，如果工作空间中存在`RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__的代码，那么如果还可以找到RTI的Connext Pro的安装，它也将被构建。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:64
msgid "For many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances. Here is a list of inter-vendor communication configurations that are not supported:"
msgstr "在许多情况下，使用不同RMW实现的节点可以进行通信，但并非在所有情况下都成立。以下是不支持的跨厂商通信配置列表："


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:67
msgid "Fast DDS <-> Connext"
msgstr "Fast DDS <-> Connext"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:68
msgid "``WString`` published by Fast DDS can't be received correctly by Connext on macOS"
msgstr "在macOS上，Fast DDS发布的``WString``无法被Connext正确接收"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:70
msgid "Connext <-> Cyclone DDS"
msgstr "Connext <-> Cyclone DDS"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:70
msgid "does not support pub/sub communication for ``WString``"
msgstr "不支持 ``WString`` 类型的发布/订阅通信"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:73
msgid "Default RMW implementation"
msgstr "默认的RMW实现"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:75
msgid "If a ROS 2 workspace has multiple RMW implementations, Fast DDS is selected as the default RMW implementation if it is available. If the Fast DDS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used. The implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. ``rmw_cyclonedds_cpp``. For example, if both ``rmw_cyclonedds_cpp`` and ``rmw_connextdds`` ROS packages are installed, ``rmw_connextdds`` would be the default. If ``rmw_fastrtps_cpp`` is ever installed, it would be the default."
msgstr "如果一个ROS 2工作空间有多个RMW实现，如果可用的话会选择Fast DDS作为默认的RMW实现。如果未安装Fast DDS的RMW实现，将使用按字母顺序排列的第一个RMW实现标识符的RMW实现。实现标识符是提供RMW实现的ROS软件包的名称，例如 ``rmw_cyclonedds_cpp``。例如，如果安装了 ``rmw_cyclonedds_cpp`` 和 ``rmw_connextdds`` 两个ROS软件包，``rmw_connextdds`` 将成为默认的。如果以后安装了 ``rmw_fastrtps_cpp``，它将成为默认的。"


#: ../../source/Concepts/About-Different-Middleware-Vendors.rst:81
msgid "See the :doc:`guide <../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to specify which RMW implementation is to be used when running the ROS 2 examples."
msgstr "请参考 :doc:`指南 <../How-To-Guides/Working-with-multiple-RMW-implementations>`，了解如何在运行ROS 2示例时指定要使用的RMW实现。"


#: ../../source/Concepts/About-Domain-ID.rst:3
msgid "The ROS_DOMAIN_ID"
msgstr "ROS_DOMAIN_ID"


#: ../../source/Concepts/About-Domain-ID.rst:8
msgid "As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS. In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. All ROS 2 nodes use domain ID 0 by default. To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group."
msgstr "如其他地方所解释的，ROS 2用于通信的默认中间件是DDS。在DDS中，不同逻辑网络共享物理网络的主要机制被称为Domain ID。同一域中的ROS 2节点可以自由地发现和相互发送消息，而不同域中的ROS 2节点则不能。所有ROS 2节点默认使用域ID 0。为了避免在同一网络上运行ROS 2的不同计算机组之间的干扰，应为每个组设置不同的域ID。"


#: ../../source/Concepts/About-Domain-ID.rst:15
msgid "Choosing a domain ID (short version)"
msgstr "选择域ID（简短版本）"


#: ../../source/Concepts/About-Domain-ID.rst:17
msgid "The text below explains the derivation of the range of domain IDs that should be used in ROS 2. To skip that background and just choose a safe number, simply choose a domain ID between 0 and 101, inclusive."
msgstr "下面的文本解释了应在ROS 2中使用的域ID范围的推导过程。如果想跳过这些背景知识，只需选择一个安全的数字，简单地选择一个介于0和101之间（包括0和101）的域ID即可。"


#: ../../source/Concepts/About-Domain-ID.rst:22
msgid "Choosing a domain ID (long version)"
msgstr "选择域ID（详细版本）"


#: ../../source/Concepts/About-Domain-ID.rst:24
msgid "The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication. See `this article <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__ for details on how the ports are computed. Remembering our basic networking, the UDP port is an `unsigned 16-bit integer <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__. Thus, the highest port number that can be allocated is 65535. Doing some math with the formula in the article above, this means that the highest domain ID that can possibly be assigned is 232, while the lowest that can be assigned is 0."
msgstr "域ID由DDS用于计算用于发现和通信的UDP端口。有关端口计算的详细信息，请参阅`此文章 <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__。根据我们的基本网络知识，UDP端口是一个`无符号16位整数 <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__。因此，最高可以分配的端口号是65535。通过使用上述文章中的公式进行一些计算，可以得知可能分配的最高域ID是232，而最低域ID是0。"


#: ../../source/Concepts/About-Domain-ID.rst:31
msgid "Platform-specific constraints"
msgstr "平台特定约束"


#: ../../source/Concepts/About-Domain-ID.rst:33
msgid "For maximum compatibility, some additional platform-specific constraints should be followed when choosing a domain ID. In particular, it is best to avoid allocating domain IDs in the operating system's `ephemeral port range <https://en.wikipedia.org/wiki/Ephemeral_port>`__. This avoids possible conflicts between the ports used by the ROS 2 nodes and other networking services on the computers."
msgstr "为了最大兼容性，在选择域ID时应遵循一些额外的平台特定约束。特别是，在操作系统的`临时端口范围 <https://en.wikipedia.org/wiki/Ephemeral_port>`__中最好避免分配域ID。这样可以避免ROS 2节点和计算机上其他网络服务之间可能的端口冲突。"


#: ../../source/Concepts/About-Domain-ID.rst:37
msgid "Here are some platform-specific notes about ephemeral ports."
msgstr "以下是有关临时端口的特定平台注意事项。"


#: ../../source/Concepts/About-Domain-ID.rst:41
msgid "Linux"
msgstr "Linux"


#: ../../source/Concepts/About-Domain-ID.rst:43
msgid "By default, the Linux kernel uses ports 32768-60999 for ephemeral ports. This means that domain IDs 0-101 and 215-232 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Linux by setting custom values in ``/proc/sys/net/ipv4/ip_local_port_range``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "默认情况下，Linux内核使用32768-60999的端口作为临时端口。这意味着域ID为0-101和215-232的端口可以安全使用，不会与临时端口冲突。在Linux中，可以通过在``/proc/sys/net/ipv4/ip_local_port_range``中设置自定义值来配置临时端口范围。如果使用自定义临时端口范围，则可能需要相应地调整上述数字。"


#: ../../source/Concepts/About-Domain-ID.rst:48
msgid "macOS"
msgstr "macOS"


#: ../../source/Concepts/About-Domain-ID.rst:50
msgid "By default, the ephemeral port range on macOS is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in macOS by setting custom sysctl values for ``net.inet.ip.portrange.first`` and ``net.inet.ip.portrange.last``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "默认情况下，macOS的临时端口范围是49152-65535。这意味着域ID为0-166的端口可以安全使用，不会与临时端口冲突。在macOS中，可以通过设置``net.inet.ip.portrange.first``和``net.inet.ip.portrange.last``的自定义sysctl值来配置临时端口范围。如果使用自定义临时端口范围，则可能需要相应地调整上述数字。"


#: ../../source/Concepts/About-Domain-ID.rst:55
msgid "Windows"
msgstr "Windows"


#: ../../source/Concepts/About-Domain-ID.rst:57
msgid "By default, the ephemeral port range on Windows is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Windows by `using netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr "默认情况下，Windows 上的临时端口范围是49152-65535。这意味着可以安全地使用域ID 0-166，而不会与临时端口冲突。在 Windows 中，可以通过`使用 netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__ 来配置临时端口范围。如果使用了自定义的临时端口范围，上述数字可能需要相应地进行调整。"


#: ../../source/Concepts/About-Domain-ID.rst:63
msgid "Participant constraints"
msgstr "参与者限制"


#: ../../source/Concepts/About-Domain-ID.rst:65
msgid "For each ROS 2 process running on a computer, one DDS \"participant\" is created. Since each DDS participant takes up two ports on the computer, running more than 120 ROS 2 processes on one computer may spill over into other domain IDs or the ephemeral ports."
msgstr "在计算机上运行的每个 ROS 2 进程都会创建一个 DDS“参与者”。由于每个 DDS 参与者占用计算机上的两个端口，如果在一台计算机上运行超过120个 ROS 2 进程，则可能会溢出到其他域ID或临时端口。"


#: ../../source/Concepts/About-Domain-ID.rst:68
msgid "To see why, consider the domain IDs 1 and 2."
msgstr "为了理解原因，请考虑域ID 1和2。"


#: ../../source/Concepts/About-Domain-ID.rst:70
msgid "Domain ID 1 uses port 7650 and 7651 for multicast."
msgstr "域ID 1使用端口7650和7651进行组播。"


#: ../../source/Concepts/About-Domain-ID.rst:71
msgid "Domain ID 2 uses port 7900 and 7901 for multicast."
msgstr "域ID 2使用端口7900和7901进行组播。"


#: ../../source/Concepts/About-Domain-ID.rst:72
msgid "When creating the 1st process (zeroth participant) in domain ID 1, the ports 7660 and 7661 are used for unicast."
msgstr "在创建域ID为1的第一个进程（第零个参与者）时，使用端口7660和7661进行单播。"


#: ../../source/Concepts/About-Domain-ID.rst:73
msgid "When creating the 120th process (119th participant) in domain ID 1, the ports 7898 and 7899 are used for unicast."
msgstr "在创建域ID为1的第120个进程（第119个参与者）时，使用端口7898和7899进行单播。"


#: ../../source/Concepts/About-Domain-ID.rst:74
msgid "When creating the 121st process (120th participant) in domain ID 1, the ports 7900 and 7901 are used for unicast and overlap with domain ID 2."
msgstr "在创建域ID为1的第121个进程（第120个参与者）时，使用端口7900和7901进行单播，并与域ID为2重叠。"


#: ../../source/Concepts/About-Domain-ID.rst:76
msgid "If it is known that the computer will only ever be on a single domain ID at a time, and the domain ID is low enough, it is safe to create more ROS 2 processes than this."
msgstr "如果已知计算机一次只会处于一个域ID上，并且域ID足够低，则可以安全地创建超过此数量的ROS 2进程。"


#: ../../source/Concepts/About-Domain-ID.rst:78
msgid "When choosing a domain ID that is near the top of the range of platform-specific domain IDs, one additional constraint should be considered."
msgstr "当选择接近平台特定域ID范围顶部的域ID时，应考虑一个额外的约束条件。"


#: ../../source/Concepts/About-Domain-ID.rst:80
msgid "For instance, assume a Linux computer with a domain ID of 101:"
msgstr "例如，假设具有域ID为101的Linux计算机："


#: ../../source/Concepts/About-Domain-ID.rst:82
msgid "The zero'th ROS 2 process on the computer will connect to ports 32650, 32651, 32660, and 32661."
msgstr "计算机上的第零个ROS 2进程将连接到端口32650、32651、32660和32661。"


#: ../../source/Concepts/About-Domain-ID.rst:83
msgid "The first ROS 2 process on the computer will connect to ports 32650, 32651, 32662, and 32663."
msgstr "计算机上的第一个ROS 2进程将连接到端口32650、32651、32662和32663。"


#: ../../source/Concepts/About-Domain-ID.rst:84
msgid "The 53rd ROS 2 process on the computer will connect to ports 32650, 32651, 32766, and 32767."
msgstr "计算机上的第53个ROS 2进程将连接到端口32650、32651、32766和32767。"


#: ../../source/Concepts/About-Domain-ID.rst:85
msgid "The 54th ROS 2 process on the computer will connect to ports 32650, 32651, 32768, and 32769, running into the ephemeral port range."
msgstr "计算机上的第54个ROS 2进程将连接到端口32650、32651、32768和32769，并进入临时端口范围。"


#: ../../source/Concepts/About-Domain-ID.rst:87
msgid "Thus the maximum number of processes that should be created when using domain ID 101 on Linux is 54. Similarly, the maximum number of processes that should be created when using domain ID 232 on Linux is 63, as the maximum port number is 65535."
msgstr "因此，在Linux上使用域ID 101时，应创建的最大进程数为54。同样，在Linux上使用域ID 232时，应创建的最大进程数为63，因为最大端口号为65535。"


#: ../../source/Concepts/About-Domain-ID.rst:90
msgid "The situation is similar on macOS and Windows, though the numbers are different. On macOS and Windows, when choosing a domain ID of 166 (the top of the range), the maximum number of ROS 2 processes that can be created on a computer before running into the ephemeral port range is 120."
msgstr "在macOS和Windows上的情况类似，但数字不同。在macOS和Windows上，选择域ID为166（范围顶部）时，计算机上在进入临时端口范围之前可以创建的最大ROS 2进程数为120。"


#: ../../source/Concepts/About-Domain-ID.rst:94
msgid "Domain ID to UDP Port Calculator"
msgstr "域 ID 到 UDP 端口计算器"


#: ../../source/Concepts/About-Executors.rst:4
msgid "Executors"
msgstr "执行器"


#: ../../source/Concepts/About-Executors.rst:12
msgid "Execution management in ROS 2 is explicated by the concept of Executors. An Executor uses one or more threads of the underlying operating system to invoke the callbacks of subscriptions, timers, service servers, action servers, etc. on incoming messages and events. The explicit Executor class (in `executor.hpp <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/executor.hpp>`_ in rclcpp, in `executors.py <https://github.com/ros2/rclpy/blob/humble/rclpy/rclpy/executors.py>`_ in rclpy, or in `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in rclc) provides more control over execution management than the spin mechanism in ROS 1, although the basic API is very similar."
msgstr "ROS 2 中的执行管理是通过执行器（Executors）的概念来解释的。执行器使用底层操作系统的一个或多个线程来调用订阅、定时器、服务服务器、动作服务器等的回调函数，以处理传入的消息和事件。显式的执行器类（在 rclcpp 的 `executor.hpp <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/executor.hpp>`_，在 rclpy 的 `executors.py <https://github.com/ros2/rclpy/blob/humble/rclpy/rclpy/executors.py>`_，或者在 rclc 的 `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ 中）比 ROS 1 中的 spin 机制提供了更多的执行管理控制，尽管基本的 API 非常相似。"


#: ../../source/Concepts/About-Executors.rst:16
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr "接下来，我们将重点介绍 C++ 客户端库 *rclcpp*。"


#: ../../source/Concepts/About-Executors.rst:19
msgid "Basic use"
msgstr "基本用法"


#: ../../source/Concepts/About-Executors.rst:21
msgid "In the simplest case, the main thread is used for processing the incoming messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:"
msgstr "在最简单的情况下，可以通过调用 ``rclcpp::spin(..)`` 来使用主线程处理节点的传入消息和事件，示例如下："


#: ../../source/Concepts/About-Executors.rst:42
msgid "The call to ``spin(node)`` basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor:"
msgstr "对 ``spin(node)`` 的调用基本上扩展为单线程执行器的实例化和调用，这是最简单的执行器："


#: ../../source/Concepts/About-Executors.rst:50
msgid "By invoking ``spin()`` of the Executor instance, the current thread starts querying the rcl and middleware layers for incoming messages and other events and calls the corresponding callback functions until the node shuts down. In order not to counteract the QoS settings of the middleware, an incoming message is not stored in a queue on the Client Library layer but kept in the middleware until it is taken for processing by a callback function. (This is a crucial difference to ROS 1.) A *wait set* is used to inform the Executor about available messages on the middleware layer, with one binary flag per queue. The *wait set* is also used to detect when timers expire."
msgstr "通过调用执行器实例的 ``spin()``，当前线程开始查询 rcl 和中间件层的传入消息和其他事件，并调用相应的回调函数，直到节点关闭。为了不影响中间件的 QoS 设置，在客户端库层不会将传入消息存储在队列中，而是在中间件中保持，直到由回调函数进行处理。（这是与 ROS 1 的一个重要区别。）一个 *等待集* 用于通知执行器中间件层上可用的消息，每个队列对应一个二进制标志。*等待集* 还用于检测计时器到期的情况。"


#: ../../source/Concepts/About-Executors.rst:58
msgid "The Single-Threaded Executor is also used by the container process for :doc:`components <./About-Composition>`, i.e. in all cases where nodes are created and executed without an explicit main function."
msgstr "单线程执行器还被容器进程用于 :doc:`组件 <./About-Composition>`，即在所有没有显式主函数的情况下创建和执行节点的情况下。"


#: ../../source/Concepts/About-Executors.rst:61
msgid "Types of Executors"
msgstr "执行器的类型"


#: ../../source/Concepts/About-Executors.rst:63
msgid "Currently, rclcpp provides three Executor types, derived from a shared parent class:"
msgstr "目前，rclcpp 提供了三种执行器类型，它们派生自一个共享的父类："


#: ../../source/Concepts/About-Executors.rst:79
msgid "The *Multi-Threaded Executor* creates a configurable number of threads to allow for processing multiple messages or events in parallel. The *Static Single-Threaded Executor* optimizes the runtime costs for scanning the structure of a node in terms of subscriptions, timers, service servers, action servers, etc. It performs this scan only once when the node is added, while the other two executors regularly scan for such changes. Therefore, the Static Single-Threaded Executor should be used only with nodes that create all subscriptions, timers, etc. during initialization."
msgstr " *多线程执行器* 创建可配置数量的线程，以允许并行处理多个消息或事件。*静态单线程执行器* 优化节点结构的运行时成本，包括订阅、计时器、服务服务器、动作服务器等。它仅在节点添加时进行一次扫描，而另外两个执行器定期扫描这些变化。因此，静态单线程执行器只应与在初始化期间创建所有订阅、计时器等的节点一起使用。"


#: ../../source/Concepts/About-Executors.rst:84
msgid "All three executors can be used with multiple nodes by calling ``add_node(..)`` for each node."
msgstr "通过为每个节点调用``add_node（..）``，可以使用所有三个执行者与多个节点一起使用。"


#: ../../source/Concepts/About-Executors.rst:98
msgid "In the above example, the one thread of a Static Single-Threaded Executor is used to serve three nodes together. In case of a Multi-Threaded Executor, the actual parallelism depends on the callback groups."
msgstr "在上面的示例中，使用一个静态单线程执行者的一个线程来同时服务三个节点。在多线程执行者的情况下，实际并行性取决于回调组。"


#: ../../source/Concepts/About-Executors.rst:102
msgid "Callback groups"
msgstr "回调组"


#: ../../source/Concepts/About-Executors.rst:104
msgid "ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a *callback group* can be created by the ``create_callback_group`` function of the Node class. In rclpy, the same is done by calling the constructor of the specific callback group type. The callback group must be stored throughout execution of the node (eg. as a class member), or otherwise the executor won't be able to trigger the callbacks. Then, this callback group can be specified when creating a subscription, timer, etc. - for example by the subscription options:"
msgstr "ROS 2允许将节点的回调组织成组。在rclcpp中，可以通过Node类的``create_callback_group``函数创建这样一个*回调组*。在rclpy中，可以通过调用特定回调组类型的构造函数来完成相同的操作。回调组必须在节点的执行过程中保留（例如，作为类成员），否则执行者将无法触发回调。然后，在创建订阅、定时器等时可以指定此回调组-例如，通过订阅选项："


#: ../../source/Concepts/About-Executors.rst:112 ../../source/Concepts/About-Logging.rst:49 ../../source/Concepts/About-Logging.rst:185
msgid "C++"
msgstr "C++"


#: ../../source/Concepts/About-Executors.rst:123 ../../source/Concepts/About-Logging.rst:72 ../../source/Concepts/About-Logging.rst:191
msgid "Python"
msgstr "Python"


#: ../../source/Concepts/About-Executors.rst:131
msgid "All subscriptions, timers, etc. that are created without the indication of a callback group are assigned to the *default callback group*. The default callback group can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by ``Node.default_callback_group`` in rclpy."
msgstr "所有没有指定回调组的订阅、定时器等都被分配到*默认回调组*。可以通过``NodeBaseInterface::get_default_callback_group()``（在rclcpp中）和``Node.default_callback_group``（在rclpy中）查询默认回调组。"


#: ../../source/Concepts/About-Executors.rst:135
msgid "There are two types of callback groups, where the type has to be specified at instantiation time:"
msgstr "有两种类型的回调组，类型必须在实例化时指定："


#: ../../source/Concepts/About-Executors.rst:137
msgid "*Mutually exclusive:* Callbacks of this group must not be executed in parallel."
msgstr "*互斥（Mutually exclusive）：*该组的回调不能并行执行。"


#: ../../source/Concepts/About-Executors.rst:138
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr "*可重入（Reentrant）：*该组的回调可以并行执行。"


#: ../../source/Concepts/About-Executors.rst:140
msgid "Callbacks of different callback groups may always be executed in parallel. The Multi-Threaded Executor uses its threads as a pool to process as many callbacks as possible in parallel according to these conditions. For tips on how to use callback groups efficiently, see :doc:`Using Callback Groups <../How-To-Guides/Using-callback-groups>`."
msgstr "不同回调组的回调可以并行执行。多线程执行器（Multi-Threaded Executor）使用线程池根据这些条件并行处理尽可能多的回调。有关如何高效使用回调组的提示，请参阅:doc:`使用回调组 <../How-To-Guides/Using-callback-groups>`。"


#: ../../source/Concepts/About-Executors.rst:144
msgid "The Executor base class in rclcpp also has the function ``add_callback_group(..)``, which allows distributing callback groups to different Executors. By configuring the underlying threads using the operating system scheduler, specific callbacks can be prioritized over other callbacks. For example, the subscriptions and timers of a control loop can be prioritized over all other subscriptions and standard services of a node. The `examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/humble/rclcpp/executors/cbg_executor>`_ provides a demo of this mechanism."
msgstr "在rclcpp中，Executor基类还具有函数``add_callback_group(..)``，可以将回调组分配给不同的执行器。通过使用操作系统调度器配置底层线程，可以使特定的回调优先于其他回调。例如，可以将控制循环的订阅和定时器优先于节点的所有其他订阅和标准服务。`examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/humble/rclcpp/executors/cbg_executor>`_ 提供了该机制的演示。"


#: ../../source/Concepts/About-Executors.rst:150
msgid "Scheduling semantics"
msgstr "调度语义"


#: ../../source/Concepts/About-Executors.rst:152
msgid "If the processing time of the callbacks is shorter than the period with which messages and events occur, the Executor basically processes them in FIFO order. However, if the processing time of some callbacks is longer, messages and events will be queued on the lower layers of the stack. The wait set mechanism reports only very little information about these queues to the Executor. In detail, it only reports whether there are any messages for a certain topic or not. The Executor uses this information to process the messages (including services and actions) in a round-robin fashion - but not in FIFO order. The following flow diagram visualizes this scheduling semantics."
msgstr "如果回调函数的处理时间短于消息和事件发生的周期，执行器基本上按照先进先出（FIFO）的顺序处理它们。然而，如果某些回调函数的处理时间较长，消息和事件将在堆栈的较低层次上排队。等待集机制对这些队列向执行器仅报告了非常少的信息。具体而言，它只报告某个主题是否有任何消息。执行器使用这些信息以循环轮询的方式处理消息（包括服务和动作），而不是按照先进先出的顺序。下面的流程图可视化了这种调度语义。"


#: ../../source/Concepts/About-Executors.rst:161
msgid "This semantics was first described in a `paper by Casini et al. at ECRTS 2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are prioritized over all other messages. `This prioritization was removed in Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr "这种语义首次在2019年的ECRTS会议上由Casini等人在一篇论文中描述。[链接](https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf)（注意：该论文还解释了计时器事件优先于所有其他消息的优先级，这个优先级在Eloquent中被移除了。[链接](https://github.com/ros2/rclcpp/pull/841)）"


#: ../../source/Concepts/About-Executors.rst:166
msgid "Outlook"
msgstr "展望"


#: ../../source/Concepts/About-Executors.rst:168
msgid "While the three Executors of rclcpp work well for most applications, there are some issues that make them not suitable for real-time applications, which require well-defined execution times, determinism, and custom control over the execution order. Here is a summary of some of these issues:"
msgstr "虽然rclcpp的三个执行器在大多数应用中运行良好，但存在一些问题，使它们不适用于实时应用程序，实时应用程序需要定义明确的执行时间、确定性和对执行顺序的自定义控制。以下是其中一些问题的摘要："


#: ../../source/Concepts/About-Executors.rst:171
msgid "Complex and mixed scheduling semantics. Ideally you want well defined scheduling semantics to perform a formal timing analysis."
msgstr "复杂和混合的调度语义。理想情况下，您希望有明确定义的调度语义以进行形式化的定时分析。"


#: ../../source/Concepts/About-Executors.rst:173
msgid "Callbacks may suffer from priority inversion. Higher priority callbacks may be blocked by lower priority callbacks."
msgstr "回调函数可能会受到优先级反转的影响。较高优先级的回调函数可能会被较低优先级的回调函数阻塞。"


#: ../../source/Concepts/About-Executors.rst:175
msgid "No explicit control over the callbacks execution order."
msgstr "无法明确控制回调函数的执行顺序。"


#: ../../source/Concepts/About-Executors.rst:176
msgid "No built-in control over triggering for specific topics."
msgstr "没有内置的机制来触发特定主题的回调函数。"


#: ../../source/Concepts/About-Executors.rst:178
msgid "Additionally, the executor overhead in terms of CPU and memory usage is considerable. The Static Single-Threaded Executor reduces this overhead greatly but it might not be enough for some applications."
msgstr "此外，执行器在CPU和内存使用方面的开销相当大。静态单线程执行器大大减少了这种开销，但对于某些应用程序可能还不够。"


#: ../../source/Concepts/About-Executors.rst:181
msgid "These issues have been partially addressed by the following developments:"
msgstr "这些问题已经部分得到以下改进的解决："


#: ../../source/Concepts/About-Executors.rst:183
msgid "`rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/wait_set.hpp>`_: The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, timers, service servers, action servers, etc. instead of using an Executor. It can be used to implement deterministic, user-defined processing sequences, possibly processing multiple messages from different subscriptions together. The `examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/humble/rclcpp/wait_set>`_ provides several examples for the use of this user-level wait set mechanism."
msgstr "`rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/wait_set.hpp>`_：rclcpp的``WaitSet``类允许直接等待订阅、定时器、服务服务器、动作服务器等，而无需使用执行器。它可以用于实现确定性的、用户定义的处理序列，可能同时处理来自不同订阅的多个消息。`examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/humble/rclcpp/wait_set>`_ 提供了使用此用户级等待集机制的多个示例。"


#: ../../source/Concepts/About-Executors.rst:186
msgid "`rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: This Executor from the C Client Library *rclc*, developed for micro-ROS, gives the user fine-grained control over the execution order of callbacks and allows for custom trigger conditions to activate callbacks. Furthermore, it implements ideas of the Logical Execution Time (LET) semantics."
msgstr "`rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_：这个来自C客户端库*rclc*的Executor是为micro-ROS开发的，它可以让用户对回调的执行顺序进行细粒度控制，并允许自定义触发条件来激活回调。此外，它实现了逻辑执行时间（LET）语义的概念。""


#: ../../source/Concepts/About-Executors.rst:190
msgid "Further information"
msgstr "更多信息""


#: ../../source/Concepts/About-Executors.rst:192
msgid "Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at ROS World 2021. Virtual event. 19 October 2021."
msgstr "Michael Pöhnl等人：`\"ROS 2 Executor: How to make it efficient, real-time and deterministic?\" <https://www.apex.ai/roscon-21>`_. ROS World 2021的研讨会。虚拟活动。2021年10月19日。""


#: ../../source/Concepts/About-Executors.rst:193
msgid "Ralph Lange: `\"Advanced Execution Management with ROS 2\" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference. Virtual event. 16 December 2020."
msgstr "Ralph Lange：`\"Advanced Execution Management with ROS 2\" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference。虚拟活动。2020年12月16日。""


#: ../../source/Concepts/About-Executors.rst:194
msgid "Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: `“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July 2019."
msgstr "Daniel Casini，Tobias Blass，Ingo Lütkebohle和Björn Brandenburg：`“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_，第31届ECRTS 2019会议论文集，德国斯图加特，2019年7月。""


#: ../../source/Concepts/About-Internal-Interfaces.rst:2
msgid "About internal ROS 2 interfaces"
msgstr "关于内部ROS 2接口""


#: ../../source/Concepts/About-Internal-Interfaces.rst:6
msgid "The internal ROS interfaces are public C |APIs| that are intended for use by developers who are creating |client libraries| or adding a new underlying middleware, but are not intended for use by typical ROS users. The ROS |client libraries| provide the user facing |APIs| that most ROS users are familiar with, and may come in a variety of programming languages."
msgstr "ROS内部接口是面向开发人员的公共C |APIs|，用于创建|客户端库|或添加新的底层中间件，但不适用于普通ROS用户。ROS |客户端库|提供了大多数ROS用户熟悉的面向用户的|APIs|，可以使用多种编程语言实现。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:10
msgid "Internal API Architecture Overview"
msgstr "内部API架构概述"


#: ../../source/Concepts/About-Internal-Interfaces.rst:12
msgid "There are two main internal interfaces:"
msgstr "有两个主要的内部接口："


#: ../../source/Concepts/About-Internal-Interfaces.rst:14
msgid "the ROS middleware interface (``rmw`` |API|)"
msgstr "ROS中间件接口（``rmw`` |API|）"


#: ../../source/Concepts/About-Internal-Interfaces.rst:15
msgid "the ROS client library interface (``rcl`` |API|)"
msgstr "ROS客户端库接口（``rcl`` |API|）"


#: ../../source/Concepts/About-Internal-Interfaces.rst:17
msgid "The ``rmw`` |API| is the interface between the ROS 2 software stack and the underlying middleware implementation. The underlying middleware used for ROS 2 is either a DDS or RTPS implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types."
msgstr "``rmw`` |API| 是ROS 2软件栈与底层中间件实现之间的接口。ROS 2使用的底层中间件可以是DDS或RTPS实现，负责发现、发布和订阅机制、服务的请求-响应机制以及消息类型的序列化。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:20
msgid "The ``rcl`` |API| is a slightly higher level |API| which is used to implement the |client libraries| and does not touch the middleware implementation directly, but rather does so through the ROS middleware interface (``rmw`` |API|) abstraction."
msgstr "``rcl`` |API| 是一个稍微高层的 |API|，用于实现 |客户端库|，不直接涉及中间件实现，而是通过 ROS 中间件接口（``rmw`` |API|）进行操作。"


msgid "ros2 software stack"
msgstr "ROS2 软件堆栈"


#: ../../source/Concepts/About-Internal-Interfaces.rst:25
msgid "As the diagram shows, these |APIs| are stacked such that the typical ROS user will use the |client library| |API|, e.g. ``rclcpp``, to implement their code (executable or library). The implementation of the |client libraries|, e.g. ``rclcpp``, use the ``rcl`` interface which provides access to the ROS graph and graph events. The ``rcl`` implementation in turn uses the ``rmw`` |API| to access the ROS graph. The purpose of the ``rcl`` implementation is to provide a common implementation for more complex ROS concepts and utilities that may be used by various |client libraries|, while remaining agnostic to the underlying middleware being used. The purpose of the ``rmw`` interface is to capture the absolute minimum middleware functionality needed to support ROS's client libraries. Finally, the implementation of the ``rmw`` |API| is provided by a middleware implementation specific |package|, e.g. ``rmw_fastrtps_cpp``, the library of which is compiled against vendor specific DDS interfaces and types."
msgstr "如图所示，这些 |API| 被堆叠在一起，以便典型的 ROS 用户可以使用 |客户端库| 的 |API|（例如 ``rclcpp``）来实现他们的代码（可执行文件或库）。 |客户端库| 的实现（例如 ``rclcpp``）使用提供对 ROS 图和图事件的访问的 ``rcl`` 接口。而 ``rcl`` 的实现则使用 ``rmw`` |API| 来访问 ROS 图。``rcl`` 实现的目的是为各种 |客户端库| 提供用于更复杂 ROS 概念和实用程序的通用实现，同时对所使用的底层中间件保持不可知。``rmw`` 接口的目的是捕获支持 ROS 客户端库所需的绝对最低限度的中间件功能。最后，``rmw`` |API| 的实现由特定中间件实现的 |软件包| 提供，例如 ``rmw_fastrtps_cpp``，其库编译针对特定供应商的 DDS 接口和类型。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:32
msgid "In the diagram above there is also a box labeled ``ros_to_dds``, and the purpose of this box is to represent a category of possible packages which allow the user to access DDS vendor specific objects and settings using the ROS equivalents. One of the goals of this abstraction interface is to completely insulate the ROS user space code from the middleware being used, so that changing DDS vendors or even middleware technology has a minimal impact on the users code. However, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have. By requiring the use of one of these packages in order to access the underlying DDS vendor's objects, we can avoid exposing vendor specific symbols and headers in the normal interface. It also makes it easy to see what code is potentially violating the vendor portability by inspecting the package's dependencies to see if one of these ``ros_to_dds`` packages are being used."
msgstr "在上图中，还有一个标有 ``ros_to_dds`` 的方框，该方框的目的是代表一类可能的软件包，允许用户使用 ROS 等效方式访问 DDS 供应商特定的对象和设置。这个抽象接口的目标之一是完全隔离 ROS 用户空间代码与所使用的中间件之间的关系，以便在更改 DDS 供应商甚至中间件技术时对用户代码的影响最小化。但我们也认识到，有时候尽管可能带来后果，从实现中手动调整设置也是有用的。通过要求使用这些软件包来访问底层 DDS 供应商的对象，我们可以避免在正常接口中暴露供应商特定的符号和头文件。通过检查软件包的依赖关系，可以轻松查看哪些代码可能违反了供应商的可移植性，以确定是否使用了这些 ``ros_to_dds`` 软件包。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:41
msgid "Type Specific Interfaces"
msgstr "特定类型的接口"


#: ../../source/Concepts/About-Internal-Interfaces.rst:43
msgid "All along the way there are some parts of the |APIs| that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type. The following diagram layouts the path from user defined ``rosidl`` files, e.g. ``.msg`` files, to the type specific code used by the user and system to perform type specific functions:"
msgstr "在整个过程中，有些 |API| 部分必然与交换的消息类型有关，例如发布消息或订阅主题，因此需要为每个消息类型生成代码。以下图表展示了从用户定义的 ``rosidl`` 文件（例"


#: ../../source/Concepts/About-Internal-Interfaces.rst:49
msgid "ros2 idl static type support stack"
msgstr "ROS2 IDL 静态类型支持堆栈"


#: ../../source/Concepts/About-Internal-Interfaces.rst:49
msgid "Figure: flow chart of \"static\" type support generation, from ``rosidl`` files to user facing code."
msgstr "图: 从``rosidl``文件到用户界面代码的“静态”类型支持生成流程图。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:51
msgid "The right hand side of the diagram shows how the ``.msg`` files are passed directly to language specific code generators, e.g. ``rosidl_generator_cpp`` or ``rosidl_generator_py``. These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the ``.msg`` files. For example, consider the message ``std_msgs/String``, a user might use this file in C++ with the statement ``#include <std_msgs/msg/string.hpp>``, or they might use the statement ``from std_msgs.msg import String`` in Python. These statements work because of the files generated by these language specific (but middleware agnostic) generator packages."
msgstr "图的右侧显示了如何直接将``.msg``文件传递给特定语言的代码生成器，例如``rosidl_generator_cpp``或``rosidl_generator_py``。这些生成器负责创建用户将包含（或导入）并用作内存中表示``.msg``文件中定义的消息的代码。例如，考虑消息``std_msgs/String``，用户可以在C++中使用语句``#include <std_msgs/msg/string.hpp>``，或者在Python中使用语句``from std_msgs.msg import String``。这些语句之所以有效，是因为这些特定语言（但与中间件无关）的生成器包生成的文件。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:56
msgid "Separately, the ``.msg`` files are used to generate type support code for each type. In this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. The type support for a given message might include things like a list of the names and types for each field in the message. It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message."
msgstr "另外，``.msg``文件用于为每种类型生成类型支持代码。在此上下文中，类型支持指的是与给定类型特定且由系统用于执行特定任务的元数据或函数。给定消息的类型支持可能包括诸如消息中每个字段的名称和类型列表等内容。它还可以包含对能够执行该类型特定任务的代码的引用，例如发布消息。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:62
msgid "Static Type Support"
msgstr "静态类型支持"


#: ../../source/Concepts/About-Internal-Interfaces.rst:64
msgid "When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. For example, consider the type specific publish function, when using \"vendor A\" the function will need to call some of \"vendor A\"'s |API|, but when using \"vendor B\" it will need to call \"vendor B\"'s |API|. To allow for middleware vendor specific code, the user defined ``.msg`` files may result in the generation of vendor specific code. This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the \"Private Implementation\" (or Pimpl) pattern works."
msgstr "当类型支持引用代码为特定消息类型执行特定功能时，该代码有时需要执行特定于中间件的工作。例如，考虑特定类型的发布函数，在使用“供应商A”时，该函数需要调用“供应商A”的一些API，但在使用“供应商B”时，它需要调用“供应商B”的API。为了允许特定于中间件供应商的代码，用户定义的``.msg``文件可能会生成特定于供应商的代码。通过类型支持抽象，该特定于供应商的代码仍对用户隐藏，类似于“私有实现”（或Pimpl）模式的工作方式。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:70
msgid "Static Type Support with DDS"
msgstr "DDS支持的静态类型"


#: ../../source/Concepts/About-Internal-Interfaces.rst:72
msgid "For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (``.idl`` files), the user defined ``rosidl`` files (``.msg`` files) are converted into equivalent OMG IDL files (``.idl`` files). From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. The above diagram shows this on the left hand side, where the ``.msg`` files are consumed by the ``rosidl_dds`` package to produce ``.idl`` files, and then those ``.idl`` files are given to language specific and DDS vendor specific type support generation packages."
msgstr "对于基于DDS的中间件供应商，特别是基于OMG IDL文件（``.idl``文件）生成代码的供应商，用户定义的``rosidl``文件（``.msg``文件）会被转换为等效的OMG IDL文件（``.idl``文件）。从这些OMG IDL文件中，创建供应商特定的代码，然后在特定类型的函数中使用这些代码，这些函数由给定类型的类型支持引用。上面的图表显示了左侧的情况，``.msg``文件被``rosidl_dds``软件包使用以生成``.idl``文件，然后将这些``.idl``文件提供给特定语言和DDS供应商的类型支持生成软件包。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:76
msgid "For example, consider the Fast DDS implementation, which has a package called ``rosidl_typesupport_fastrtps_cpp``. This package is responsible for generating code to handle things like converting a C++ message object into a serialized octet buffer to be written over the network. This code, while specific to Fast DDS, is still not exposed to the user because of the abstraction in the type support code."
msgstr "例如，考虑Fast DDS实现，它有一个名为``rosidl_typesupport_fastrtps_cpp``的软件包。该软件包负责生成处理诸如将C++消息对象转换为序列化的八位字节缓冲区以便通过网络写入等任务的代码。尽管这些代码是针对Fast DDS特定的，但由于类型支持代码中的抽象，用户仍然无需直接接触到这些代码。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:81
msgid "Dynamic Type Support"
msgstr "动态类型支持"


#: ../../source/Concepts/About-Internal-Interfaces.rst:83
msgid "Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type. Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type. This is referred to as \"dynamic\" type support, as opposed to \"static\" type support which requires generated versions of a function for each type."
msgstr "实现类型支持的另一种方法是为诸如发布到主题之类的通用功能编写通用函数，而不是为每种消息类型生成函数的版本。为了实现这一点，这个通用函数需要一些关于正在发布的消息类型的元信息，例如消息类型中字段名称和类型的列表，以它们在消息类型中出现的顺序。然后，为了发布一条消息，您调用一个通用的发布函数，并传递要发布的消息以及包含有关消息类型的必要元数据的结构体。这被称为\"动态\"类型支持，与为每种类型生成函数的\"静态\"类型支持相对应。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:91
msgid "ros2 idl dynamic type support stack"
msgstr "ros2 idl动态类型支持栈"


#: ../../source/Concepts/About-Internal-Interfaces.rst:91
msgid "Figure: flow chart of \"dynamic\" type support generation, from ``rosidl`` files to user facing code."
msgstr "图：\"动态\"类型支持生成的流程图，从``rosidl``文件到用户界面代码。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:93
msgid "The above diagram shows the flow from user defined ``rosidl`` files to generated user facing code. It is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram. In dynamic type support the ``.msg`` files are converted directly into user facing code."
msgstr "上图显示了从用户定义的``rosidl``文件到生成的用户界面代码的流程。它与静态类型支持的流程图非常相似，只在类型支持生成的方式上有所不同，这在图的左侧表示。在动态类型支持中，``.msg``文件直接转换为用户界面代码。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:97
msgid "This code is also middleware agnostic, because it only contains meta information about the messages. The function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific |APIs|. Note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. ``rosidl_typesupport_introspection_c`` and ``rosidl_typesupport_introspection_cpp``. The ``introspection`` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. This is the fundamental capability that allows for generic implementations of functions like \"publish to a topic\"."
msgstr "这段代码也是中间件无关的，因为它只包含有关消息的元信息。实际执行工作的函数（例如发布到话题）对消息类型是通用的，并将根据需要调用特定中间件的API。请注意，与静态类型支持不同，不是由DDS供应商特定的软件包提供类型支持代码，而是每种语言都有一个中间件无关的软件包，例如``rosidl_typesupport_introspection_c``和``rosidl_typesupport_introspection_cpp``。软件包名称中的``introspection``部分指的是使用生成的元数据对任何消息实例进行内省的能力。这是允许实现诸如“发布到话题”等通用函数的基本能力。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:103
msgid "This approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support. It also results in less generated code, which reduces compile time and code size."
msgstr "这种方法的优点是所有生成的代码都是中间件无关的，这意味着可以在不同的中间件实现中重用它们，只要它们支持动态类型支持。它还会生成较少的代码，从而减少编译时间和代码大小。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:106
msgid "However, dynamic type support requires that the underlying middleware support a similar form of dynamic type support. In the case of DDS the DDS-XTypes standard allows for publishing of messages using meta information rather than generated code. DDS-XTypes, or something like it, is required in the underlying middleware in order to support dynamic type support. Also, this approach to type support is normally slower than the static type support alternative. The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type's meta data to perform things like serialization."
msgstr "然而，动态类型支持要求底层中间件支持类似的动态类型支持形式。对于DDS，DDS-XTypes标准允许使用元信息而不是生成的代码发布消息。在底层中间件中需要DDS-XTypes或类似的东西来支持动态类型支持。此外，与静态类型支持相比，这种类型支持方法通常较慢。静态类型支持中的类型特定生成代码可以编写得更高效，因为它不需要迭代消息类型的元数据来执行诸如序列化之类的操作。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:113
msgid "The ``rcl`` Repository"
msgstr "``rcl``代码库"


#: ../../source/Concepts/About-Internal-Interfaces.rst:115
msgid "The ROS Client Library interface (``rcl`` |API|) can be used by |client libraries| (e.g. ``rclc``, ``rclcpp``, ``rclpy``, etc.) in order to avoid duplicating logic and features. By reusing the ``rcl`` |API|, client libraries can be smaller and more consistent with each other. Some parts of the client library are intentionally left out of the ``rcl`` |API| because the language idiomatic method should be used to implement those parts of the system. A good example of this is the execution model, which ``rcl`` does not address at all. Instead the client library should provide a language idiomatic solution like ``pthreads`` in C, ``std::thread`` in C++11, and ``threading.Thread`` in Python. Generally the ``rcl`` interface provides functions that are not specific to a language pattern and are not specific to a particular message type."
msgstr "ROS客户端库接口（``rcl`` |API|）可被|客户端库|（例如``rclc``、``rclcpp``、``rclpy``等）使用，以避免重复逻辑和功能。通过重用``rcl`` |API|，客户端库可以更小且更一致。客户端库的某些部分故意未包含在``rcl`` |API|中，因为应使用语言惯用方法来实现系统的这些部分。一个很好的例子是执行模型，``rcl``根本不涉及。相反，客户端库应该提供一种语言惯用的解决方案，比如C中的``pthreads``，C++11中的``std::thread``和Python中的``threading.Thread``。一般来说，``rcl``接口提供的函数不特定于语言模式，也不特定于特定的消息类型。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:122
msgid "The ``rcl`` |API| is located in the `ros2/rcl <https://github.com/ros2/rcl>`_ repository on |GitHub|_ and contains the interface as C headers. The ``rcl`` C implementation is provided by the ``rcl`` |package| in the same repository. This implementation avoids direct contact with the middleware by instead using the ``rmw`` and ``rosidl`` |APIs|."
msgstr "``rcl`` |API|位于|GitHub|_上的`ros2/rcl <https://github.com/ros2/rcl>`_仓库中，包含C头文件作为接口。``rcl`` C实现由同一仓库中的``rcl`` |package|提供。该实现通过使用``rmw``和``rosidl`` |APIs|来避免与中间件的直接接触。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:126
msgid "For a complete definition of the ``rcl`` |API|, see `the rcl docs <http://docs.ros.org/en/humble/p/rcl/>`_."
msgstr "有关完整的``rcl`` |API|定义，请参阅`rcl文档 <http://docs.ros.org/en/humble/p/rcl/>`_。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:129
msgid "The ``rmw`` Repository"
msgstr "``rmw``仓库"


#: ../../source/Concepts/About-Internal-Interfaces.rst:131
msgid "The ROS middleware interface (``rmw`` |API|) is the minimal set of primitive middleware capabilities needed to build ROS on top. Providers of different middleware implementations must implement this interface in order to support the entire ROS stack on top. Currently all of the middleware implementations are for different DDS vendors."
msgstr "ROS中间件接口（``rmw`` |API|）是构建ROS所需的最小原始中间件功能集。不同中间件实现的提供者必须实现此接口，以支持整个ROS堆栈。目前，所有中间件实现均为不同的DDS供应商提供。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:135
msgid "The ``rmw`` |API| is located in the `ros2/rmw <https://github.com/ros2/rmw>`_ repository. The ``rmw`` |package| contains the C headers which define the interface, the implementation of which is provided by the various |packages| of rmw implementations for different DDS vendors."
msgstr "``rmw`` |API|位于|GitHub|_上的`ros2/rmw <https://github.com/ros2/rmw>`_仓库中。``rmw`` |package|包含定义接口的C头文件，其实现由不同DDS供应商的rmw实现的各个|packages|提供。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:138
msgid "For a definition of the ``rmw`` |API|, see `the rmw docs <http://docs.ros.org/en/humble/p/rmw/>`_."
msgstr "有关``rmw`` |API|的定义，请参阅`rmw文档 <http://docs.ros.org/en/humble/p/rmw/>`_。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:142
msgid "The ``rosidl`` Repository"
msgstr "``rosidl``存储库"


#: ../../source/Concepts/About-Internal-Interfaces.rst:144
msgid "The ``rosidl`` |API| consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages. The generated message code specified in the |API| will be language specific, but may or may not reuse generated code for other languages. The generated message code specified in the |API| contains things like the message data structure, functions for construction, destruction, etc. The |API| will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type."
msgstr "``rosidl`` |API|由一些与消息相关的静态函数和类型组成，以及对不同语言的消息生成的代码应该是什么的定义。|API|中指定的生成的消息代码将是特定于语言的，但可能会或可能不会重用其他语言的生成代码。|API|中指定的生成的消息代码包含诸如消息数据结构、构造、销毁等函数。|API|还将实现一种获取消息类型的类型支持结构的方式，在发布或订阅该消息类型的主题时使用。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:149
msgid "There are several repositories that play a role in the ``rosidl`` |API| and implementation."
msgstr "有几个存储库在``rosidl`` |API|和实现中发挥作用。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:151
msgid "The ``rosidl`` repository, located on |GitHub|_ at `ros2/rosidl <https://github.com/ros2/rosidl>`_, defines the message IDL syntax, i.e. syntax of ``.msg`` files, ``.srv`` files, etc., and contains |packages| for parsing the files, for providing CMake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators. The repository contains these |packages|:"
msgstr "``rosidl``存储库位于|GitHub|_上的`ros2/rosidl <https://github.com/ros2/rosidl>`_，定义了消息IDL语法，即``.msg``文件、``.srv``文件等的语法，并包含用于解析文件、提供CMake基础架构以从消息生成代码、生成与实现无关的代码（头文件和源文件）以及建立默认生成器集合的|packages|。该存储库包含以下|packages|："


#: ../../source/Concepts/About-Internal-Interfaces.rst:154
msgid "``rosidl_cmake``: provides CMake functions and modules for generating code from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr "``rosidl_cmake``：提供了用于从``rosidl``文件（例如``.msg``文件、``.srv``文件等）生成代码的CMake函数和模块。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:155
msgid "``rosidl_default_generators``: defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used."
msgstr "``rosidl_default_generators``：定义了默认生成器的列表，以确保它们作为依赖项安装，但也可以使用其他注入的生成器。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:156
msgid "``rosidl_generator_c``: provides tools to generate C header files (``.h``) for ``rosidl`` files."
msgstr "``rosidl_generator_c``：提供用于为``rosidl``文件生成C头文件（``.h``）的工具。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:157
msgid "``rosidl_generator_cpp``: provides tools to generate C++ header files (``.hpp``) for ``rosidl`` files."
msgstr "``rosidl_generator_cpp``：提供用于为``rosidl``文件生成C++头文件（``.hpp``）的工具。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:158
msgid "``rosidl_generator_py``: provides tools to generate Python modules for ``rosidl`` files."
msgstr "``rosidl_generator_py``：提供用于为``rosidl``文件生成Python模块的工具。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:159
msgid "``rosidl_parser``: provides Python |API| for parsing ``rosidl`` files."
msgstr "``rosidl_parser``：提供用于解析``rosidl``文件的Python |API|。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:161
msgid "Generators for other languages, e.g. ``rosidl_generator_java``, are hosted externally (in different repositories) but would use the same mechanism that the above generators use to \"register\" themselves as a ``rosidl`` generator."
msgstr "用于其他语言的生成器，例如``rosidl_generator_java``，由外部托管（在不同的存储库中），但使用与上述生成器相同的机制来将自己注册为``rosidl``生成器。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:163
msgid "In addition to the aforementioned |packages| for parsing and generating headers for the ``rosidl`` files, the ``rosidl`` repository also contains |packages| concerned with \"type support\" for the message types defined in the files. Type support refers to the ability to interpret and manipulate the information represented by ROS message instances of particular types (publishing the messages, for example). Type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the ``rosidl`` file, e.g. the ``.msg`` or ``.srv`` file, and the data received, by introspecting the data. In the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ROS 2 can be agnostic to the rmw implementation. The packages that provide this type support through introspection of the data are:"
msgstr "除了上述用于解析和生成``rosidl``文件中的标头的 |packages| 外，``rosidl``存储库还包含与文件中定义的消息类型相关的\"类型支持\" |packages|。类型支持指的是能够解释和操作特定类型的ROS消息实例所表示的信息的能力（例如，发布消息）。类型支持可以通过在编译时生成的代码提供，也可以根据``rosidl``文件（例如，``.msg``或``.srv``文件）和接收到的数据进行编程方式的动态处理。在后一种情况下，通过对消息进行运行时解释来实现类型支持，由ROS 2生成的消息代码可以与rmw实现无关。通过数据内省来提供此类型支持的软件包有："


#: ../../source/Concepts/About-Internal-Interfaces.rst:169
msgid "``rosidl_typesupport_introspection_c``: provides tools for generating C code for supporting ``rosidl`` message data types."
msgstr "``rosidl_typesupport_introspection_c``：提供用于支持``rosidl``消息数据类型的生成C代码的工具。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:170
msgid "``rosidl_typesupport_introspection_cpp``: provides tools for generating C++ code for supporting ``rosidl`` message data types."
msgstr "``rosidl_typesupport_introspection_cpp``：提供用于支持``rosidl``消息数据类型的生成C++代码的工具。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:172
msgid "In the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used. This is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the DDS vendor in order for the DDS implementation to make use of it. See the :ref:`Type Specific Interfaces` section above for more details."
msgstr "如果要在编译时生成类型支持，而不是以编程方式生成，将需要使用特定于rmw实现的软件包。这是因为通常特定的rmw实现需要以特定于DDS供应商的方式存储和操作数据，以便DDS实现能够使用它。有关更多详细信息，请参见上面的“特定类型接口”部分。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:176
msgid "For more information on what exactly is in the ``rosidl`` |API| (static and generated) see this page:"
msgstr "有关``rosidl`` |API|（静态和生成的）的详细信息，请参阅此页面："


#: ../../source/Concepts/About-Internal-Interfaces.rst:180
msgid "TODO: link to definition of ``rosidl`` |APIs|"
msgstr "待办事项：链接到``rosidl`` |APIs| 的定义"


#: ../../source/Concepts/About-Internal-Interfaces.rst:183
msgid "The ``rcutils`` Repository"
msgstr "``rcutils`` 代码库"


#: ../../source/Concepts/About-Internal-Interfaces.rst:185
msgid "ROS 2 C Utilities (``rcutils``) is a C |API| composed of macros, functions, and data structures used throughout the ROS 2 codebase. These are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both."
msgstr "ROS 2 C Utilities（``rcutils``）是一个由宏、函数和数据结构组成的 C |API|，在整个 ROS 2 代码库中广泛使用。主要用于错误处理、命令行参数解析和日志记录，这些功能与客户端或中间件层无关，可以被两者共享。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:188
msgid "The ``rcutils`` |API| and implementation are located in the `ros2/rcutils <https://github.com/ros2/rcutils>`_ repository on |GitHub|_ which contains the interface as C headers."
msgstr "``rcutils`` |API| 和实现位于 |GitHub|_ 上的 `ros2/rcutils <https://github.com/ros2/rcutils>`_ 代码库中，其中包含 C 头文件作为接口。"


#: ../../source/Concepts/About-Internal-Interfaces.rst:190
msgid "For a complete definition of the ``rcutils`` |API|, see `the rcutils docs <https://docs.ros.org/en/humble/p/rcutils/>`_."
msgstr "要完整了解 ``rcutils`` |API| 的定义，请参阅 `rcutils 文档 <https://docs.ros.org/en/humble/p/rcutils/>`_。"


#: ../../source/Concepts/About-Logging.rst:6
msgid "About logging and logger configuration"
msgstr "关于日志记录和日志记录器配置"


#: ../../source/Concepts/About-Logging.rst:16
msgid "The logging subsystem in ROS 2 aims to deliver logging messages to a variety of targets, including:"
msgstr "ROS 2 中的日志记录子系统旨在将日志消息传递到各种目标，包括："


#: ../../source/Concepts/About-Logging.rst:18
msgid "To the console (if one is attached)"
msgstr "输出到控制台（如果有连接的话）"


#: ../../source/Concepts/About-Logging.rst:19
msgid "To log files on disk (if local storage is available)"
msgstr "输出到磁盘上的日志文件（如果有本地存储可用）"


#: ../../source/Concepts/About-Logging.rst:20
msgid "To the ``/rosout`` topic on the ROS 2 network"
msgstr "输出到ROS 2网络上的``/rosout``主题"


#: ../../source/Concepts/About-Logging.rst:22
msgid "By default, log messages in ROS 2 nodes will go out to the console (on stderr), to log files on disk, and to the ``/rosout`` topic on the ROS 2 network. All of the targets can be individually enabled or disabled on a per-node basis."
msgstr "默认情况下，ROS 2节点中的日志消息将输出到控制台（stderr）、输出到磁盘上的日志文件以及输出到ROS 2网络上的``/rosout``主题。所有这些目标都可以在每个节点上独立启用或禁用。"


#: ../../source/Concepts/About-Logging.rst:25
msgid "The rest of this document will go over some of the ideas behind the logging subsystem."
msgstr "本文档的其余部分将介绍日志子系统背后的一些概念。"


#: ../../source/Concepts/About-Logging.rst:28
msgid "Severity level"
msgstr "严重程度级别"


#: ../../source/Concepts/About-Logging.rst:30
msgid "Log messages have a severity level associated with them: ``DEBUG``, ``INFO``, ``WARN``, ``ERROR`` or ``FATAL``, in ascending order."
msgstr "日志消息与严重级别关联：``DEBUG``（调试）、``INFO``（信息）、``WARN``（警告）、``ERROR``（错误）或 ``FATAL``（致命），按升序排列。"


#: ../../source/Concepts/About-Logging.rst:32
msgid "A logger will only process log messages with severity at or higher than a specified level chosen for the logger."
msgstr "记录器仅处理具有不低于记录器指定级别的严重级别的日志消息。"


#: ../../source/Concepts/About-Logging.rst:34
msgid "Each node has a logger associated with it that automatically includes the node's name and namespace. If the node's name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name. Non-node loggers can also be created that use a specific name."
msgstr "每个节点都有一个与之关联的记录器，自动包含节点的名称和命名空间。如果节点的名称在外部重映射为源代码中定义的其他内容，则会反映在记录器名称中。还可以创建使用特定名称的非节点记录器。"


#: ../../source/Concepts/About-Logging.rst:38
msgid "Logger names represent a hierarchy. If the level of a logger named \"abc.def\" is unset, it will defer to the level of its parent named \"abc\", and if that level is also unset, the default logger level will be used. When the level of logger \"abc\" is changed, all of its descendants (e.g. \"abc.def\", \"abc.ghi.jkl\") will have their level impacted unless their level has been explicitly set."
msgstr "记录器名称表示层次结构。如果名称为“abc.def”的记录器的级别未设置，它将推迟到其父级名称为“abc”的级别，如果该级别也未设置，则使用默认记录器级别。更改记录器“abc”的级别时，除非明确设置了它们的级别，否则会影响其所有后代（例如“abc.def”、“abc.ghi.jkl”）的级别。"


#: ../../source/Concepts/About-Logging.rst:43
msgid "APIs"
msgstr "API"


#: ../../source/Concepts/About-Logging.rst:45
msgid "These are the APIs that end users of the ROS 2 logging infrastructure should use, split up by client library."
msgstr "这些是ROS 2日志记录基础设施的终端用户应使用的API，按客户端库进行划分。"


#: ../../source/Concepts/About-Logging.rst:51
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - output the given printf-style message every time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - 每次执行到这行时输出给定的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:52
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - output the given printf-style message only the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - 仅在第一次执行到这行时输出给定的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:53
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - output the given printf-style message only if the given expression is true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - 仅在给定表达式为真时输出给定的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:54
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - output the given printf-style message only if the given function returns true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - 仅在给定函数返回 true 时输出给定的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:55
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - output the given printf-style message all but the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - 第一次执行到这行时除外，输出给定的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:56
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - 以整数毫秒为单位，输出不超过给定速率的 printf 样式的消息"


#: ../../source/Concepts/About-Logging.rst:57
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - 按照给定的整数毫秒速率输出printf风格的消息，但跳过第一次"


#: ../../source/Concepts/About-Logging.rst:58
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - output the given C++ stream-style message every time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - 每次执行到此行时，输出给定的C++流式消息"


#: ../../source/Concepts/About-Logging.rst:59
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - output the given C++ stream-style message only the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - 仅在第一次执行到此行时，输出给定的C++流式消息"


#: ../../source/Concepts/About-Logging.rst:60
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - output the given C++ stream-style message only if the given expression is true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - 仅在给定表达式为真时，输出给定的C++流式消息"


#: ../../source/Concepts/About-Logging.rst:61
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - output the given C++ stream-style message only if the given function returns true"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - 仅在给定函数返回真时，输出给定的C++流式消息"


#: ../../source/Concepts/About-Logging.rst:62
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - output the given C++ stream-style message all but the first time this line is hit"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - 第一次执行到此行时以外的其他时间，输出给定的C++流式消息"


#: ../../source/Concepts/About-Logging.rst:63
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - 以整数毫秒的速率输出给定的C++流式消息，不超过指定的速率"


#: ../../source/Concepts/About-Logging.rst:64
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - 以整数毫秒的速率输出给定的C++流式消息，不超过指定的速率，但跳过第一个消息"


#: ../../source/Concepts/About-Logging.rst:66
msgid "Each of the above APIs takes an ``rclcpp::Logger`` object as the first argument. This can be pulled from the node API by calling ``node->get_logger()`` (recommended), or by constructing a stand-alone ``rclcpp::Logger`` object."
msgstr "上述每个API的第一个参数都需要传递一个``rclcpp::Logger``对象。可以通过调用``node->get_logger()``（推荐）从节点API中获取该对象，或者构建一个独立的``rclcpp::Logger``对象。"


#: ../../source/Concepts/About-Logging.rst:69
msgid "``rcutils_logging_set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr "``rcutils_logging_set_logger_level`` - 将特定记录器名称的日志级别设置为给定的严重级别"


#: ../../source/Concepts/About-Logging.rst:70
msgid "``rcutils_logging_get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr "``rcutils_logging_get_logger_effective_level`` - 给定记录器名称，返回记录器的级别（可能未设置）"


#: ../../source/Concepts/About-Logging.rst:74
msgid "``logger.{debug,info,warning,error,fatal}`` - output the given Python string to the logging infrastructure.  The calls accept the following keyword args to control behavior:"
msgstr "``logger.{debug,info,warning,error,fatal}`` - 将给定的Python字符串输出到日志记录基础设施。这些调用接受以下关键字参数来控制行为："


#: ../../source/Concepts/About-Logging.rst:76
msgid "``throttle_duration_sec`` - if not None, the duration of the throttle interval in floating-point seconds"
msgstr "``throttle_duration_sec`` - 如果不是 None，则为浮点数秒数的节流间隔持续时间"


#: ../../source/Concepts/About-Logging.rst:77
msgid "``skip_first`` - if True, output the message all but the first time this line is hit"
msgstr "``skip_first`` - 如果为 True，则在第一次命中此行之外的所有时间输出消息"


#: ../../source/Concepts/About-Logging.rst:78
msgid "``once`` - if True, only output the message the first time this line is hit"
msgstr "``once`` - 如果为 True，则仅在第一次命中此行时输出消息"


#: ../../source/Concepts/About-Logging.rst:80
msgid "``rclpy.logging.set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr "``rclpy.logging.set_logger_level`` - 将特定日志记录器名称的日志记录级别设置为给定的严重级别"


#: ../../source/Concepts/About-Logging.rst:81
msgid "``rclpy.logging.get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr "``rclpy.logging.get_logger_effective_level`` - 给定日志记录器名称，返回日志记录级别（可能未设置）"


#: ../../source/Concepts/About-Logging.rst:84
msgid "Configuration"
msgstr "配置"


#: ../../source/Concepts/About-Logging.rst:86
msgid "Since ``rclcpp`` and ``rclpy`` use the same underlying logging infrastructure, the configuration options are the same."
msgstr "由于``rclcpp``和``rclpy``使用相同的底层日志记录基础设施，配置选项是相同的。"


#: ../../source/Concepts/About-Logging.rst:89
msgid "Environment variables"
msgstr "环境变量"


#: ../../source/Concepts/About-Logging.rst:91
msgid "The following environment variables control some aspects of the ROS 2 loggers. For each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process."
msgstr "以下环境变量控制ROS 2日志记录器的某些方面。对于每个环境设置，请注意这是一个进程级的设置，因此适用于该进程中的所有节点。"


#: ../../source/Concepts/About-Logging.rst:94
msgid "``ROS_LOG_DIR`` - Control the logging directory that is used for writing logging messages to disk (if that is enabled).  If non-empty, use the exact directory as specified in this variable.  If empty, use the contents of the ``ROS_HOME`` environment variable to construct a path of the form ``$ROS_HOME/.log``.  In all cases, the ``~`` character is expanded to the user's HOME directory."
msgstr "``ROS_LOG_DIR`` - 控制用于将日志消息写入磁盘的日志目录（如果启用）。如果非空，则使用此变量中指定的确切目录。如果为空，则使用``ROS_HOME``环境变量的内容构建路径，形式为``$ROS_HOME/.log``。在所有情况下，``~``字符会扩展为用户的主目录。"


#: ../../source/Concepts/About-Logging.rst:95
msgid "``ROS_HOME`` - Control the home directory that is used for various ROS files, including logging and config files.  In the context of logging, this variable is used to construct a path to a directory for log files.  If non-empty, use the contents of this variable for the ROS_HOME path.  In all cases, the ``~`` character is expanded to the users's HOME directory."
msgstr "``ROS_HOME`` - 控制用于各种ROS文件（包括日志和配置文件）的主目录。在日志记录的上下文中，此变量用于构建用于日志文件的目录路径。如果非空，则使用此变量的内容作为ROS_HOME路径。在所有情况下，``~``字符会扩展为用户的主目录。"


#: ../../source/Concepts/About-Logging.rst:96
msgid "``RCUTILS_LOGGING_USE_STDOUT`` - Control what stream output messages go to.  If this is unset or 0, use stderr.  If this is 1, use stdout."
msgstr "``RCUTILS_LOGGING_USE_STDOUT`` - 控制输出消息流的目标。如果未设置或为0，则使用stderr。如果为1，则使用stdout。"


#: ../../source/Concepts/About-Logging.rst:97
msgid "``RCUTILS_LOGGING_BUFFERED_STREAM`` - Control whether the logging stream (as configured in ``RCUTILS_LOGGING_USE_STDOUT``) should be line buffered or unbuffered.  If this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr).  If this is 0, force the stream to be unbuffered.  If this is 1, force the stream to be line buffered."
msgstr "``RCUTILS_LOGGING_BUFFERED_STREAM`` - 控制日志流（如在 ``RCUTILS_LOGGING_USE_STDOUT`` 中配置）是否应该是行缓冲或无缓冲的。如果未设置此项，则使用流的默认设置（通常为标准输出的行缓冲，标准错误输出的无缓冲）。如果设置为 0，则强制将流设置为无缓冲。如果设置为 1，则强制将流设置为行缓冲。"


#: ../../source/Concepts/About-Logging.rst:98
msgid "``RCUTILS_COLORIZED_OUTPUT`` - Control whether colors are used when outputting messages.  If unset, automatically determine based on the platform and whether the console is a TTY.  If 0, force disable using colors for output.  If 1, force enable using colors for output."
msgstr "``RCUTILS_COLORIZED_OUTPUT`` - 控制是否在输出消息时使用颜色。如果未设置此项，则根据平台和控制台是否为 TTY 自动确定。如果设置为 0，则强制禁用输出时使用颜色。如果设置为 1，则强制启用输出时使用颜色。"


#: ../../source/Concepts/About-Logging.rst:99
msgid "``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - Control the fields that are output for each log message.  The available fields are:"
msgstr "``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - 控制每条日志消息输出的字段。可用字段有："


#: ../../source/Concepts/About-Logging.rst:101
msgid "``{severity}`` - The severity level."
msgstr "``{severity}`` - 严重级别。"


#: ../../source/Concepts/About-Logging.rst:102
msgid "``{name}`` - The name of the logger (may be empty)."
msgstr "``{name}`` - 日志记录器的名称（可能为空）。"


#: ../../source/Concepts/About-Logging.rst:103
msgid "``{message}`` - The log message (may be empty)."
msgstr "``{message}`` - 日志消息（可能为空）。"


#: ../../source/Concepts/About-Logging.rst:104
msgid "``{function_name}`` - The function name this was called from (may be empty)."
msgstr "``{function_name}`` - 调用此函数的函数名称（可能为空）。"


#: ../../source/Concepts/About-Logging.rst:105
msgid "``{file_name}`` - The file name this was called from (may be empty)."
msgstr "``{file_name}`` - 调用此函数的文件名（可能为空）。"


#: ../../source/Concepts/About-Logging.rst:106
msgid "``{time}`` - The time in seconds since the epoch."
msgstr "``{time}`` - 自纪元以来的秒数。"


#: ../../source/Concepts/About-Logging.rst:107
msgid "``{time_as_nanoseconds}`` - The time in nanoseconds since the epoch."
msgstr "``{time_as_nanoseconds}`` - 自纪元以来的纳秒数。"


#: ../../source/Concepts/About-Logging.rst:108
msgid "``{line_number}`` - The line number this was called from (may be empty)."
msgstr "``{line_number}`` - 调用此函数的行号（可能为空）。"


#: ../../source/Concepts/About-Logging.rst:110
msgid "If no format is given, a default of ``[{severity}] [{time}] [{name}]: {message}`` is used."
msgstr "如果未提供格式，则使用默认格式 ``[{severity}] [{time}] [{name}]: {message}``。"


#: ../../source/Concepts/About-Logging.rst:114
msgid "Node creation"
msgstr "节点创建"


#: ../../source/Concepts/About-Logging.rst:116
msgid "When initializing a ROS 2 node, it is possible to control some aspects of the behavior via node options. Since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process."
msgstr "当初始化ROS 2节点时，可以通过节点选项来控制一些行为方面的细节。由于这些是每个节点的选项，即使将节点组合到单个进程中，也可以为不同的节点设置不同的选项。"


#: ../../source/Concepts/About-Logging.rst:119
msgid "``log_levels`` - The log level to use for a component within this particular node.  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``"
msgstr "``log_levels`` - 在此特定节点内使用的组件的日志级别。可以使用以下命令设置：``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``"


#: ../../source/Concepts/About-Logging.rst:120
msgid "``external_log_config_file`` - The external file to use to configure the backend logger.  If it is NULL, the default configuration will be used.  Note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog).  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``"
msgstr "``external_log_config_file`` - 用于配置后端日志记录器的外部文件。如果为NULL，则将使用默认配置。请注意，此文件的格式是特定于后端的（当前未实现默认后端记录器spdlog的配置）。可以使用以下命令设置：``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``"


#: ../../source/Concepts/About-Logging.rst:121
msgid "``log_stdout_disabled`` - Whether to disable writing log messages to the console.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``"
msgstr "``log_stdout_disabled`` - 是否禁止将日志消息写入控制台。可以使用以下命令执行：``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``"


#: ../../source/Concepts/About-Logging.rst:122
msgid "``log_rosout_disabled`` - Whether to disable writing log messages out to ``/rosout``.  This can significantly save on network bandwidth, but external observers will not be able to monitor logging.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``"
msgstr "``log_rosout_disabled`` - 是否禁止将日志消息写入``/rosout``。这可以大大节省网络带宽，但外部观察者将无法监视日志记录。可以使用以下命令执行：``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``"


#: ../../source/Concepts/About-Logging.rst:123
msgid "``log_ext_lib_disabled`` - Whether to completely disable the use of an external logger.  This may be faster in some cases, but means that logs will not be written to disk.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``"
msgstr "``log_ext_lib_disabled`` - 是否完全禁用外部日志记录器的使用。在某些情况下，这可能更快，但意味着日志不会写入磁盘。可以使用以下命令来实现：``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``"


#: ../../source/Concepts/About-Logging.rst:126
msgid "Logging subsystem design"
msgstr "日志子系统设计"


#: ../../source/Concepts/About-Logging.rst:128
msgid "The image below shows the five main pieces to the logging subsystem and how they interact."
msgstr "下图显示了日志子系统的五个主要组件及其交互方式。"


msgid "ROS 2 logging architecture"
msgstr "ROS 2 日志架构"


#: ../../source/Concepts/About-Logging.rst:136
msgid "rcutils"
msgstr "rcutils"


#: ../../source/Concepts/About-Logging.rst:138
msgid "``rcutils`` has a logging implementation that can format log messages according to a certain format (see ``Configuration`` above), and output those log messages to a console. ``rcutils`` implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model. This will become more evident when we talk about the ``rcl`` layer below."
msgstr "``rcutils``具有一个日志实现，可以根据特定格式（参见上面的``配置``）格式化日志消息，并将这些日志消息输出到控制台。``rcutils``实现了一个完整的日志解决方案，但允许较高级别的组件以依赖注入模型插入到日志基础设施中。当我们谈到下面的``rcl``层时，这将变得更加明显。"


#: ../../source/Concepts/About-Logging.rst:142
msgid "Note that this is a *per-process* logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes."
msgstr "请注意，这是一种*每个进程*的日志记录实现，因此在此级别配置的任何内容都将影响整个进程，而不仅仅是单个节点。"


#: ../../source/Concepts/About-Logging.rst:145
msgid "rcl_logging_spdlog"
msgstr "rcl_logging_spdlog"


#: ../../source/Concepts/About-Logging.rst:147
msgid "``rcl_logging_spdlog`` implements the ``rcl_logging_interface`` API, and thus provides external logging services to the ``rcl`` layer. In particular, the ``rcl_logging_spdlog`` implementation takes formatted log messages and writes them out to log files on disk using the ``spdlog`` library, typically within ``~/.ros/log`` (though this is configurable; see ``Configuration`` above)."
msgstr "``rcl_logging_spdlog`` 实现了 ``rcl_logging_interface`` API，因此为 ``rcl`` 层提供外部日志记录服务。特别是，``rcl_logging_spdlog`` 实现接受格式化的日志消息，并使用 ``spdlog`` 库将它们写入磁盘上的日志文件，通常位于 ``~/.ros/log``（尽管此处可配置；请参阅上述 ``Configuration``）。"


#: ../../source/Concepts/About-Logging.rst:151
msgid "rcl"
msgstr "rcl"


#: ../../source/Concepts/About-Logging.rst:153
msgid "The logging subsystem in ``rcl`` uses ``rcutils`` and ``rcl_logging_spdlog`` to provide the bulk of the ROS 2 logging services. When log messages come in, ``rcl`` decides where to send them. There are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled:"
msgstr "``rcl`` 中的日志记录子系统使用 ``rcutils`` 和 ``rcl_logging_spdlog`` 来提供大部分 ROS 2 日志记录服务。当日志消息到达时，``rcl`` 决定将其发送到何处。有三个主要位置可以传送日志消息；单个节点可以启用其中任意组合："


#: ../../source/Concepts/About-Logging.rst:157
msgid "To the console via the ``rcutils`` layer"
msgstr "通过 ``rcutils`` 层发送到控制台"


#: ../../source/Concepts/About-Logging.rst:158
msgid "To disk via the ``rcl_logging_spdlog`` layer"
msgstr "通过``rcl_logging_spdlog``层将日志写入磁盘"


#: ../../source/Concepts/About-Logging.rst:159
msgid "To the ``/rosout`` topic on the ROS 2 network via the RMW layer"
msgstr "通过RMW层将日志发送到ROS 2网络上的``/rosout``主题"


#: ../../source/Concepts/About-Logging.rst:162
msgid "rclcpp"
msgstr "rclcpp"


#: ../../source/Concepts/About-Logging.rst:164
msgid "This is the main ROS 2 C++ API which sits atop the ``rcl`` API. In the context of logging, ``rclcpp`` provides the ``RCLCPP_`` logging macros; see ``APIs`` above for a complete list. When one of the ``RCLCPP_`` macros runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. Note that ``rclcpp`` uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded."
msgstr "这是主要的ROS 2 C++ API，位于``rcl`` API之上。在日志记录的上下文中，``rclcpp``提供了``RCLCPP_``日志宏；请参阅上面的``APIs``获取完整列表。当运行其中一个``RCLCPP_``宏时，它会将节点的当前严重级别与宏的严重级别进行比较。如果宏的严重级别大于或等于节点的严重级别，则会对消息进行格式化，并输出到当前配置的所有位置。请注意，``rclcpp``在日志调用中使用全局互斥锁，因此同一进程内的所有日志调用最终都是单线程的。"


#: ../../source/Concepts/About-Logging.rst:172
msgid "rclpy"
msgstr "rclpy"


#: ../../source/Concepts/About-Logging.rst:174
msgid "This is the main ROS 2 Python API which sits atop the ``rcl`` API. In the context of logging, ``rclpy`` provides the ``logger.debug``-style functions; see ``APIs`` above for a complete list. When one of the ``logger.debug`` functions runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured."
msgstr "这是主要的ROS 2 Python API，位于``rcl`` API之上。在日志记录的上下文中，``rclpy``提供了``logger.debug``风格的函数；请参阅上面的``APIs``获取完整列表。当运行其中一个``logger.debug``函数时，它会将节点的当前严重级别与宏的严重级别进行比较。如果宏的严重级别大于或等于节点的严重级别，则会对消息进行格式化，并输出到当前配置的所有位置。"


#: ../../source/Concepts/About-Logging.rst:181
msgid "Logging usage"
msgstr "记录用法"


#: ../../source/Concepts/About-Logging.rst:187
msgid "See the `rclcpp logging demo <https://github.com/ros2/demos/tree/humble/logging_demo>`_ for some simple examples."
msgstr "查看 `rclcpp日志演示 <https://github.com/ros2/demos/tree/humble/logging_demo>`_ 获取一些简单的示例。"


#: ../../source/Concepts/About-Logging.rst:188
msgid "See the :doc:`logging demo <../Tutorials/Demos/Logging-and-logger-configuration>` for example usage."
msgstr "查看 :doc:`日志演示 <../Tutorials/Demos/Logging-and-logger-configuration>` 获取示例用法。"


#: ../../source/Concepts/About-Logging.rst:189
msgid "See the `rclcpp documentation <https://docs.ros2.org/latest/api/rclcpp/logging_8hpp.html>`__ for an extensive list of functionality."
msgstr "查看 `rclcpp文档 <https://docs.ros2.org/latest/api/rclcpp/logging_8hpp.html>`__ 获取详细功能列表。"


#: ../../source/Concepts/About-Logging.rst:193
msgid "See the `rclpy examples <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ for example usage of a node's logger."
msgstr "查看 `rclpy示例 <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ 以查看节点日志记录器的示例用法。"


#: ../../source/Concepts/About-Logging.rst:194
msgid "See the `rclpy tests <https://github.com/ros2/rclpy/blob/humble/rclpy/test/test_logging.py>`__ for example usage of keyword arguments (e.g. ``skip_first``, ``once``)."
msgstr "查看 `rclpy测试 <https://github.com/ros2/rclpy/blob/humble/rclpy/test/test_logging.py>`__ 以查看关键字参数的示例用法（例如``skip_first``，``once``）。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:3
msgid "About ROS 2 middleware implementations"
msgstr "关于ROS 2中间件实现"


#: ../../source/Concepts/About-Middleware-Implementations.rst:7
msgid "ROS middleware implementations are sets of |packages| that implement some of the internal ROS interfaces, e.g. the ``rmw``, ``rcl``, and ``rosidl`` |APIs|."
msgstr "ROS中间件实现是一组|packages|，用于实现一些内部的ROS接口，例如``rmw``、``rcl``和``rosidl``|APIs|。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:10
msgid "Common Packages for DDS Middleware Packages"
msgstr "DDS中间件的常见包"


#: ../../source/Concepts/About-Middleware-Implementations.rst:12
msgid "All of the current ROS middleware implementations are based on full or partial DDS implementations. For example, there is a middleware implementation that uses RTI's Connext DDS and an implementation which uses eProsima's Fast DDS. Because of this, there are some shared |packages| amongst most DDS based middleware implementations."
msgstr "所有当前的ROS中间件实现都基于完整或部分的DDS实现。例如，有一种中间件实现使用RTI的Connext DDS，另一种实现使用eProsima的Fast DDS。因此，在大多数基于DDS的中间件实现之间存在一些共享的|packages|。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:16
msgid "In the `ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_ repository on |GitHub|_, there is the following |package|:"
msgstr "在|GitHub|_上的`ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_代码库中，有以下|package|："


#: ../../source/Concepts/About-Middleware-Implementations.rst:18
msgid "``rosidl_generator_dds_idl``: provides tools to generate DDS ``.idl`` files from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr "``rosidl_generator_dds_idl``：提供从``rosidl``文件（例如``.msg``文件、``.srv``文件等）生成DDS ``.idl``文件的工具。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:20
msgid "The ``rosidl_generator_dds_idl`` |package| generates a DDS ``.idl`` file for each ``rosidl`` file, e.g. ``.msg`` file, defined by |packages| containing messages. Currently DDS based ROS middleware implementations make use of this generator's output ``.idl`` files to generate pre-compiled type support that is vendor specific."
msgstr "``rosidl_generator_dds_idl`` |package| 会为每个包含消息的 |packages| 中定义的 ``rosidl`` 文件（例如 ``.msg`` 文件）生成一个 DDS ``.idl`` 文件。目前基于 DDS 的 ROS 中间件实现使用该生成器的输出 ``.idl`` 文件来生成供应商特定的预编译类型支持。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:24
msgid "Structure of ROS Middleware Implementations"
msgstr "ROS 中间件实现的结构"


#: ../../source/Concepts/About-Middleware-Implementations.rst:26
msgid "A ROS middleware implementation is typically made up of a few |packages| in a single repository:"
msgstr "一个 ROS 中间件实现通常由一个单一仓库中的几个 |packages| 组成："


#: ../../source/Concepts/About-Middleware-Implementations.rst:28
msgid "``<implementation_name>_cmake_module``: contains CMake Module for discovering and exposing required dependencies"
msgstr "``<implementation_name>_cmake_module``：包含用于发现和公开所需依赖项的 CMake 模块"


#: ../../source/Concepts/About-Middleware-Implementations.rst:29
msgid "``rmw_<implementation_name>_<language>``: contains the implementation of the ``rmw`` |API| in a particular language, typically C++"
msgstr "``rmw_<implementation_name>_<language>``：包含特定语言（通常是 C++）中 ``rmw`` |API| 的实现"


#: ../../source/Concepts/About-Middleware-Implementations.rst:30
msgid "``rosidl_typesupport_<implementation_name>_<language>``: contains tools to generate static type support code for ``rosidl`` files, tailored to the implementation in a particular language, typically C or C++"
msgstr "``rosidl_typesupport_<implementation_name>_<language>``：包含用于为 ``rosidl`` 文件生成静态类型支持代码的工具，适用于特定语言的实现（通常是 C 或 C++）"


#: ../../source/Concepts/About-Middleware-Implementations.rst:32
msgid "The ``<implementation_name>_cmake_module`` |package| contains any CMake Modules and functions needed to find the supporting dependencies for the middleware implementation. For example, ``rti_connext_dds_cmake_module`` provides wrapper logic around the CMake Module shipped with RTI Connext DDS to make sure that all packages that depend on it will select the same installation of RTI Connext DDS. Similarly, ``fastrtps_cmake_module`` includes a CMake Module to find eProsima's Fast DDS and ``gurumdds_cmake_module`` includes a CMake Module to find GurumNetworks GurumDDS. Not all implementations will have a package like this: for example, Eclipe's Cyclone DDS already provides a CMake Module which is used directly by its RMW implementation without the need of additional wrappers."
msgstr "``<implementation_name>_cmake_module`` |package| 包含了查找中间件实现所需的所有 CMake 模块和函数。例如，``rti_connext_dds_cmake_module`` 提供了围绕 RTI Connext DDS 提供的 CMake 模块的包装逻辑，确保所有依赖它的软件包将选择相同的 RTI Connext DDS 安装。类似地，``fastrtps_cmake_module`` 包括一个用于查找 eProsima's Fast DDS 的 CMake 模块，而 ``gurumdds_cmake_module`` 包括一个用于查找 GurumNetworks GurumDDS 的 CMake 模块。并非所有实现都会有这样的包：例如，Eclipse 的 Cyclone DDS 已经提供了一个 CMake 模块，其 RMW 实现直接使用它，无需额外的包装。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:37
msgid "The ``rmw_<implementation_name>_<language>`` |package| implements the ``rmw`` C |API| in a particular language. The implementation itself can be C++, it just must expose the header's symbols as ``extern \"C\"`` so that C applications can link against it."
msgstr "``rmw_<implementation_name>_<language>`` |package| 在特定语言中实现了 ``rmw`` C |API|。实现本身可以是 C++，只需将头文件的符号公开为 ``extern \"C\"``，以便 C 应用程序可以链接到它。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:40
msgid "The ``rosidl_typesupport_<implementation_name>_<language>`` |package| provides a generator which generates DDS code in a particular language. This is done using the ``.idl`` files generated by the ``rosidl_generator_dds_idl`` |package| and the DDS IDL code generator provided by the DDS vendor. It also generates code for converting ROS message structures to and from DDS message structures. This generator is also responsible for creating a shared library for the message package it is being used in, which is specific to the messages in the message package and to the DDS vendor being used."
msgstr "``rosidl_typesupport_<implementation_name>_<language>`` |package| 提供了一个生成器，用于生成特定语言的 DDS 代码。这是使用 ``rosidl_generator_dds_idl`` |package| 生成的 ``.idl`` 文件和 DDS 供应商提供的 DDS IDL 代码生成器完成的。它还生成用于将 ROS 消息结构与 DDS 消息结构相互转换的代码。该生成器还负责为其所使用的消息包创建一个特定于消息包和所使用的 DDS 供应商的共享库。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:45
msgid "As mentioned above, the ``rosidl_typesupport_introspection_<language>`` may be used instead of a vendor specific type support package if an rmw implementation supports runtime interpretation of messages. This ability to programmatically send and receive types over topics without generating code beforehand is achieved by supporting the `DDS X-Types Dynamic Data standard <http://www.omg.org/spec/DDS-XTypes>`_. As such, rmw implementations may provide support for the X-Types standard, and/or provide a package for type support generated at compile time specific to their DDS implementation."
msgstr "如上所述，如果 rmw 实现支持消息的运行时解释，则可以使用 ``rosidl_typesupport_introspection_<language>`` 代替特定于供应商的类型支持包。通过支持 `DDS X-Types Dynamic Data 标准 <http://www.omg.org/spec/DDS-XTypes>`_，实现了在生成代码之前以编程方式在主题上发送和接收类型的能力。因此，rmw 实现可以提供对 X-Types 标准的支持，并/或者提供一个在编译时生成的类型支持包，特定于其 DDS 实现。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:49
msgid "As an example of an rmw implementation repository, the ``Eclipse Cyclone DDS`` ROS middleware implementation is on |GitHub|_ at `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_."
msgstr "以 ``Eclipse Cyclone DDS`` 作为 rmw 实现的示例，它的 ROS 中间件实现位于 |GitHub|_ 上的 `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:51
msgid "The rmw implementation for ``Fast DDS`` is on |GitHub|_ at `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_."
msgstr "``Fast DDS`` 的 rmw 实现位于 |GitHub|_ 上的 `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:53
msgid "The rmw implementation for ``Connext DDS`` is on |GitHub|_ at `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_."
msgstr "``Connext DDS`` 的 rmw 实现位于 |GitHub|_ 上，链接为 `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:55
msgid "The rmw implementation for ``GurumDDS`` is on |GitHub|_ at `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_."
msgstr "``GurumDDS`` 的 rmw 实现位于 |GitHub|_ 上，链接为 `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_。"


#: ../../source/Concepts/About-Middleware-Implementations.rst:57
msgid "To learn more about what is required to create a new middleware implementation for ROS see this page:"
msgstr "要了解有关为 ROS 创建新的中间件实现所需的更多信息，请参阅此页面："


#: ../../source/Concepts/About-Middleware-Implementations.rst:61
msgid "TODO: Link to more detailed middleware implementation docs and/or tutorial."
msgstr "TODO: 链接到更详细的中间件实现文档和/或教程。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:6
msgid "About Quality of Service settings"
msgstr "关于服务质量设置"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:12
msgid "ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes. With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between. Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a “best effort” policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines."
msgstr "ROS 2 提供了丰富多样的服务质量 (Quality of Service，QoS) 策略，使您能够调整节点之间的通信。通过适当的服务质量策略集合，ROS 2 可以像 TCP 一样可靠，也可以像 UDP 一样尽力而为，在中间还有许多可能的状态。与主要仅支持 TCP 的 ROS 1 不同，ROS 2 在具有有损无线网络的环境中从底层 DDS 传输的灵活性中受益，那里“尽力而为”策略更为合适，或者在实时计算系统中需要正确的服务质量配置文件以满足截止日期。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:16
msgid "A set of QoS “policies” combine to form a QoS “profile”. Given the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common use cases (e.g. sensor data). At the same time, developers are given the flexibility to control specific policies of the QoS profiles."
msgstr "一组QoS“策略”组合形成一个QoS“配置文件”。考虑到为特定场景选择正确的QoS策略的复杂性，ROS 2为常见用例（例如传感器数据）提供了一组预定义的QoS配置文件。与此同时，开发人员可以灵活控制QoS配置文件的特定策略。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:20
msgid "QoS profiles can be specified for publishers, subscriptions, service servers and clients. A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages."
msgstr "可以为发布者、订阅者、服务服务器和客户端指定QoS配置文件。一个QoS配置文件可以独立应用于上述实体的每个实例，但如果使用不同的配置文件，可能会导致不兼容，从而阻止消息的传递。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:25
msgid "QoS policies"
msgstr "QoS策略"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:27
msgid "The base QoS profile currently includes settings for the following policies:"
msgstr "基本QoS配置文件当前包括以下策略的设置："


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:29
msgid "History"
msgstr "历史记录"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:31
msgid "*Keep last*: only store up to N samples, configurable via the queue depth option."
msgstr "保留最近：仅存储最多N个样本，可通过队列深度选项进行配置。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:32
msgid "*Keep all*: store all samples, subject to the configured resource limits of the underlying middleware."
msgstr "*全部保留*: 将所有样本存储，受基础中间件配置的资源限制约束。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:34
msgid "Depth"
msgstr "深度"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:36
msgid "*Queue size*: only honored if the “history” policy was set to “keep last”."
msgstr "*队列大小*: 仅在“历史”策略设置为“保留最新”时受到尊重。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:38
msgid "Reliability"
msgstr "可靠性"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:40
msgid "*Best effort*: attempt to deliver samples, but may lose them if the network is not robust."
msgstr "*尽力而为*: 尝试传递样本，但如果网络不稳定，可能会丢失它们。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:41
msgid "*Reliable*: guarantee that samples are delivered, may retry multiple times."
msgstr "*可靠传递*: 保证样本被传递，可能会进行多次重试。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:43
msgid "Durability"
msgstr "耐久性"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:45
msgid "*Transient local*: the publisher becomes responsible for persisting samples for “late-joining” subscriptions."
msgstr "*瞬态本地*：发布者负责为“后加入”的订阅持久化样本。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:46
msgid "*Volatile*: no attempt is made to persist samples."
msgstr "*易失性*：不尝试持久化样本。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:48
msgid "Deadline"
msgstr "截止日期"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:50
msgid "*Duration*: the expected maximum amount of time between subsequent messages being published to a topic"
msgstr "*持续时间*：期望的发布到主题的连续消息之间的最大时间间隔。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:52
msgid "Lifespan"
msgstr "寿命"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:54
msgid "*Duration*: the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received)."
msgstr "*持续时间*：在发布消息和接收消息之间的最大时间间隔，超过此时间则将认为消息已过期或失效（已过期的消息将被静默丢弃，实际上永远不会被接收）。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:56
msgid "Liveliness"
msgstr "活跃性"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:58
msgid "*Automatic*: the system will consider all of the node’s publishers to be alive for another “lease duration” when any one of its publishers has published a message."
msgstr "*自动*：当任何一个发布者发布消息时，系统将认为该节点的所有发布者都仍然存活，持续时间为“租约期”。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:59
msgid "*Manual by topic*: the system will consider the publisher to be alive for another “lease duration” if it manually asserts that it is still alive (via a call to the publisher API)."
msgstr "*按主题手动*：如果发布者通过调用发布者API手动断言自己仍然存活，则系统将认为该发布者在“租约期”内仍然存活。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:61
msgid "Lease Duration"
msgstr "租约期"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:63
msgid "*Duration*: the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure)."
msgstr "*持续时间*：在系统认为发布者失去活跃性之前，发布者有的最长时间来表明自己仍然存活（失去活跃性可能表明出现故障）。"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:65
msgid "For each of the policies that is not a duration, there is also the option of “system default”, which uses the default of the underlying middleware. For each of the policies that is a duration, there also exists a “default” option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration."
msgstr "For each of the policies that is not a duration, there is also the option of “system default”, which uses the default of the underlying middleware. For each of the policies that is a duration, there also exists a “default” option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:69 ../../source/Concepts/About-Quality-of-Service-Settings.rst:265 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:119 ../../source/Concepts/About-Topic-Statistics.rst:75
msgid "Comparison to ROS 1"
msgstr "Comparison to ROS 1"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:71
msgid "The “history” and “depth” policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1."
msgstr "The “history” and “depth” policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:73
msgid "The “reliability” policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for “best effort”, or TCPROS (ROS 1 default) for “reliable”. Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate."
msgstr "The “reliability” policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for “best effort”, or TCPROS (ROS 1 default) for “reliable”. Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:76
msgid "The “durability” policy “transient local”, combined with any depth, provides functionality similar to that of “latching” publishers. The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect. It is possible that in the future, even more QoS policies will be available in ROS 2."
msgstr "The “durability” policy “transient local”, combined with any depth, provides functionality similar to that of “latching” publishers. The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect. It is possible that in the future, even more QoS policies will be available in ROS 2."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:82
msgid "QoS profiles"
msgstr "QoS profiles"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:84
msgid "Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case."
msgstr "Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:87
msgid "The currently defined QoS profiles are:"
msgstr "The currently defined QoS profiles are:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:89
msgid "Default QoS settings for publishers and subscriptions"
msgstr "Default QoS settings for publishers and subscriptions"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:91
msgid "In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable. By default, publishers and subscriptions in ROS 2 have “keep last” for history with a queue size of 10, “reliable” for reliability, “volatile” for durability, and “system default” for liveliness. Deadline, lifespan, and lease durations are also all set to “default”."
msgstr "In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable. By default, publishers and subscriptions in ROS 2 have “keep last” for history with a queue size of 10, “reliable” for reliability, “volatile” for durability, and “system default” for liveliness. Deadline, lifespan, and lease durations are also all set to “default”."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:95
msgid "Services"
msgstr "服务"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:97
msgid "In the same vein as publishers and subscriptions, services are reliable. It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests."
msgstr "In the same vein as publishers and subscriptions, services are reliable. It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:101
msgid "Sensor data"
msgstr "Sensor data"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:103
msgid "For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. For that reason the sensor data profile uses best effort reliability and a smaller queue size."
msgstr "For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. For that reason the sensor data profile uses best effort reliability and a smaller queue size."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:107 ../../source/Concepts/About-ROS-2-Client-Libraries.rst:31
msgid "Parameters"
msgstr "参数"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:109
msgid "Parameters in ROS 2 are based on services, and as such have a similar profile. The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server."
msgstr "Parameters in ROS 2 are based on services, and as such have a similar profile. The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:112
msgid "System default"
msgstr "System default"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:114
msgid "This uses the RMW implementation’s default values for all of the policies. Different RMW implementations may have different defaults."
msgstr "This uses the RMW implementation’s default values for all of the policies. Different RMW implementations may have different defaults."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:117
msgid "`Click here <https://github.com/ros2/rmw/blob/humble/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles. The settings in these profiles are subject to further tweaks, based on the feedback from the community."
msgstr "`Click here <https://github.com/ros2/rmw/blob/humble/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles. The settings in these profiles are subject to further tweaks, based on the feedback from the community."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:122
msgid "QoS compatibilities"
msgstr "QoS compatibilities"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:124
msgid "**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner."
msgstr "**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:126
msgid "QoS profiles may be configured for publishers and subscriptions independently. A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles."
msgstr "QoS profiles may be configured for publishers and subscriptions independently. A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:129
msgid "QoS profile compatibility is determined based on a “Request vs Offered” model. Subscriptions *request* a QoS profile that is the “minimum quality” that it is willing to accept, and publishers *offer* a QoS profile that is the “maximum quality” that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile. Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different. The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions."
msgstr "QoS profile compatibility is determined based on a “Request vs Offered” model. Subscriptions *request* a QoS profile that is the “minimum quality” that it is willing to accept, and publishers *offer* a QoS profile that is the “maximum quality” that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile. Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different. The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:135
msgid "The following tables show the compatibility of the different policy settings and the result:"
msgstr "The following tables show the compatibility of the different policy settings and the result:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:137
msgid "*Compatibility of reliability QoS policies:*"
msgstr "*Compatibility of reliability QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:142 ../../source/Concepts/About-Quality-of-Service-Settings.rst:163 ../../source/Concepts/About-Quality-of-Service-Settings.rst:186 ../../source/Concepts/About-Quality-of-Service-Settings.rst:213 ../../source/Concepts/About-Quality-of-Service-Settings.rst:236
msgid "Publisher"
msgstr "Publisher"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:143 ../../source/Concepts/About-Quality-of-Service-Settings.rst:164 ../../source/Concepts/About-Quality-of-Service-Settings.rst:187 ../../source/Concepts/About-Quality-of-Service-Settings.rst:214 ../../source/Concepts/About-Quality-of-Service-Settings.rst:237
msgid "Subscription"
msgstr "Subscription"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:144 ../../source/Concepts/About-Quality-of-Service-Settings.rst:165 ../../source/Concepts/About-Quality-of-Service-Settings.rst:188 ../../source/Concepts/About-Quality-of-Service-Settings.rst:215 ../../source/Concepts/About-Quality-of-Service-Settings.rst:238
msgid "Compatible"
msgstr "Compatible"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:145 ../../source/Concepts/About-Quality-of-Service-Settings.rst:146 ../../source/Concepts/About-Quality-of-Service-Settings.rst:148 ../../source/Concepts/About-Quality-of-Service-Settings.rst:152
msgid "Best effort"
msgstr "Best effort"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:147 ../../source/Concepts/About-Quality-of-Service-Settings.rst:153 ../../source/Concepts/About-Quality-of-Service-Settings.rst:156 ../../source/Concepts/About-Quality-of-Service-Settings.rst:168 ../../source/Concepts/About-Quality-of-Service-Settings.rst:174 ../../source/Concepts/About-Quality-of-Service-Settings.rst:177 ../../source/Concepts/About-Quality-of-Service-Settings.rst:191 ../../source/Concepts/About-Quality-of-Service-Settings.rst:197 ../../source/Concepts/About-Quality-of-Service-Settings.rst:200 ../../source/Concepts/About-Quality-of-Service-Settings.rst:203 ../../source/Concepts/About-Quality-of-Service-Settings.rst:218 ../../source/Concepts/About-Quality-of-Service-Settings.rst:224 ../../source/Concepts/About-Quality-of-Service-Settings.rst:227 ../../source/Concepts/About-Quality-of-Service-Settings.rst:241 ../../source/Concepts/About-Quality-of-Service-Settings.rst:247 ../../source/Concepts/About-Quality-of-Service-Settings.rst:250 ../../source/Concepts/About-Quality-of-Service-Settings.rst:253
msgid "Yes"
msgstr "Yes"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:149 ../../source/Concepts/About-Quality-of-Service-Settings.rst:151 ../../source/Concepts/About-Quality-of-Service-Settings.rst:154 ../../source/Concepts/About-Quality-of-Service-Settings.rst:155
msgid "Reliable"
msgstr "Reliable"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:150 ../../source/Concepts/About-Quality-of-Service-Settings.rst:171 ../../source/Concepts/About-Quality-of-Service-Settings.rst:194 ../../source/Concepts/About-Quality-of-Service-Settings.rst:206 ../../source/Concepts/About-Quality-of-Service-Settings.rst:221 ../../source/Concepts/About-Quality-of-Service-Settings.rst:244 ../../source/Concepts/About-Quality-of-Service-Settings.rst:256
msgid "No"
msgstr "No"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:158
msgid "*Compatibility of durability QoS policies:*"
msgstr "*Compatibility of durability QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:166 ../../source/Concepts/About-Quality-of-Service-Settings.rst:167 ../../source/Concepts/About-Quality-of-Service-Settings.rst:169 ../../source/Concepts/About-Quality-of-Service-Settings.rst:173
msgid "Volatile"
msgstr "Volatile"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:170 ../../source/Concepts/About-Quality-of-Service-Settings.rst:172 ../../source/Concepts/About-Quality-of-Service-Settings.rst:175 ../../source/Concepts/About-Quality-of-Service-Settings.rst:176
msgid "Transient local"
msgstr "Transient local"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:179
msgid "*Compatibility of deadline QoS policies:*"
msgstr "*Compatibility of deadline QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:181 ../../source/Concepts/About-Quality-of-Service-Settings.rst:231
msgid "Assume *x* and *y* are arbitrary valid duration values."
msgstr "Assume *x* and *y* are arbitrary valid duration values."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:189 ../../source/Concepts/About-Quality-of-Service-Settings.rst:190 ../../source/Concepts/About-Quality-of-Service-Settings.rst:192 ../../source/Concepts/About-Quality-of-Service-Settings.rst:196 ../../source/Concepts/About-Quality-of-Service-Settings.rst:239 ../../source/Concepts/About-Quality-of-Service-Settings.rst:240 ../../source/Concepts/About-Quality-of-Service-Settings.rst:242 ../../source/Concepts/About-Quality-of-Service-Settings.rst:246
msgid "Default"
msgstr "Default"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:193 ../../source/Concepts/About-Quality-of-Service-Settings.rst:195 ../../source/Concepts/About-Quality-of-Service-Settings.rst:198 ../../source/Concepts/About-Quality-of-Service-Settings.rst:199 ../../source/Concepts/About-Quality-of-Service-Settings.rst:201 ../../source/Concepts/About-Quality-of-Service-Settings.rst:204 ../../source/Concepts/About-Quality-of-Service-Settings.rst:243 ../../source/Concepts/About-Quality-of-Service-Settings.rst:245 ../../source/Concepts/About-Quality-of-Service-Settings.rst:248 ../../source/Concepts/About-Quality-of-Service-Settings.rst:249 ../../source/Concepts/About-Quality-of-Service-Settings.rst:251 ../../source/Concepts/About-Quality-of-Service-Settings.rst:254
msgid "*x*"
msgstr "*x*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:202 ../../source/Concepts/About-Quality-of-Service-Settings.rst:252
msgid "*y* (where *y* > *x*)"
msgstr "*y* (where *y* > *x*)"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:205 ../../source/Concepts/About-Quality-of-Service-Settings.rst:255
msgid "*y* (where *y* < *x*)"
msgstr "*y* (where *y* < *x*)"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:208
msgid "*Compatibility of liveliness QoS policies:*"
msgstr "*Compatibility of liveliness QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:216 ../../source/Concepts/About-Quality-of-Service-Settings.rst:217 ../../source/Concepts/About-Quality-of-Service-Settings.rst:219 ../../source/Concepts/About-Quality-of-Service-Settings.rst:223
msgid "Automatic"
msgstr "Automatic"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:220 ../../source/Concepts/About-Quality-of-Service-Settings.rst:222 ../../source/Concepts/About-Quality-of-Service-Settings.rst:225 ../../source/Concepts/About-Quality-of-Service-Settings.rst:226
msgid "Manual by topic"
msgstr "Manual by topic"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:229
msgid "*Compatibility of lease duration QoS policies:*"
msgstr "*Compatibility of lease duration QoS policies:*"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:258
msgid "In order for a connection to be made, all of the policies that affect compatibility must be compatible. For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made."
msgstr "In order for a connection to be made, all of the policies that affect compatibility must be compatible. For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:261
msgid "When connections are not made, no messages will be passed between the publisher and subscription. There are mechanisms to detect this situation, which will be covered in a later section."
msgstr "When connections are not made, no messages will be passed between the publisher and subscription. There are mechanisms to detect this situation, which will be covered in a later section."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:267
msgid "Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected. The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2."
msgstr "Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected. The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:272
msgid "QoS events"
msgstr "QoS events"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:274
msgid "Some QoS policies have possible events related to them. Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled."
msgstr "Some QoS policies have possible events related to them. Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:277
msgid "Developers may subscribe to the following QoS events that are associated with a publisher:"
msgstr "Developers may subscribe to the following QoS events that are associated with a publisher:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:279
msgid "Offered deadline missed"
msgstr "Offered deadline missed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:281
msgid "The publisher has not published a message within the expected duration that was set out by the deadline QoS policy."
msgstr "The publisher has not published a message within the expected duration that was set out by the deadline QoS policy."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:283
msgid "Liveliness lost"
msgstr "Liveliness lost"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:285
msgid "The publisher has failed to indicate its liveliness within the lease duration."
msgstr "The publisher has failed to indicate its liveliness within the lease duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:287
msgid "Offered incompatible QoS"
msgstr "Offered incompatible QoS"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:289
msgid "The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription."
msgstr "The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:291
msgid "Developers may subscribe to the following QoS events that are associated with a subscription:"
msgstr "Developers may subscribe to the following QoS events that are associated with a subscription:"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:293
msgid "Requested deadline missed"
msgstr "Requested deadline missed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:295
msgid "The subscription has not received a message within the expected duration that was set out by the deadline QoS policy."
msgstr "The subscription has not received a message within the expected duration that was set out by the deadline QoS policy."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:297
msgid "Liveliness changed"
msgstr "Liveliness changed"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:299
msgid "The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration."
msgstr "The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration."


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:301
msgid "Requested incompatible QoS"
msgstr "Requested incompatible QoS"


#: ../../source/Concepts/About-Quality-of-Service-Settings.rst:303
msgid "The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher."
msgstr "The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:10
msgid "About ROS 2 client libraries"
msgstr "About ROS 2 client libraries"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:18
msgid "Client libraries are the APIs that allow users to implement their ROS code. Using client libraries, users gain access to ROS concepts such as nodes, topics, services, etc. Client libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application. For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++."
msgstr "Client libraries are the APIs that allow users to implement their ROS code. Using client libraries, users gain access to ROS concepts such as nodes, topics, services, etc. Client libraries come in a variety of programming languages so that users may write ROS code in the language that is best-suited for their application. For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:23
msgid "Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language."
msgstr "Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS interface files in the respective language."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:25
msgid "In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”. For example, here is a list of functionality that can typically be accessed through a client library:"
msgstr "In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS “ROS”. For example, here is a list of functionality that can typically be accessed through a client library:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:29
msgid "Names and namespaces"
msgstr "Names and namespaces"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:30
msgid "Time (real or simulated)"
msgstr "Time (real or simulated)"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:32
msgid "Console logging"
msgstr "Console logging"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:33
msgid "Threading model"
msgstr "Threading model"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:34
msgid "Intra-process communication"
msgstr "Intra-process communication"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:37
msgid "Supported client libraries"
msgstr "Supported client libraries"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:39
msgid "The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in the RCL."
msgstr "The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in the RCL."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:42
msgid "The ``rclcpp`` Package"
msgstr "The ``rclcpp`` Package"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:44
msgid "The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions. ``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``."
msgstr "The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions. ``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:47
msgid "``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|."
msgstr "``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:49
msgid "The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``. The generated |API| documentation is here:"
msgstr "The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``. The generated |API| documentation is here:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:52
msgid "`api/rclcpp/index.html <http://docs.ros.org/en/humble/p/rclcpp>`_"
msgstr "`api/rclcpp/index.html <http://docs.ros.org/en/humble/p/rclcpp>`_"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:55
msgid "The ``rclpy`` Package"
msgstr "The ``rclpy`` Package"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:57
msgid "The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library. Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation. The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects. By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior. In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|."
msgstr "The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library. Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation. The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects. By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior. In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:63
msgid "Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message. All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|. This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python."
msgstr "Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message. All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|. This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:67
msgid "The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``. The generated |API| documentation is here:"
msgstr "The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``. The generated |API| documentation is here:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:70
msgid "`api/rclpy/index.html <http://docs.ros2.org/foxy/api/rclpy/index.html>`_"
msgstr "`api/rclpy/index.html <http://docs.ros2.org/foxy/api/rclpy/index.html>`_"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:74
msgid "Community-maintained"
msgstr "Community-maintained"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:76
msgid "While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:"
msgstr "While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:78
msgid "`Ada <https://github.com/ada-ros/ada4ros2>`__ Ada binding and tools for ROS 2 - workspace overlay."
msgstr "`Ada <https://github.com/ada-ros/ada4ros2>`__ Ada binding and tools for ROS 2 - workspace overlay."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:79
msgid "`C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials."
msgstr "`C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:80
msgid "`JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2."
msgstr "`JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:81
msgid "`.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard."
msgstr "`.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:82
msgid "`Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming."
msgstr "`Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:83
msgid "`Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust."
msgstr "`Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:85
msgid "Older, unmaintained client libraries are:"
msgstr "Older, unmaintained client libraries are:"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:87
msgid "`C# <https://github.com/firesurfer/rclcs>`__"
msgstr "`C# <https://github.com/firesurfer/rclcs>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:88
msgid "`Objective C and iOS <https://github.com/esteve/ros2_objc>`__"
msgstr "`Objective C and iOS <https://github.com/esteve/ros2_objc>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:92
msgid "Common functionality: the RCL"
msgstr "Common functionality: the RCL"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:94
msgid "Most of the functionality found in a client library is not specific to the programming language of the client library. For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific. As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces. This keeps client libraries thinner and easier to develop. For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap."
msgstr "Most of the functionality found in a client library is not specific to the programming language of the client library. For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific. As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces. This keeps client libraries thinner and easier to develop. For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:101
msgid "In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected. Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes."
msgstr "In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected. Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:105
msgid "`The API documentation for the RCL can be found here. <https://docs.ros2.org/latest/api/rcl/>`__"
msgstr "`The API documentation for the RCL can be found here. <https://docs.ros2.org/latest/api/rcl/>`__"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:108
msgid "Language-specific functionality"
msgstr "Language-specific functionality"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:110
msgid "Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library. For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library."
msgstr "Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library. For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:114
msgid "Demo"
msgstr "Demo"


#, python-format
msgid "For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__)."
msgstr "For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__)."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:121
msgid "In ROS 1, all client libraries are developed \"from the ground up\". This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code. However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS)."
msgstr "In ROS 1, all client libraries are developed \"from the ground up\". This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code. However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS)."


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:126
msgid "Summary"
msgstr "摘要"


#: ../../source/Concepts/About-ROS-2-Client-Libraries.rst:128
msgid "By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior."
msgstr "By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:8
msgid "About parameters in ROS 2"
msgstr "About parameters in ROS 2"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:16
msgid "Parameters in ROS are associated with individual nodes. Parameters are used to configure nodes at startup (and during runtime), without changing the code. The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart)."
msgstr "Parameters in ROS are associated with individual nodes. Parameters are used to configure nodes at startup (and during runtime), without changing the code. The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart)."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:20
msgid "Parameters are addressed by node name, node namespace, parameter name, and parameter namespace. Providing a parameter namespace is optional."
msgstr "Parameters are addressed by node name, node namespace, parameter name, and parameter namespace. Providing a parameter namespace is optional."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:23
msgid "Each parameter consists of a key, a value, and a descriptor. The key is a string and the value is one of the following types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints."
msgstr "Each parameter consists of a key, a value, and a descriptor. The key is a string and the value is one of the following types: bool, int64, float64, string, byte[], bool[], int64[], float64[] or string[]. By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:27
msgid "For an hands-on tutorial with ROS parameters see :doc:`../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`."
msgstr "For an hands-on tutorial with ROS parameters see :doc:`../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:30
msgid "Parameters background"
msgstr "Parameters background"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:33
msgid "Declaring parameters"
msgstr "Declaring parameters"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:35
msgid "By default, a node needs to *declare* all of the parameters that it will accept during its lifetime. This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. See :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node."
msgstr "By default, a node needs to *declare* all of the parameters that it will accept during its lifetime. This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. See :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:39
msgid "For some types of nodes, not all of the parameters will be known ahead of time. In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared."
msgstr "For some types of nodes, not all of the parameters will be known ahead of time. In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:43
msgid "Parameter types"
msgstr "Parameter types"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:45
msgid "Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview. By default, attempts to change the type of a declared parameter at runtime will fail. This prevents common mistakes, such as putting a boolean value into an integer parameter."
msgstr "Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview. By default, attempts to change the type of a declared parameter at runtime will fail. This prevents common mistakes, such as putting a boolean value into an integer parameter."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:49
msgid "If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``."
msgstr "If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:53
msgid "Parameter callbacks"
msgstr "Parameter callbacks"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:55
msgid "A ROS 2 node can register two different types of callbacks to be informed when changes are happening to parameters. The reason that there are two types of callbacks is to have a chance to intervene before the parameter change happens, and to have a chance to react after the parameter change happens. A node can register for both, either, or none of the callback types. Both types are described below."
msgstr "A ROS 2 node can register two different types of callbacks to be informed when changes are happening to parameters. The reason that there are two types of callbacks is to have a chance to intervene before the parameter change happens, and to have a chance to react after the parameter change happens. A node can register for both, either, or none of the callback types. Both types are described below."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:60
msgid "The first type is known as a \"set parameter\" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API. The callback should accept a list of ``Parameter`` objects, and return an ``rcl_interfaces/msg/SetParametersResult``. This callback will be called before a parameter is declared or changed on a node. The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change."
msgstr "The first type is known as a \"set parameter\" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API. The callback should accept a list of ``Parameter`` objects, and return an ``rcl_interfaces/msg/SetParametersResult``. This callback will be called before a parameter is declared or changed on a node. The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:66
msgid "It is important that \"set parameter\" callbacks have no side-effects. Since multiple \"set parameter\" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. To get a callback *after* a parameter has been successfully changed, see the next type of callback below."
msgstr "It is important that \"set parameter\" callbacks have no side-effects. Since multiple \"set parameter\" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. To get a callback *after* a parameter has been successfully changed, see the next type of callback below."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:71
msgid "The second type of callback is known as an \"on parameter event\" callback, and can be set by calling ``on_parameter_event`` from one of the parameter client APIs. The callback should accept an ``rcl_interfaces/msg/ParameterEvent`` object, and return nothing. This callback will be called after all parameters in the input event have been declared, changed, or deleted. The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted."
msgstr "The second type of callback is known as an \"on parameter event\" callback, and can be set by calling ``on_parameter_event`` from one of the parameter client APIs. The callback should accept an ``rcl_interfaces/msg/ParameterEvent`` object, and return nothing. This callback will be called after all parameters in the input event have been declared, changed, or deleted. The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:77
msgid "Interacting with parameters"
msgstr "Interacting with parameters"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:79
msgid "ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`. External processes can perform parameter operations via parameter services that are created by default when a node is instantiated. The services that are created by default are:"
msgstr "ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`. External processes can perform parameter operations via parameter services that are created by default when a node is instantiated. The services that are created by default are:"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:83
msgid "/node_name/describe_parameters: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``. Given a list of parameter names, returns a list of descriptors associated with the parameters."
msgstr "/node_name/describe_parameters: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``. Given a list of parameter names, returns a list of descriptors associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:85
msgid "/node_name/get_parameter_types: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``. Given a list of parameter names, returns a list of parameter types associated with the parameters."
msgstr "/node_name/get_parameter_types: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``. Given a list of parameter names, returns a list of parameter types associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:87
msgid "/node_name/get_parameters: Uses a service type of ``rcl_interfaces/srv/GetParameters``. Given a list of parameter names, returns a list of parameter values associated with the parameters."
msgstr "/node_name/get_parameters: Uses a service type of ``rcl_interfaces/srv/GetParameters``. Given a list of parameter names, returns a list of parameter values associated with the parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:89
msgid "/node_name/list_parameters: Uses a service type of ``rcl_interfaces/srv/ListParameters``. Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters."
msgstr "/node_name/list_parameters: Uses a service type of ``rcl_interfaces/srv/ListParameters``. Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:91
msgid "/node_name/set_parameters: Uses a service type of ``rcl_interfaces/srv/SetParameters``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed."
msgstr "/node_name/set_parameters: Uses a service type of ``rcl_interfaces/srv/SetParameters``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:93
msgid "/node_name/set_parameters_atomically: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed."
msgstr "/node_name/set_parameters_atomically: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:97
msgid "Setting initial parameter values when running a node"
msgstr "Setting initial parameter values when running a node"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:99
msgid "Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files. See :ref:`NodeArgsParameters` for examples on how to set initial parameter values."
msgstr "Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files. See :ref:`NodeArgsParameters` for examples on how to set initial parameter values."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:103
msgid "Setting initial parameter values when launching nodes"
msgstr "Setting initial parameter values when launching nodes"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:105
msgid "Initial parameter values can also be set when running the node through the ROS 2 launch facility. See :doc:`this document <../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch."
msgstr "Initial parameter values can also be set when running the node through the ROS 2 launch facility. See :doc:`this document <../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:109
msgid "Manipulating parameter values at runtime"
msgstr "Manipulating parameter values at runtime"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:111
msgid "The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running. ``ros2 param`` uses the parameter service API as described above to perform the various operations. See :doc:`this how-to guide <../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``."
msgstr "The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running. ``ros2 param`` uses the parameter service API as described above to perform the various operations. See :doc:`this how-to guide <../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:116
msgid "Migrating from ROS 1"
msgstr "Migrating from ROS 1"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:118
msgid "The :doc:`Launch file migration guide <../How-To-Guides/Launch-files-migration-guide>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2."
msgstr "The :doc:`Launch file migration guide <../How-To-Guides/Launch-files-migration-guide>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:120
msgid "The :doc:`YAML parameter file migration guide <../How-To-Guides/Parameters-YAML-files-migration-guide>` explains how to migrate parameter files from ROS 1 to ROS 2."
msgstr "The :doc:`YAML parameter file migration guide <../How-To-Guides/Parameters-YAML-files-migration-guide>` explains how to migrate parameter files from ROS 1 to ROS 2."


#: ../../source/Concepts/About-ROS-2-Parameters.rst:122
msgid "In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters. Since there is no central ``roscore`` in ROS 2, that functionality no longer exists. The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them. If a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ROS 2 ships with one in the ``ros-humble-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:"
msgstr "In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters. Since there is no central ``roscore`` in ROS 2, that functionality no longer exists. The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them. If a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ROS 2 ships with one in the ``ros-humble-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:"


#: ../../source/Concepts/About-ROS-2-Parameters.rst:132
msgid "The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__."
msgstr "The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__."


#: ../../source/Concepts/About-ROS-Interfaces.rst:8
msgid "About ROS 2 interfaces"
msgstr "About ROS 2 interfaces"


#: ../../source/Concepts/About-ROS-Interfaces.rst:14
msgid "1. Background"
msgstr "1. Background"


#: ../../source/Concepts/About-ROS-Interfaces.rst:16
msgid "ROS applications typically communicate through interfaces of one of three types: messages, services and actions. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages."
msgstr "ROS applications typically communicate through interfaces of one of three types: messages, services and actions. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages."


#: ../../source/Concepts/About-ROS-Interfaces.rst:20
msgid "In this document we will describe the supported types:"
msgstr "In this document we will describe the supported types:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:22
msgid "msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages."
msgstr "msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages."


#: ../../source/Concepts/About-ROS-Interfaces.rst:23
msgid "srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations."
msgstr "srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations."


#: ../../source/Concepts/About-ROS-Interfaces.rst:24
msgid "action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself."
msgstr "action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself."


#: ../../source/Concepts/About-ROS-Interfaces.rst:29
msgid "2. Message description specification"
msgstr "2. Message description specification"


#: ../../source/Concepts/About-ROS-Interfaces.rst:31
msgid "Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package. ``.msg`` files are composed of two parts: fields and constants."
msgstr "Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package. ``.msg`` files are composed of two parts: fields and constants."


#: ../../source/Concepts/About-ROS-Interfaces.rst:35
msgid "2.1 Fields"
msgstr "2.1 Fields"


#: ../../source/Concepts/About-ROS-Interfaces.rst:37
msgid "Each field consists of a type and a name, separated by a space, i.e:"
msgstr "Each field consists of a type and a name, separated by a space, i.e:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:45 ../../source/Concepts/About-ROS-Interfaces.rst:194 ../../source/Concepts/About-ROS-Interfaces.rst:218
msgid "For example:"
msgstr "For example:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:53
msgid "2.1.1 Field types"
msgstr "2.1.1 Field types"


#: ../../source/Concepts/About-ROS-Interfaces.rst:55
msgid "Field types can be:"
msgstr "Field types can be:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:58
msgid "a built-in-type"
msgstr "a built-in-type"


#: ../../source/Concepts/About-ROS-Interfaces.rst:59
msgid "names of Message descriptions defined on their own, such as \"geometry_msgs/PoseStamped\""
msgstr "names of Message descriptions defined on their own, such as \"geometry_msgs/PoseStamped\""


#: ../../source/Concepts/About-ROS-Interfaces.rst:61
msgid "*Built-in-types currently supported:*"
msgstr "*Built-in-types currently supported:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:66 ../../source/Concepts/About-ROS-Interfaces.rst:137
msgid "Type name"
msgstr "Type name"


#: ../../source/Concepts/About-ROS-Interfaces.rst:67 ../../source/Concepts/About-ROS-Interfaces.rst:138
msgid "`C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__"
msgstr "`C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:68 ../../source/Concepts/About-ROS-Interfaces.rst:139
msgid "`Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__"
msgstr "`Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:69 ../../source/Concepts/About-ROS-Interfaces.rst:140
msgid "`DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__"
msgstr "`DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__"


#: ../../source/Concepts/About-ROS-Interfaces.rst:70 ../../source/Concepts/About-ROS-Interfaces.rst:71
msgid "bool"
msgstr "bool"


#: ../../source/Concepts/About-ROS-Interfaces.rst:72
msgid "builtins.bool"
msgstr "builtins.bool"


#: ../../source/Concepts/About-ROS-Interfaces.rst:73
msgid "boolean"
msgstr "boolean"


#: ../../source/Concepts/About-ROS-Interfaces.rst:74
msgid "byte"
msgstr "byte"


#: ../../source/Concepts/About-ROS-Interfaces.rst:75 ../../source/Concepts/About-ROS-Interfaces.rst:95
msgid "uint8_t"
msgstr "uint8_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:76
msgid "builtins.bytes*"
msgstr "builtins.bytes*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:77 ../../source/Concepts/About-ROS-Interfaces.rst:93 ../../source/Concepts/About-ROS-Interfaces.rst:97
msgid "octet"
msgstr "octet"


#: ../../source/Concepts/About-ROS-Interfaces.rst:78 ../../source/Concepts/About-ROS-Interfaces.rst:79 ../../source/Concepts/About-ROS-Interfaces.rst:81
msgid "char"
msgstr "char"


#: ../../source/Concepts/About-ROS-Interfaces.rst:80 ../../source/Concepts/About-ROS-Interfaces.rst:155
msgid "builtins.str*"
msgstr "builtins.str*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:82
msgid "float32"
msgstr "float32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:83 ../../source/Concepts/About-ROS-Interfaces.rst:85
msgid "float"
msgstr "float"


#: ../../source/Concepts/About-ROS-Interfaces.rst:84 ../../source/Concepts/About-ROS-Interfaces.rst:88
msgid "builtins.float*"
msgstr "builtins.float*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:86
msgid "float64"
msgstr "float64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:87 ../../source/Concepts/About-ROS-Interfaces.rst:89
msgid "double"
msgstr "double"


#: ../../source/Concepts/About-ROS-Interfaces.rst:90
msgid "int8"
msgstr "int8"


#: ../../source/Concepts/About-ROS-Interfaces.rst:91
msgid "int8_t"
msgstr "int8_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:92 ../../source/Concepts/About-ROS-Interfaces.rst:96 ../../source/Concepts/About-ROS-Interfaces.rst:100 ../../source/Concepts/About-ROS-Interfaces.rst:104 ../../source/Concepts/About-ROS-Interfaces.rst:108 ../../source/Concepts/About-ROS-Interfaces.rst:112 ../../source/Concepts/About-ROS-Interfaces.rst:116 ../../source/Concepts/About-ROS-Interfaces.rst:120
msgid "builtins.int*"
msgstr "builtins.int*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:94
msgid "uint8"
msgstr "uint8"


#: ../../source/Concepts/About-ROS-Interfaces.rst:98
msgid "int16"
msgstr "int16"


#: ../../source/Concepts/About-ROS-Interfaces.rst:99
msgid "int16_t"
msgstr "int16_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:101
msgid "short"
msgstr "short"


#: ../../source/Concepts/About-ROS-Interfaces.rst:102
msgid "uint16"
msgstr "uint16"


#: ../../source/Concepts/About-ROS-Interfaces.rst:103
msgid "uint16_t"
msgstr "uint16_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:105
msgid "unsigned short"
msgstr "unsigned short"


#: ../../source/Concepts/About-ROS-Interfaces.rst:106
msgid "int32"
msgstr "int32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:107
msgid "int32_t"
msgstr "int32_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:109
msgid "long"
msgstr "long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:110
msgid "uint32"
msgstr "uint32"


#: ../../source/Concepts/About-ROS-Interfaces.rst:111
msgid "uint32_t"
msgstr "uint32_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:113
msgid "unsigned long"
msgstr "unsigned long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:114
msgid "int64"
msgstr "int64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:115
msgid "int64_t"
msgstr "int64_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:117
msgid "long long"
msgstr "long long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:118
msgid "uint64"
msgstr "uint64"


#: ../../source/Concepts/About-ROS-Interfaces.rst:119
msgid "uint64_t"
msgstr "uint64_t"


#: ../../source/Concepts/About-ROS-Interfaces.rst:121
msgid "unsigned long long"
msgstr "unsigned long long"


#: ../../source/Concepts/About-ROS-Interfaces.rst:122 ../../source/Concepts/About-ROS-Interfaces.rst:125 ../../source/Concepts/About-ROS-Interfaces.rst:156
msgid "string"
msgstr "string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:123 ../../source/Concepts/About-ROS-Interfaces.rst:154
msgid "std::string"
msgstr "std::string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:124 ../../source/Concepts/About-ROS-Interfaces.rst:128
msgid "builtins.str"
msgstr "builtins.str"


#: ../../source/Concepts/About-ROS-Interfaces.rst:126 ../../source/Concepts/About-ROS-Interfaces.rst:129
msgid "wstring"
msgstr "wstring"


#: ../../source/Concepts/About-ROS-Interfaces.rst:127
msgid "std::u16string"
msgstr "std::u16string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:132
msgid "*Every built-in-type can be used to define arrays:*"
msgstr "*Every built-in-type can be used to define arrays:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:141
msgid "static array"
msgstr "static array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:142
msgid "std::array<T, N>"
msgstr "std::array<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:143 ../../source/Concepts/About-ROS-Interfaces.rst:151
msgid "builtins.list*"
msgstr "builtins.list*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:144
msgid "T[N]"
msgstr "T[N]"


#: ../../source/Concepts/About-ROS-Interfaces.rst:145
msgid "unbounded dynamic array"
msgstr "unbounded dynamic array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:146
msgid "std::vector"
msgstr "std::vector"


#: ../../source/Concepts/About-ROS-Interfaces.rst:147
msgid "builtins.list"
msgstr "builtins.list"


#: ../../source/Concepts/About-ROS-Interfaces.rst:148
msgid "sequence"
msgstr "sequence"


#: ../../source/Concepts/About-ROS-Interfaces.rst:149
msgid "bounded dynamic array"
msgstr "bounded dynamic array"


#: ../../source/Concepts/About-ROS-Interfaces.rst:150
msgid "custom_class<T, N>"
msgstr "custom_class<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:152
msgid "sequence<T, N>"
msgstr "sequence<T, N>"


#: ../../source/Concepts/About-ROS-Interfaces.rst:153
msgid "bounded string"
msgstr "bounded string"


#: ../../source/Concepts/About-ROS-Interfaces.rst:159
msgid "All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software"
msgstr "All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software"


#: ../../source/Concepts/About-ROS-Interfaces.rst:161
msgid "*Example of message definition using arrays and bounded types:*"
msgstr "*Example of message definition using arrays and bounded types:*"


#: ../../source/Concepts/About-ROS-Interfaces.rst:177
msgid "2.1.2 Field names"
msgstr "2.1.2 Field names"


#: ../../source/Concepts/About-ROS-Interfaces.rst:179
msgid "Field names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores."
msgstr "Field names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores."


#: ../../source/Concepts/About-ROS-Interfaces.rst:183
msgid "2.1.3 Field default value"
msgstr "2.1.3 Field default value"


#: ../../source/Concepts/About-ROS-Interfaces.rst:185
msgid "Default values can be set to any field in the message type. Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages)."
msgstr "Default values can be set to any field in the message type. Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:188
msgid "Defining a default value is done by adding a third element to the field definition line, i.e:"
msgstr "Defining a default value is done by adding a third element to the field definition line, i.e:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:203
msgid "Note:"
msgstr "Note:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:206
msgid "string values must be defined in single ``'`` or double ``\"`` quotes"
msgstr "string values must be defined in single ``'`` or double ``\"`` quotes"


#: ../../source/Concepts/About-ROS-Interfaces.rst:207
msgid "currently string values are not escaped"
msgstr "currently string values are not escaped"


#: ../../source/Concepts/About-ROS-Interfaces.rst:210
msgid "2.2 Constants"
msgstr "2.2 Constants"


#: ../../source/Concepts/About-ROS-Interfaces.rst:212
msgid "Each constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal '=' sign, e.g."
msgstr "Each constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal '=' sign, e.g."


#: ../../source/Concepts/About-ROS-Interfaces.rst:229
msgid "Constants names have to be UPPERCASE"
msgstr "Constants names have to be UPPERCASE"


#: ../../source/Concepts/About-ROS-Interfaces.rst:232
msgid "3. Service description specification"
msgstr "3. Service description specification"


#: ../../source/Concepts/About-ROS-Interfaces.rst:234
msgid "Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package."
msgstr "Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package."


#: ../../source/Concepts/About-ROS-Interfaces.rst:236
msgid "A service description file consists of a request and a response msg type, separated by ``---``. Any two ``.msg`` files concatenated with a ``---`` are a legal service description."
msgstr "A service description file consists of a request and a response msg type, separated by ``---``. Any two ``.msg`` files concatenated with a ``---`` are a legal service description."


#: ../../source/Concepts/About-ROS-Interfaces.rst:239
msgid "Here is a very simple example of a service that takes in a string and returns a string:"
msgstr "Here is a very simple example of a service that takes in a string and returns a string:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:247
msgid "We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):"
msgstr "We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):"


#: ../../source/Concepts/About-ROS-Interfaces.rst:265
msgid "You cannot embed another service inside of a service."
msgstr "You cannot embed another service inside of a service."


#: ../../source/Concepts/About-ROS-Interfaces.rst:268
msgid "4. New features in ROS 2 interfaces"
msgstr "4. New features in ROS 2 interfaces"


#: ../../source/Concepts/About-ROS-Interfaces.rst:270
msgid "The ROS 2 IDL is closely related to the `ROS 1 IDL <https://wiki.ros.org/msg>`__. Most existing ROS 1 ``.msg`` and ``.srv`` files should be usable as-is with ROS 2. Atop ROS 1's existing feature set, the ROS 2 IDL introduces some new features, namely:"
msgstr "The ROS 2 IDL is closely related to the `ROS 1 IDL <https://wiki.ros.org/msg>`__. Most existing ROS 1 ``.msg`` and ``.srv`` files should be usable as-is with ROS 2. Atop ROS 1's existing feature set, the ROS 2 IDL introduces some new features, namely:"


#: ../../source/Concepts/About-ROS-Interfaces.rst:275
msgid "**bounded arrays**: Whereas the ROS 1 IDL allows unbounded arrays (e.g., ``int32[] foo``) and fixed-size arrays (e.g., ``int32[5] bar``), the ROS 2 IDL further allows bounded arrays (e.g., ``int32[<=5] bat``). There are use cases in which it's important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution)."
msgstr "**bounded arrays**: Whereas the ROS 1 IDL allows unbounded arrays (e.g., ``int32[] foo``) and fixed-size arrays (e.g., ``int32[5] bar``), the ROS 2 IDL further allows bounded arrays (e.g., ``int32[<=5] bat``). There are use cases in which it's important to be able to place an upper bound on the size of an array without committing to always using that much space (e.g., in a real-time system in which you need to preallocate all memory that will be used during execution)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:277
msgid "**bounded strings**: Whereas the ROS 1 IDL allows unbounded strings (e.g., ``string foo``), the ROS 2 IDL further allows bounded strings (e.g., ``string<=5 bar``)."
msgstr "**bounded strings**: Whereas the ROS 1 IDL allows unbounded strings (e.g., ``string foo``), the ROS 2 IDL further allows bounded strings (e.g., ``string<=5 bar``)."


#: ../../source/Concepts/About-ROS-Interfaces.rst:278
msgid "**default values**: Whereas the ROS 1 IDL allows constant fields (e.g., ``int32 X=123``), the ROS 2 IDL further allows default values to be specified (e.g., ``int32 X 123``). The default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field. You can also specify default values for action parts."
msgstr "**default values**: Whereas the ROS 1 IDL allows constant fields (e.g., ``int32 X=123``), the ROS 2 IDL further allows default values to be specified (e.g., ``int32 X 123``). The default value is used when constructing a message/service object and can be subsequently overridden by assigning to the field. You can also specify default values for action parts."


#: ../../source/Concepts/About-RQt.rst:9
msgid "Overview and usage of RQt"
msgstr "Overview and usage of RQt"


#: ../../source/Concepts/About-RQt.rst:18
msgid "RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout."
msgstr "RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt! The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout."


#: ../../source/Concepts/About-RQt.rst:22
msgid "You can run any RQt tools/plugins easily by:"
msgstr "You can run any RQt tools/plugins easily by:"


#: ../../source/Concepts/About-RQt.rst:28
msgid "This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Python Console:"
msgstr "This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Python Console:"


#: ../../source/Concepts/About-RQt.rst:36
msgid "Users can create their own plugins for RQt with either ``Python`` or ``C++``. To see what RQt plugins are available for your system, run:"
msgstr "Users can create their own plugins for RQt with either ``Python`` or ``C++``. To see what RQt plugins are available for your system, run:"


#: ../../source/Concepts/About-RQt.rst:43
msgid "And then look for packages that start with ``rqt_``."
msgstr "And then look for packages that start with ``rqt_``."


#: ../../source/Concepts/About-RQt.rst:46
msgid "System setup"
msgstr "System setup"


#: ../../source/Concepts/About-RQt.rst:49
msgid "Installing From Debian"
msgstr "Installing From Debian"


#: ../../source/Concepts/About-RQt.rst:57
msgid "Building From Source"
msgstr "从源代码构建"


#: ../../source/Concepts/About-RQt.rst:59
msgid "See :doc:`Building RQt from Source <../How-To-Guides/RQt-Source-Install>`."
msgstr "See :doc:`Building RQt from Source <../How-To-Guides/RQt-Source-Install>`."


#: ../../source/Concepts/About-RQt.rst:62
msgid "RQt Components Structure"
msgstr "RQt Components Structure"


#: ../../source/Concepts/About-RQt.rst:64
msgid "RQt consists of two metapackages:"
msgstr "RQt consists of two metapackages:"


#: ../../source/Concepts/About-RQt.rst:66
msgid "*rqt* - core infrastucture modules."
msgstr "*rqt* - core infrastucture modules."


#: ../../source/Concepts/About-RQt.rst:67
msgid "*rqt_common_plugins* - Commonly useful debugging tools."
msgstr "*rqt_common_plugins* - Commonly useful debugging tools."


#: ../../source/Concepts/About-RQt.rst:70
msgid "Advantage of RQt framework"
msgstr "Advantage of RQt framework"


#: ../../source/Concepts/About-RQt.rst:72
msgid "Compared to building your own GUIs from scratch:"
msgstr "Compared to building your own GUIs from scratch:"


#: ../../source/Concepts/About-RQt.rst:74
msgid "Standardized common procedures for GUI (start-shutdown hook, restore previous states)."
msgstr "Standardized common procedures for GUI (start-shutdown hook, restore previous states)."


#: ../../source/Concepts/About-RQt.rst:75
msgid "Multiple widgets can be docked in a single window."
msgstr "Multiple widgets can be docked in a single window."


#: ../../source/Concepts/About-RQt.rst:76
msgid "Easily turn your existing Qt widgets into RQt plugins."
msgstr "Easily turn your existing Qt widgets into RQt plugins."


#: ../../source/Concepts/About-RQt.rst:77
msgid "Expect support at `ROS Answers <https://answers.ros.org>`__ (ROS community website for the questions)."
msgstr "Expect support at `ROS Answers <https://answers.ros.org>`__ (ROS community website for the questions)."


#: ../../source/Concepts/About-RQt.rst:79
msgid "From system architecture's perspective:"
msgstr "From system architecture's perspective:"


#: ../../source/Concepts/About-RQt.rst:81
msgid "Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``)."
msgstr "Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``)."


#: ../../source/Concepts/About-RQt.rst:82
msgid "Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier."
msgstr "Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier."


#: ../../source/Concepts/About-RQt.rst:86
msgid "Further Reading"
msgstr "进一步阅读"


#: ../../source/Concepts/About-RQt.rst:88
msgid "ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)"
msgstr "ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)"


#: ../../source/Concepts/About-RQt.rst:89
msgid "`RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__"
msgstr "`RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__"


#: ../../source/Concepts/About-RQt.rst:90
msgid "Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)"
msgstr "Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)"


#: ../../source/Concepts/About-Security.rst:4
msgid "About ROS 2 Security"
msgstr "About ROS 2 Security"


#: ../../source/Concepts/About-Security.rst:13
msgid "Built-in ROS 2 security features enable control over communications throughout the ROS graph. This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls."
msgstr "Built-in ROS 2 security features enable control over communications throughout the ROS graph. This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls."


#: ../../source/Concepts/About-Security.rst:16
msgid "ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes. DDS vendors provide open source and commercial DDS implementations that work with ROS. However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_. ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control. DDS and ROS security is enabled through predefined configuration files and environment variables."
msgstr "ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes. DDS vendors provide open source and commercial DDS implementations that work with ROS. However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_. ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control. DDS and ROS security is enabled through predefined configuration files and environment variables."


#: ../../source/Concepts/About-Security.rst:24
msgid "The Security Enclave"
msgstr "The Security Enclave"


#: ../../source/Concepts/About-Security.rst:26
msgid "A security enclave encapsulates a single policy for protecting ROS communications. The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices. Security enclaves can be flexibly mapped to processes, users, or devices at deployment. Adjusting this default behavior becomes important for optimizing communications and for complex systems. See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details."
msgstr "A security enclave encapsulates a single policy for protecting ROS communications. The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices. Security enclaves can be flexibly mapped to processes, users, or devices at deployment. Adjusting this default behavior becomes important for optimizing communications and for complex systems. See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details."


#: ../../source/Concepts/About-Security.rst:34
msgid "Security Files"
msgstr "Security Files"


#: ../../source/Concepts/About-Security.rst:36
msgid "A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification. Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave. All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave."
msgstr "A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification. Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave. All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave."


#: ../../source/Concepts/About-Security.rst:41
msgid "Enclave Identity"
msgstr "Enclave Identity"


#: ../../source/Concepts/About-Security.rst:43
msgid "The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants. Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``. Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate. This valid certificate exchange allows the enclave to securely establish trusted communications with other participants. The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing."
msgstr "The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants. Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``. Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate. This valid certificate exchange allows the enclave to securely establish trusted communications with other participants. The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing."


#: ../../source/Concepts/About-Security.rst:50
msgid "Enclave Permissions"
msgstr "Enclave Permissions"


#: ../../source/Concepts/About-Security.rst:52
msgid "The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves. This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies. Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA. Domain members use a copy of the permissions CA to validate these signed files and grant the requested access."
msgstr "The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves. This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies. Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA. Domain members use a copy of the permissions CA to validate these signed files and grant the requested access."


#: ../../source/Concepts/About-Security.rst:57
msgid "Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority."
msgstr "Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority."


#: ../../source/Concepts/About-Security.rst:60
msgid "Private Keys"
msgstr "Private Keys"


#: ../../source/Concepts/About-Security.rst:62
msgid "The identity and permissions certificates also have associated private key files. Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key. Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key."
msgstr "The identity and permissions certificates also have associated private key files. Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key. Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key."


#: ../../source/Concepts/About-Security.rst:68
msgid "Security Environment Variables"
msgstr "Security Environment Variables"


#: ../../source/Concepts/About-Security.rst:70
msgid "The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master \"on/off\" switch for ROS 2 security features. Security has been turned off by default, so security features will not be enabled even when the proper security files are present. In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive)."
msgstr "The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master \"on/off\" switch for ROS 2 security features. Security has been turned off by default, so security features will not be enabled even when the proper security files are present. In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive)."


#: ../../source/Concepts/About-Security.rst:74
msgid "Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants. Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features. In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive)."
msgstr "Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants. Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features. In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive)."


#: ../../source/Concepts/About-Security.rst:78
msgid "Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_. These variables generally assist ROS in managing enclaves and locating the security files."
msgstr "Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_. These variables generally assist ROS in managing enclaves and locating the security files."


#: ../../source/Concepts/About-Security.rst:83
msgid "Learn More"
msgstr "Learn More"


#: ../../source/Concepts/About-Security.rst:85
msgid "For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../Tutorials/Advanced/Security/Introducing-ros2-security`."
msgstr "For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../Tutorials/Advanced/Security/Introducing-ros2-security`."


#: ../../source/Concepts/About-Tf2.rst:4
msgid "About tf2"
msgstr "About tf2"


#: ../../source/Concepts/About-Tf2.rst:13
msgid "tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time."
msgstr "tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time."


#: ../../source/Concepts/About-Tf2.rst:19
msgid "Properties of tf2"
msgstr "Properties of tf2"


#: ../../source/Concepts/About-Tf2.rst:21
msgid "A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:"
msgstr "A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:"


#: ../../source/Concepts/About-Tf2.rst:24
msgid "Where was the head frame relative to the world frame 5 seconds ago?"
msgstr "Where was the head frame relative to the world frame 5 seconds ago?"


#: ../../source/Concepts/About-Tf2.rst:25
msgid "What is the pose of the object in my gripper relative to my base?"
msgstr "What is the pose of the object in my gripper relative to my base?"


#: ../../source/Concepts/About-Tf2.rst:26
msgid "What is the current pose of the base frame in the map frame?"
msgstr "What is the current pose of the base frame in the map frame?"


#: ../../source/Concepts/About-Tf2.rst:28
msgid "tf2 can operate in a distributed system. This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system. tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information."
msgstr "tf2 can operate in a distributed system. This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system. tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information."


#: ../../source/Concepts/About-Tf2.rst:33
msgid "Tutorials"
msgstr "教程"


#: ../../source/Concepts/About-Tf2.rst:35
msgid "We created a set of :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step. You can get started on the :doc:`introduction to tf2 <../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial. For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` page."
msgstr "We created a set of :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step. You can get started on the :doc:`introduction to tf2 <../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial. For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../Tutorials/Intermediate/Tf2/Tf2-Main>` page."


#: ../../source/Concepts/About-Tf2.rst:39
msgid "There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms."
msgstr "There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms."


#: ../../source/Concepts/About-Tf2.rst:41
msgid "If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms. What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames. Check out the \"Writing a listener\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more."
msgstr "If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms. What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames. Check out the \"Writing a listener\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more."


#: ../../source/Concepts/About-Tf2.rst:45
msgid "To extend the capabilities of a robot, you will need to start broadcasting transforms. Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system. A system can have many broadcasters that each provide information about a different part of the robot. Check out the \"Writing a broadcaster\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more."
msgstr "To extend the capabilities of a robot, you will need to start broadcasting transforms. Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system. A system can have many broadcasters that each provide information about a different part of the robot. Check out the \"Writing a broadcaster\" tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more."


#: ../../source/Concepts/About-Tf2.rst:50
msgid "In addition to that, tf2 can broadcast static transforms that do not change over time. This mainly saves storage and lookup time, but also reduces the publishing overhead. You should note that static transforms are published once and assumed to not change, so no history is stored. If you want to define static transforms in your tf2 tree, take a look at the \"Writing a static broadcaster\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial."
msgstr "In addition to that, tf2 can broadcast static transforms that do not change over time. This mainly saves storage and lookup time, but also reduces the publishing overhead. You should note that static transforms are published once and assumed to not change, so no history is stored. If you want to define static transforms in your tf2 tree, take a look at the \"Writing a static broadcaster\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial."


#: ../../source/Concepts/About-Tf2.rst:55
msgid "You can also learn how to add fixed and dynamic frames to your tf2 tree in the \"Adding a frame\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial."
msgstr "You can also learn how to add fixed and dynamic frames to your tf2 tree in the \"Adding a frame\" :doc:`(Python) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial."


#: ../../source/Concepts/About-Tf2.rst:57
msgid "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time :doc:`(Python) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2."
msgstr "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial :doc:`(Python) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time :doc:`(Python) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Py>` :doc:`(C++) <../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2."


#: ../../source/Concepts/About-Tf2.rst:62
msgid "Paper"
msgstr "Paper"


#: ../../source/Concepts/About-Tf2.rst:64
msgid "There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_."
msgstr "There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_."


#: ../../source/Concepts/About-Topic-Statistics.rst:8
msgid "About topic statistics"
msgstr "About topic statistics"


#: ../../source/Concepts/About-Topic-Statistics.rst:16
msgid "ROS 2 provides integrated measurement of statistics for messages received by any subscription. Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues."
msgstr "ROS 2 provides integrated measurement of statistics for messages received by any subscription. Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues."


#: ../../source/Concepts/About-Topic-Statistics.rst:21
msgid "The measurements provided are the received message age and received message period. For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count. These statistics are calculated in a moving window."
msgstr "The measurements provided are the received message age and received message period. For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count. These statistics are calculated in a moving window."


#: ../../source/Concepts/About-Topic-Statistics.rst:26
msgid "How statistics are calculated"
msgstr "How statistics are calculated"


#: ../../source/Concepts/About-Topic-Statistics.rst:28
msgid "Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package. When a new message is received by a subscription, this is a new sample for calculation in the current measurement window. The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__. The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__."
msgstr "Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package. When a new message is received by a subscription, this is a new sample for calculation in the current measurement window. The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__. The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__."


#: ../../source/Concepts/About-Topic-Statistics.rst:41
msgid "Types of statistics calculated"
msgstr "Types of statistics calculated"


#: ../../source/Concepts/About-Topic-Statistics.rst:43
msgid "Received message period"
msgstr "Received message period"


#: ../../source/Concepts/About-Topic-Statistics.rst:45 ../../source/Concepts/About-Topic-Statistics.rst:50
msgid "Units: milliseconds"
msgstr "Units: milliseconds"


#: ../../source/Concepts/About-Topic-Statistics.rst:46
msgid "Uses the system clock to measure the period between received messages"
msgstr "Uses the system clock to measure the period between received messages"


#: ../../source/Concepts/About-Topic-Statistics.rst:48
msgid "Received message age"
msgstr "Received message age"


#: ../../source/Concepts/About-Topic-Statistics.rst:51
msgid "Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher"
msgstr "Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher"


#: ../../source/Concepts/About-Topic-Statistics.rst:54
msgid "Behavior"
msgstr "Behavior"


#: ../../source/Concepts/About-Topic-Statistics.rst:56
msgid "By default, Topic Statistics measurements are not enabled. After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription."
msgstr "By default, Topic Statistics measurements are not enabled. After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription."


#: ../../source/Concepts/About-Topic-Statistics.rst:60
msgid "The data is published as a `statistics_msg/msg/MetricsMessage <https://github.com/ros2/rcl_interfaces/blob/humble/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``). Note that the publishing period also serves as the sample collection window period."
msgstr "The data is published as a `statistics_msg/msg/MetricsMessage <https://github.com/ros2/rcl_interfaces/blob/humble/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``). Note that the publishing period also serves as the sample collection window period."


#: ../../source/Concepts/About-Topic-Statistics.rst:65
msgid "Since received message period requires a message timestamp in a header field, empty data is published. That is, all statistics values are NaN if no timestamp is found. Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made."
msgstr "Since received message period requires a message timestamp in a header field, empty data is published. That is, all statistics values are NaN if no timestamp is found. Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made."


#: ../../source/Concepts/About-Topic-Statistics.rst:70
msgid "The first sample of each window for the received message period statistic does not yield a measurement. This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements."
msgstr "The first sample of each window for the received message period statistic does not yield a measurement. This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements."


#: ../../source/Concepts/About-Topic-Statistics.rst:77
msgid "Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side. Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided."
msgstr "Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side. Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided."


#: ../../source/Concepts/About-Topic-Statistics.rst:82
msgid "Support"
msgstr "Support"


#: ../../source/Concepts/About-Topic-Statistics.rst:84
msgid "This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp). Future work and improvements, such as Python support, can be found `here <https://github.com/ros2/ros2/issues/917>`__."
msgstr "This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp). Future work and improvements, such as Python support, can be found `here <https://github.com/ros2/ros2/issues/917>`__."

