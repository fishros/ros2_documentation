# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Open Robotics
# This file is distributed under the same license as the ROS 2 Documentation: Humble package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 Documentation: Humble \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-04 14:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh\n"
"Language-Team: zh <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/Concepts.rst:2
msgid "Concepts"
msgstr ""

#: ../../source/Concepts.rst:4
msgid "Conceptual overviews provide relatively high-level, general background information about key aspects of ROS 2."
msgstr ""

#: ../../source/Concepts.rst:15
msgid "Related Content"
msgstr ""

#: ../../source/Concepts.rst:17
msgid ":doc:`See the ROS 2 citations <Citations>` for more explanation of concepts and citable resources."
msgstr ""

#: ../../source/Concepts.rst:19
msgid "For a brief video introduction to ROS 2, see this community contributed content:"
msgstr ""

#: ../../source/Concepts.rst:21
msgid "`Getting started with ROS Part 1: Nodes, Parameters and Topics <https://youtu.be/46TPAKXBOF8>`_"
msgstr ""

#: ../../source/Concepts.rst:22
msgid "`Getting started with ROS Part 2: Services and Actions <https://youtu.be/keZAJ83eEoM>`_"
msgstr ""

#: ../../source/Concepts/Advanced.rst:2
msgid "Advanced Concepts"
msgstr ""

#: ../../source/Concepts/Advanced.rst:4
msgid "These conceptual documents are intended for developers who plan to modify or contribute to the ROS 2 core."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:6
msgid "The build system"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:9 ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:9 ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:9 ../../source/Concepts/Basic/About-Actions.rst:5 ../../source/Concepts/Basic/About-Client-Libraries.rst:12 ../../source/Concepts/Basic/About-Command-Line-Tools.rst:11 ../../source/Concepts/Basic/About-Interfaces.rst:10 ../../source/Concepts/Basic/About-Parameters.rst:10 ../../source/Concepts/Basic/About-Services.rst:5 ../../source/Concepts/Basic/About-Topics.rst:5 ../../source/Concepts/Intermediate/About-Composition.rst:9 ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:9 ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:10 ../../source/Concepts/Intermediate/About-Domain-ID.rst:9 ../../source/Concepts/Intermediate/About-Executors.rst:9 ../../source/Concepts/Intermediate/About-Logging.rst:10 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:10 ../../source/Concepts/Intermediate/About-RQt.rst:11 ../../source/Concepts/Intermediate/About-Security.rst:9 ../../source/Concepts/Intermediate/About-Tf2.rst:9 ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:10
msgid "Table of Contents"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:13
msgid "The build system is what allows developers to build their ROS 2 code as needed. ROS 2 relies heavily on the division of code into packages, with each package containing a manifest file (``package.xml``). This manifest file contains essential metadata about the package, including its dependencies on other packages. This manifest is required for the meta-build tool to function."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:18
msgid "The ROS 2 build system consists of 3 major concepts."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:21
msgid "Build tool"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:23
msgid "This is the software that controls the compilation and testing of a single package. In ROS 2 this is usually CMake for C++, and setuptools for Python, but other build tools are supported."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:27
msgid "Build helpers"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:29
msgid "These are helper functions that hook into the build tool to developer experience. ROS 2 packages typically rely on the ``ament`` series of packages for this. ``ament`` consists of a few important repositories which are all in the `GitHub organization <https://github.com/ament>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:34
msgid "The ``ament_package`` package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:36
msgid "Located on |GitHub|_ at `ament/ament_package <https://github.com/ament/ament_package>`_, this repository contains a single :term:`ament Python package` that provides various utilities for |ament packages|, e.g. templates for environment hooks."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:38
msgid "All |ament packages| must contain a single :term:`package.xml` file at the root of the package regardless of their underlying build system. The :term:`package.xml` \"manifest\" file contains information that is required in order to process and operate on a |package|. This |package| information includes things like the |package|'s name, which is globally unique, and the package's dependencies. The :term:`package.xml` file also serves as the marker file which indicates the location of the |package| on the file system."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:43
msgid "Parsing of the :term:`package.xml` files is provided by ``catkin_pkg`` (as in ROS 1), while functionality to locate |packages| by searching the file system for these :term:`package.xml` files is provided by build tools such as ``colcon``."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:46
msgid "package.xml"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:48
msgid "Package manifest file which marks the root of a :term:`package` and contains meta information about the :term:`package` including its name, version, description, maintainer, license, dependencies, and more. The contents of the manifest are in machine readable XML format and the contents are described in the |REPs| `127 <http://www.ros.org/reps/rep-0127.html>`_ and `140 <http://www.ros.org/reps/rep-0140.html>`_, with the possibility of further modifications in future |REPs|."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:51
msgid "So anytime some |package| is referred to as an :term:`ament package`, it means that it is a single unit of software (source code, build files, tests, documentation, and other resources) which is described using a :term:`package.xml` manifest file."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:54
msgid "ament package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:56
msgid "Any |package| which contains a :term:`package.xml` and follows the packaging guidelines of ``ament``, regardless of the underlying build system."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:58
msgid "Since the term :term:`ament package` is build system agnostic, there can be different kinds of |ament packages|, e.g. :term:`ament CMake package`, :term:`ament Python package`, etc."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:60
msgid "Here is a list of common package types that you might run into in this software stack:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:63
msgid "CMake package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:65
msgid "Any |package| containing a plain CMake project and a :term:`package.xml` manifest file."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:66
msgid "ament CMake package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:68
msgid "A :term:`CMake package` that also follows the ``ament`` packaging guidelines."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:69
msgid "Python package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:71
msgid "Any |package| containing a `setuptools <https://pypi.org/project/setuptools/>`_ based Python project and a :term:`package.xml` manifest file."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:72
msgid "ament Python package"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:74
msgid "A :term:`Python package` that also follows the ``ament`` packaging guidelines."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:77
msgid "The ``ament_cmake`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:79
msgid "Located on |GitHub|_ at `ament/ament_cmake <https://github.com/ament/ament_cmake>`_, this repository contains many \"ament CMake\" and pure CMake packages which provide the infrastructure in CMake that is required to create \"ament CMake\" packages. In this context \"ament CMake\" packages means: ``ament`` packages that are built using CMake. So the |packages| in this repository provide the necessary CMake functions/macros and CMake Modules to facilitate creating more \"ament CMake\" (or ``ament_cmake``) packages. Packages of this type are identified with the ``<build_type>ament_cmake</build_type>`` tag in the ``<export>`` tag of the :term:`package.xml` file."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:84
msgid "The |packages| in this repository are extremely modular, but there is a single \"bottleneck\" |package| called ``ament_cmake``. Anyone can depend on the ``ament_cmake`` |package| to get all of the aggregate functionality of the |packages| in this repository. Here a list of the |packages| in the repository along with a short description:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:88
msgid "``ament_cmake``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:90
msgid "aggregates all other |packages| in this repository, users need only to depend on this"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:92
msgid "``ament_cmake_auto``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:94
msgid "provides convenience CMake functions which automatically handle a lot of the tedious parts of writing a |package|'s ``CMakeLists.txt`` file"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:96
msgid "``ament_cmake_core``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:98
msgid "provides all built-in core concepts for ``ament``, e.g. environment hooks, resource indexing, symbolic linking install and others"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:100
msgid "``ament_cmake_gmock``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:102
msgid "adds convenience functions for making gmock based unit tests"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:104
msgid "``ament_cmake_gtest``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:106
msgid "adds convenience functions for making gtest based automated tests"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:108
msgid "``ament_cmake_nose``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:110
msgid "adds convenience functions for making nosetests based python automated tests"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:112
msgid "``ament_cmake_python``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:114
msgid "provides CMake functions for |packages| that contain Python code"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:115
msgid "see the :doc:`ament_cmake_python user documentation <../../How-To-Guides/Ament-CMake-Python-Documentation>`"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:117
msgid "``ament_cmake_test``"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:119
msgid "aggregates different kinds of tests, e.g. gtest and nosetests, under a single target using `CTest <https://cmake.org/Wiki/CMake/Testing_With_CTest>`_"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:121
msgid "The ``ament_cmake_core`` |package| contains a lot of the CMake infrastructure that makes it possible to cleanly pass information between |packages| using conventional interfaces. This makes the |packages| have more decoupled build interfaces with other |packages|, promoting their reuse and encouraging conventions in the build systems of different |packages|. For instance, it provides a standard way to pass include directories, libraries, definitions, and dependencies between |packages| so that consumers of this information can access this information in a conventional way."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:125
msgid "The ``ament_cmake_core`` |package| also provides features of the ``ament`` build system like symbolic link installation, which allows you to symbolically link files from either the source space or the build space into the install space rather than copying them. This allows you to install once and then edit non-generated resources like Python code and configuration files without having to rerun the install step for them to take effect. This feature essentially replaces the \"devel space\" from ``catkin`` because it has most of the advantages with few of the complications or drawbacks."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:129
msgid "Another feature provided by ``ament_cmake_core`` is the |package| resource indexing which is a way for |packages| to indicate that they contain a resource of some type. The design of this feature makes it much more efficient to answer simple questions like what |packages| are in this prefix (e.g. ``/usr/local``) because it only requires that you list the files in a single possible location under that prefix. You can read more about this feature in the `design docs <https://github.com/ament/ament_cmake/blob/humble/ament_cmake_core/doc/resource_index.md>`_ for the resource index."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:133
msgid "Like ``catkin``, ``ament_cmake_core`` also provides environment setup files and |package| specific environment hooks. The environment setup files, often named something like ``setup.bash``, are a place for |package| developers to define changes to the environment that are needed to utilize their |package|. The developers are able to do this using an \"environment hook\" which is basically an arbitrary bit of shell code that can set or modify environment variables, define shell functions, setup auto-completion rules, etc... This feature is how, for example, ROS 1 set the ``ROS_DISTRO`` environment variable without ``catkin`` knowing anything about the ROS distribution."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:139
msgid "The ``ament_lint`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:141
msgid "Located on |GitHub|_ at `ament/ament_lint <https://github.com/ament/ament_lint>`_, this repository provides several |packages| which provide linting and testing services in a convenient and consistent manner. Currently there are |packages| to support C++ style linting using ``uncrustify``, static C++ code checks using ``cppcheck``, checking for copyright in source code, Python style linting using ``pep8``, and other things. The list of helper packages will likely grow in the future."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:146
msgid "Meta-build tool"
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:148
msgid "This is a piece of software that knows how to topologically order a group of packages, and build or test them in the correct dependency order. This software will call into the Build Tool to do the actual work of compiling, testing, and installing the package."
msgstr ""

#: ../../source/Concepts/Advanced/About-Build-System.rst:151
msgid "In ROS 2, the tool named `colcon <https://colcon.readthedocs.io/en/released/>`__ is used for this."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:6
msgid "Internal ROS 2 interfaces"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:13
msgid "The internal ROS interfaces are public C |APIs| that are intended for use by developers who are creating |client libraries| or adding a new underlying middleware, but are not intended for use by typical ROS users. The ROS |client libraries| provide the user facing |APIs| that most ROS users are familiar with, and may come in a variety of programming languages."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:17
msgid "Internal API Architecture Overview"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:19
msgid "There are two main internal interfaces:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:21
msgid "the ROS middleware interface (``rmw`` |API|)"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:22
msgid "the ROS client library interface (``rcl`` |API|)"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:24
msgid "The ``rmw`` |API| is the interface between the ROS 2 software stack and the underlying middleware implementation. The underlying middleware used for ROS 2 is either a DDS or RTPS implementation, and is responsible for discovery, publish and subscribe mechanics, request-reply mechanics for services, and serialization of message types."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:27
msgid "The ``rcl`` |API| is a slightly higher level |API| which is used to implement the |client libraries| and does not touch the middleware implementation directly, but rather does so through the ROS middleware interface (``rmw`` |API|) abstraction."
msgstr ""

msgid "ros2 software stack"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:32
msgid "As the diagram shows, these |APIs| are stacked such that the typical ROS user will use the |client library| |API|, e.g. ``rclcpp``, to implement their code (executable or library). The implementation of the |client libraries|, e.g. ``rclcpp``, use the ``rcl`` interface which provides access to the ROS graph and graph events. The ``rcl`` implementation in turn uses the ``rmw`` |API| to access the ROS graph. The purpose of the ``rcl`` implementation is to provide a common implementation for more complex ROS concepts and utilities that may be used by various |client libraries|, while remaining agnostic to the underlying middleware being used. The purpose of the ``rmw`` interface is to capture the absolute minimum middleware functionality needed to support ROS's client libraries. Finally, the implementation of the ``rmw`` |API| is provided by a middleware implementation specific |package|, e.g. ``rmw_fastrtps_cpp``, the library of which is compiled against vendor specific DDS interfaces and types."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:39
msgid "In the diagram above there is also a box labeled ``ros_to_dds``, and the purpose of this box is to represent a category of possible packages which allow the user to access DDS vendor specific objects and settings using the ROS equivalents. One of the goals of this abstraction interface is to completely insulate the ROS user space code from the middleware being used, so that changing DDS vendors or even middleware technology has a minimal impact on the users code. However, we recognize that on occasion it is useful to reach into the implementation and manually adjust settings despite the consequences that might have. By requiring the use of one of these packages in order to access the underlying DDS vendor's objects, we can avoid exposing vendor specific symbols and headers in the normal interface. It also makes it easy to see what code is potentially violating the vendor portability by inspecting the package's dependencies to see if one of these ``ros_to_dds`` packages are being used."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:48
msgid "Type Specific Interfaces"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:50
msgid "All along the way there are some parts of the |APIs| that are necessarily specific to the message types being exchanged, e.g. publishing a message or subscribing to a topic, and therefore require generated code for each message type. The following diagram layouts the path from user defined ``rosidl`` files, e.g. ``.msg`` files, to the type specific code used by the user and system to perform type specific functions:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:56
msgid "ros2 idl static type support stack"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:56
msgid "Figure: flow chart of \"static\" type support generation, from ``rosidl`` files to user facing code."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:58
msgid "The right hand side of the diagram shows how the ``.msg`` files are passed directly to language specific code generators, e.g. ``rosidl_generator_cpp`` or ``rosidl_generator_py``. These generators are responsible for creating the code that the user will include (or import) and use as the in-memory representation of the messages that were defined in the ``.msg`` files. For example, consider the message ``std_msgs/String``, a user might use this file in C++ with the statement ``#include <std_msgs/msg/string.hpp>``, or they might use the statement ``from std_msgs.msg import String`` in Python. These statements work because of the files generated by these language specific (but middleware agnostic) generator packages."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:63
msgid "Separately, the ``.msg`` files are used to generate type support code for each type. In this context, type support means: meta data or functions that are specific to a given type and that are used by the system to perform particular tasks for the given type. The type support for a given message might include things like a list of the names and types for each field in the message. It might also contain a reference to code that can perform particular tasks for that type, e.g. publish a message."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:69
msgid "Static Type Support"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:71
msgid "When the type support references code to do particular functions for a specific message type, that code sometimes needs to do middleware specific work. For example, consider the type specific publish function, when using \"vendor A\" the function will need to call some of \"vendor A\"'s |API|, but when using \"vendor B\" it will need to call \"vendor B\"'s |API|. To allow for middleware vendor specific code, the user defined ``.msg`` files may result in the generation of vendor specific code. This vendor specific code is still hidden from the user through the type support abstraction, which is similar to how the \"Private Implementation\" (or Pimpl) pattern works."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:77
msgid "Static Type Support with DDS"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:79
msgid "For middleware vendors based on DDS, and specifically those which generate code based on the OMG IDL files (``.idl`` files), the user defined ``rosidl`` files (``.msg`` files) are converted into equivalent OMG IDL files (``.idl`` files). From these OMG IDL files, vendor specific code is created and then used within the type specific functions which are referenced by the type support for a given type. The above diagram shows this on the left hand side, where the ``.msg`` files are consumed by the ``rosidl_dds`` package to produce ``.idl`` files, and then those ``.idl`` files are given to language specific and DDS vendor specific type support generation packages."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:83
msgid "For example, consider the Fast DDS implementation, which has a package called ``rosidl_typesupport_fastrtps_cpp``. This package is responsible for generating code to handle things like converting a C++ message object into a serialized octet buffer to be written over the network. This code, while specific to Fast DDS, is still not exposed to the user because of the abstraction in the type support code."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:88
msgid "Dynamic Type Support"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:90
msgid "Another way to implement type support is to have generic functions for things like publishing to a topic, rather than generating a version of the function for each message type. In order to accomplish this, this generic function needs some meta information about the message type being published, things like a list of field names and types in the order in which they appear in the message type. Then to publish a message, you call a generic publish function and pass a message to be published along with a structure which contains the necessary meta data about the message type. This is referred to as \"dynamic\" type support, as opposed to \"static\" type support which requires generated versions of a function for each type."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:98
msgid "ros2 idl dynamic type support stack"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:98
msgid "Figure: flow chart of \"dynamic\" type support generation, from ``rosidl`` files to user facing code."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:100
msgid "The above diagram shows the flow from user defined ``rosidl`` files to generated user facing code. It is very similar to the diagram for static type support, and differs only in how the type support is generated which is represented by the left hand side of the diagram. In dynamic type support the ``.msg`` files are converted directly into user facing code."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:104
msgid "This code is also middleware agnostic, because it only contains meta information about the messages. The function to actually do the work, e.g. publishing to a topic, is generic to the message type and will make any necessary calls to the middleware specific |APIs|. Note that rather than dds vendor specific packages providing the type support code, which is the case in static type support, this method has middleware agnostic package for each language, e.g. ``rosidl_typesupport_introspection_c`` and ``rosidl_typesupport_introspection_cpp``. The ``introspection`` part of the package name refers to the ability to introspect any message instance with the generated meta data for the message type. This is the fundamental capability that allows for generic implementations of functions like \"publish to a topic\"."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:110
msgid "This approach has the advantage that all generated code is middleware agnostic, which means it can be reused for different middleware implementations, so long as they allow for dynamic type support. It also results in less generated code, which reduces compile time and code size."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:113
msgid "However, dynamic type support requires that the underlying middleware support a similar form of dynamic type support. In the case of DDS the DDS-XTypes standard allows for publishing of messages using meta information rather than generated code. DDS-XTypes, or something like it, is required in the underlying middleware in order to support dynamic type support. Also, this approach to type support is normally slower than the static type support alternative. The type specific generated code in static type support can be written to be more efficient as it does not need to iterate over the message type's meta data to perform things like serialization."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:120
msgid "The ``rcl`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:122
msgid "The ROS Client Library interface (``rcl`` |API|) can be used by |client libraries| (e.g. ``rclc``, ``rclcpp``, ``rclpy``, etc.) in order to avoid duplicating logic and features. By reusing the ``rcl`` |API|, client libraries can be smaller and more consistent with each other. Some parts of the client library are intentionally left out of the ``rcl`` |API| because the language idiomatic method should be used to implement those parts of the system. A good example of this is the execution model, which ``rcl`` does not address at all. Instead the client library should provide a language idiomatic solution like ``pthreads`` in C, ``std::thread`` in C++11, and ``threading.Thread`` in Python. Generally the ``rcl`` interface provides functions that are not specific to a language pattern and are not specific to a particular message type."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:129
msgid "The ``rcl`` |API| is located in the `ros2/rcl <https://github.com/ros2/rcl>`_ repository on |GitHub|_ and contains the interface as C headers. The ``rcl`` C implementation is provided by the ``rcl`` |package| in the same repository. This implementation avoids direct contact with the middleware by instead using the ``rmw`` and ``rosidl`` |APIs|."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:133
msgid "For a complete definition of the ``rcl`` |API|, see `the rcl docs <http://docs.ros.org/en/humble/p/rcl/>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:136
msgid "The ``rmw`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:138
msgid "The ROS middleware interface (``rmw`` |API|) is the minimal set of primitive middleware capabilities needed to build ROS on top. Providers of different middleware implementations must implement this interface in order to support the entire ROS stack on top. Currently all of the middleware implementations are for different DDS vendors."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:142
msgid "The ``rmw`` |API| is located in the `ros2/rmw <https://github.com/ros2/rmw>`_ repository. The ``rmw`` |package| contains the C headers which define the interface, the implementation of which is provided by the various |packages| of rmw implementations for different DDS vendors."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:145
msgid "For a definition of the ``rmw`` |API|, see `the rmw docs <http://docs.ros.org/en/humble/p/rmw/>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:149
msgid "The ``rosidl`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:151
msgid "The ``rosidl`` |API| consists of a few message related static functions and types along with a definition of what code should be generated by messages in different languages. The generated message code specified in the |API| will be language specific, but may or may not reuse generated code for other languages. The generated message code specified in the |API| contains things like the message data structure, functions for construction, destruction, etc. The |API| will also implement a way to get the type support structure for the message type, which is used when publishing or subscribing to a topic of that message type."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:156
msgid "There are several repositories that play a role in the ``rosidl`` |API| and implementation."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:158
msgid "The ``rosidl`` repository, located on |GitHub|_ at `ros2/rosidl <https://github.com/ros2/rosidl>`_, defines the message IDL syntax, i.e. syntax of ``.msg`` files, ``.srv`` files, etc., and contains |packages| for parsing the files, for providing CMake infrastructure to generate code from the messages, for generating implementation agnostic code (headers and source files), and for establishing the default set of generators. The repository contains these |packages|:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:161
msgid "``rosidl_cmake``: provides CMake functions and modules for generating code from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:162
msgid "``rosidl_default_generators``: defines the list of default generators which ensures that they are installed as dependencies, but other injected generators can also be used."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:163
msgid "``rosidl_generator_c``: provides tools to generate C header files (``.h``) for ``rosidl`` files."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:164
msgid "``rosidl_generator_cpp``: provides tools to generate C++ header files (``.hpp``) for ``rosidl`` files."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:165
msgid "``rosidl_generator_py``: provides tools to generate Python modules for ``rosidl`` files."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:166
msgid "``rosidl_parser``: provides Python |API| for parsing ``rosidl`` files."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:168
msgid "Generators for other languages, e.g. ``rosidl_generator_java``, are hosted externally (in different repositories) but would use the same mechanism that the above generators use to \"register\" themselves as a ``rosidl`` generator."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:170
msgid "In addition to the aforementioned |packages| for parsing and generating headers for the ``rosidl`` files, the ``rosidl`` repository also contains |packages| concerned with \"type support\" for the message types defined in the files. Type support refers to the ability to interpret and manipulate the information represented by ROS message instances of particular types (publishing the messages, for example). Type support can either be provided by code that is generated at compile time or it can be done programmatically based on the contents of the ``rosidl`` file, e.g. the ``.msg`` or ``.srv`` file, and the data received, by introspecting the data. In the case of the latter, where type support is done through runtime interpretation of the messages, the message code generated by ROS 2 can be agnostic to the rmw implementation. The packages that provide this type support through introspection of the data are:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:176
msgid "``rosidl_typesupport_introspection_c``: provides tools for generating C code for supporting ``rosidl`` message data types."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:177
msgid "``rosidl_typesupport_introspection_cpp``: provides tools for generating C++ code for supporting ``rosidl`` message data types."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:179
msgid "In the case where type support is to be generated at compile time instead of being generated programmatically, a package specific to the rmw implementation will need to be used. This is because typically a particular rmw implementation will require data to be stored and manipulated in a manner that is specific to the DDS vendor in order for the DDS implementation to make use of it. See the :ref:`Type Specific Interfaces` section above for more details."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:183
msgid "For more information on what exactly is in the ``rosidl`` |API| (static and generated) see this page:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:186
msgid "The ``rcutils`` repository"
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:188
msgid "ROS 2 C Utilities (``rcutils``) is a C |API| composed of macros, functions, and data structures used throughout the ROS 2 codebase. These are mainly used for error handling, commandline argument parsing, and logging which are not specific to the client or middleware layers and can be shared by both."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:191
msgid "The ``rcutils`` |API| and implementation are located in the `ros2/rcutils <https://github.com/ros2/rcutils>`_ repository on |GitHub|_ which contains the interface as C headers."
msgstr ""

#: ../../source/Concepts/Advanced/About-Internal-Interfaces.rst:193
msgid "For a complete definition of the ``rcutils`` |API|, see `the rcutils docs <https://docs.ros.org/en/humble/p/rcutils/>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:6
msgid "ROS 2 middleware implementations"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:13
msgid "ROS middleware implementations are sets of |packages| that implement some of the internal ROS interfaces, e.g. the ``rmw``, ``rcl``, and ``rosidl`` |APIs|."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:16
msgid "Common Packages for DDS Middleware Packages"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:18
msgid "All of the current ROS middleware implementations are based on full or partial DDS implementations. For example, there is a middleware implementation that uses RTI's Connext DDS and an implementation which uses eProsima's Fast DDS. Because of this, there are some shared |packages| amongst most DDS based middleware implementations."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:22
msgid "In the `ros2/rosidl_dds <https://github.com/ros2/rosidl_dds>`_ repository on |GitHub|_, there is the following |package|:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:24
msgid "``rosidl_generator_dds_idl``: provides tools to generate DDS ``.idl`` files from ``rosidl`` files, e.g. ``.msg`` files, ``.srv`` files, etc."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:26
msgid "The ``rosidl_generator_dds_idl`` |package| generates a DDS ``.idl`` file for each ``rosidl`` file, e.g. ``.msg`` file, defined by |packages| containing messages. Currently DDS based ROS middleware implementations make use of this generator's output ``.idl`` files to generate pre-compiled type support that is vendor specific."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:30
msgid "Structure of ROS Middleware Implementations"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:32
msgid "A ROS middleware implementation is typically made up of a few |packages| in a single repository:"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:34
msgid "``<implementation_name>_cmake_module``: contains CMake Module for discovering and exposing required dependencies"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:35
msgid "``rmw_<implementation_name>_<language>``: contains the implementation of the ``rmw`` |API| in a particular language, typically C++"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:36
msgid "``rosidl_typesupport_<implementation_name>_<language>``: contains tools to generate static type support code for ``rosidl`` files, tailored to the implementation in a particular language, typically C or C++"
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:38
msgid "The ``<implementation_name>_cmake_module`` |package| contains any CMake Modules and functions needed to find the supporting dependencies for the middleware implementation. For example, ``rti_connext_dds_cmake_module`` provides wrapper logic around the CMake Module shipped with RTI Connext DDS to make sure that all packages that depend on it will select the same installation of RTI Connext DDS. Similarly, ``fastrtps_cmake_module`` includes a CMake Module to find eProsima's Fast DDS and ``gurumdds_cmake_module`` includes a CMake Module to find GurumNetworks GurumDDS. Not all implementations will have a package like this: for example, Eclipe's Cyclone DDS already provides a CMake Module which is used directly by its RMW implementation without the need of additional wrappers."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:43
msgid "The ``rmw_<implementation_name>_<language>`` |package| implements the ``rmw`` C |API| in a particular language. The implementation itself can be C++, it just must expose the header's symbols as ``extern \"C\"`` so that C applications can link against it."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:46
msgid "The ``rosidl_typesupport_<implementation_name>_<language>`` |package| provides a generator which generates DDS code in a particular language. This is done using the ``.idl`` files generated by the ``rosidl_generator_dds_idl`` |package| and the DDS IDL code generator provided by the DDS vendor. It also generates code for converting ROS message structures to and from DDS message structures. This generator is also responsible for creating a shared library for the message package it is being used in, which is specific to the messages in the message package and to the DDS vendor being used."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:51
msgid "As mentioned above, the ``rosidl_typesupport_introspection_<language>`` may be used instead of a vendor specific type support package if an rmw implementation supports runtime interpretation of messages. This ability to programmatically send and receive types over topics without generating code beforehand is achieved by supporting the `DDS X-Types Dynamic Data standard <http://www.omg.org/spec/DDS-XTypes>`_. As such, rmw implementations may provide support for the X-Types standard, and/or provide a package for type support generated at compile time specific to their DDS implementation."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:55
msgid "As an example of an rmw implementation repository, the ``Eclipse Cyclone DDS`` ROS middleware implementation is on |GitHub|_ at `ros2/rmw_cyclonedds <https://github.com/ros2/rmw_cyclonedds>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:57
msgid "The rmw implementation for ``Fast DDS`` is on |GitHub|_ at `ros2/rmw_fastrtps_cpp <https://github.com/ros2/rmw_fastrtps_cpp>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:59
msgid "The rmw implementation for ``Connext DDS`` is on |GitHub|_ at `ros2/rmw_connextdds <https://github.com/ros2/rmw_connextdds>`_."
msgstr ""

#: ../../source/Concepts/Advanced/About-Middleware-Implementations.rst:61
msgid "The rmw implementation for ``GurumDDS`` is on |GitHub|_ at `ros/rmw_gurumdds <https://github.com/ros2/rmw_gurumdds>`_."
msgstr ""

#: ../../source/Concepts/Basic.rst:2
msgid "Basic Concepts"
msgstr ""

#: ../../source/Concepts/Basic.rst:4
msgid "ROS 2 is a middleware based on a strongly-typed, anonymous publish/subscribe mechanism that allows for message passing between different processes."
msgstr ""

#: ../../source/Concepts/Basic.rst:6
msgid "At the heart of any ROS 2 system is the ROS graph. The ROS graph refers to the network of nodes in a ROS system and the connections between them by which they communicate."
msgstr ""

#: ../../source/Concepts/Basic.rst:9
msgid "These are the concepts that will help you get started understanding the basics of ROS 2."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:2 ../../source/Concepts/Basic/About-Interfaces.rst:269
msgid "Actions"
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:7
msgid "In ROS 2, an action refers to a long-running remote procedure call with feedback and the ability to cancel or preempt the goal. For instance, the high-level state machine running a robot may call an action to tell the navigation subsystem to travel to a waypoint, which may take several seconds (or minutes) to do. Along the way, the navigation subsystem can provide feedback on how far along it is, and the high-level state machine has the option to cancel or preempt the travel to that waypoint."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:11
msgid "This structure is reflected in how an action message definition looks:"
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:21
msgid "In ROS 2, actions are expected to be long running procedures, as there is overhead in setting up and monitoring the connection. If you need a short running remote procedure call, consider using a :doc:`service <About-Services>` instead."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:24
msgid "Actions are identified by an action name, which looks much like a topic name (but is in a different namespace)."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:26
msgid "An action consists of two parts: the action server and the action client."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:29
msgid "Action server"
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:31
msgid "The action server is the entity that will accept the remote procedure request and perform some procedure on it. It is also responsible for sending out feedback as the action progresses and should react to cancellation/preemption requests. For instance, consider an action to calculate the Fibonacci sequence with the following interface:"
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:43
msgid "The action server is the entity that receives this message, starts calculating the sequence up to ``order`` (providing feedback along the way), and finally returns a full result in ``sequence``."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:47
msgid "There should only ever be one action server per action name. It is undefined which action server will receive client requests in the case of multiple action servers on the same action name."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:51
msgid "Action client"
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:53
msgid "An action client is an entity that will request a remote action server to perform a procedure on its behalf. Following the example above, the action client is the entity that creates the initial message containing the ``order``, and waits for the action server to compute the sequence and return it (with feedback along the way)."
msgstr ""

#: ../../source/Concepts/Basic/About-Actions.rst:56
msgid "Unlike the action server, there can be arbitrary numbers of action clients using the same action name."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:9
msgid "Client libraries"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:15 ../../source/Concepts/Basic/About-Parameters.rst:13 ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:12 ../../source/Concepts/Intermediate/About-Domain-ID.rst:12 ../../source/Concepts/Intermediate/About-Executors.rst:12 ../../source/Concepts/Intermediate/About-Logging.rst:13 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:13 ../../source/Concepts/Intermediate/About-RQt.rst:14 ../../source/Concepts/Intermediate/About-Security.rst:12 ../../source/Concepts/Intermediate/About-Tf2.rst:12 ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:13
msgid "Overview"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:17
msgid "Client libraries are the APIs that allow users to implement their ROS 2 code. Using client libraries, users gain access to ROS 2 concepts such as nodes, topics, services, etc. Client libraries come in a variety of programming languages so that users may write ROS 2 code in the language that is best-suited for their application. For example, you might prefer to write visualization tools in Python because it makes prototyping iterations faster, while for parts of your system that are concerned with efficiency, the nodes might be better implemented in C++."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:22
msgid "Nodes written using different client libraries are able to share messages with each other because all client libraries implement code generators that provide users with the capability to interact with ROS 2 interface files in the respective language."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:24
msgid "In addition to the language-specific communication tools, client libraries expose to users the core functionality that makes ROS \"ROS\". For example, here is a list of functionality that can typically be accessed through a client library:"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:27
msgid "Names and namespaces"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:28
msgid "Time (real or simulated)"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:29 ../../source/Concepts/Basic/About-Parameters.rst:7 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:110
msgid "Parameters"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:30
msgid "Console logging"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:31
msgid "Threading model"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:32
msgid "Intra-process communication"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:35
msgid "Supported client libraries"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:37
msgid "The C++ client library (``rclcpp``) and the Python client library (``rclpy``) are both client libraries which utilize common functionality in ``rcl``."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:40
msgid "The ``rclcpp`` package"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:42
msgid "The ROS Client Library for C++ (``rclcpp``) is the user facing, C++ idiomatic interface which provides all of the ROS client functionality like creating nodes, publishers, and subscriptions. ``rclcpp`` builds on top of ``rcl`` and the ``rosidl`` |API|, and it is designed to be used with the C++ messages generated by ``rosidl_generator_cpp``."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:45
msgid "``rclcpp`` makes use of all the features of C++ and C++17 to make the interface as easy to use as possible, but since it reuses the implementation in ``rcl`` it is able maintain a consistent behavior with the other client libraries that use the ``rcl`` |API|."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:47
msgid "The ``rclcpp`` repository is located on GitHub at `ros2/rclcpp <https://github.com/ros2/rclcpp>`_ and contains the |package| ``rclcpp``. The generated |API| documentation is here:"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:50
msgid "`api/rclcpp/index.html <http://docs.ros.org/en/humble/p/rclcpp>`_"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:53
msgid "The ``rclpy`` package"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:55
msgid "The ROS Client Library for Python (``rclpy``) is the Python counterpart to the C++ client library. Like the C++ client library, ``rclpy`` also builds on top of the ``rcl`` C API for its implementation. The interface provides an idiomatic Python experience that uses native Python types and patterns like lists and context objects. By using the ``rcl`` |API| in the implementation, it stays consistent with the other client libraries in terms of feature parity and behavior. In addition to providing Python idiomatic bindings around the ``rcl`` |API| and Python classes for each message, the Python client library takes care of the execution model, using ``threading.Thread`` or similar to run the functions in the ``rcl`` |API|."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:61
msgid "Like C++ it generates custom Python code for each ROS message that the user interacts with, but unlike C++ it eventually converts the native Python message object into the C version of the message. All operations happen on the Python version of the messages until they need to be passed into the ``rcl`` layer, at which point they are converted into the plain C version of the message so it can be passed into the ``rcl`` C |API|. This is avoided if possible when communicating between publishers and subscriptions in the same process to cut down on the conversion into and out of Python."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:65
msgid "The ``rclpy`` repository is located on GitHub at `ros2/rclpy <https://github.com/ros2/rclpy>`_ and contains the |package| ``rclpy``. The generated |API| documentation is here:"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:68
msgid "`api/rclpy/index.html <http://docs.ros2.org/foxy/api/rclpy/index.html>`_"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:72
msgid "Community-maintained"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:74
msgid "While the C++ and Python client libraries are maintained by the core ROS 2 team, members of the ROS 2 community maintain additional client libraries:"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:76
msgid "`C <https://github.com/ros2/rclc>`__  ``rclc`` does not put a layer on top of rcl but complements rcl to make rcl+rclc a feature-complete client library in C. See `micro.ros.org <https://micro.ros.org/>`__ for tutorials."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:77
msgid "`JVM and Android <https://github.com/ros2-java>`__ Java and Android bindings for ROS 2."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:78
msgid "`.NET Core, UWP and C# <https://github.com/esteve/ros2_dotnet>`__ This is a collection of projects (bindings, code generator, examples and more) for writing ROS 2 applications for .NET Core and .NET Standard."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:79
msgid "`Node.js <https://www.npmjs.com/package/rclnodejs>`__ rclnodejs is a Node.js client for ROS 2. It provides a simple and easy JavaScript API for ROS 2 programming."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:80
msgid "`Rust <https://github.com/ros2-rust/ros2_rust>`__ This is a set of projects (the rclrs client library, code generator, examples and more) that enables developers to write ROS 2 applications in Rust."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:82
msgid "Older, unmaintained client libraries are:"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:84
msgid "`Ada <https://github.com/ada-ros/ada4ros2>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:85
msgid "`C# <https://github.com/firesurfer/rclcs>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:86
msgid "`Objective C and iOS <https://github.com/esteve/ros2_objc>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:87
msgid "`Zig <https://github.com/jacobperron/rclzig>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:91
msgid "Common functionality: ``rcl``"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:93
msgid "Most of the functionality found in a client library is not specific to the programming language of the client library. For example, the behavior of parameters and the logic of namespaces should ideally be the same across all programming languages. Because of this, rather than implementing the common functionality from scratch, client libraries make use of a common core ROS Client Library (RCL) interface that implements logic and behavior of ROS concepts that is not language-specific. As a result, client libraries only need to wrap the common functionality in the RCL with foreign function interfaces. This keeps client libraries thinner and easier to develop. For this reason the common RCL functionality is exposed with C interfaces as the C language is typically the easiest language for client libraries to wrap."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:100
msgid "In addition to making the client libraries light-weight, an advantage of having the common core is that the behavior between languages is more consistent. If any changes are made to the logic/behavior of the functionality in the core RCL -- namespaces, for example -- all client libraries that use the RCL will have these changes reflected. Furthermore, having the common core means that maintaining multiple client libraries becomes less work when it comes to bug fixes."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:104
msgid "The API documentation for ``rcl`` can be found `here <https://docs.ros.org/en/humble/p/rcl/>`__."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:107
msgid "Language-specific functionality"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:109
msgid "Client library concepts that require language-specific features/properties are not implemented in the RCL but instead are implemented in each client library. For example, threading models used by “spin” functions will have implementations that are specific to the language of the client library."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:113
msgid "Demo"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:115
#, python-format
msgid "For a walkthrough of the message exchange between a publisher using ``rclpy`` and a subscription using ``rclcpp``\\ , we encourage you to watch `this ROSCon talk <https://vimeo.com/187696091>`__ starting at 17:25 (`see the slides here <https://roscon.ros.org/2016/presentations/ROSCon%202016%20-%20ROS%202%20Update.pdf>`__)."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:118 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:72 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:276 ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:61
msgid "Comparison to ROS 1"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:120
msgid "In ROS 1, all client libraries are developed \"from the ground up\". This allows for the ROS 1 Python client library to be implemented purely in Python, for example, which brings benefits of such as not needing to compile code. However, naming conventions and behaviors are not always consistent between client libraries, bug fixes have to be done in multiple places, and there is a lot of functionality that has only ever been implemented in one client library (e.g. UDPROS)."
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:125
msgid "Summary"
msgstr ""

#: ../../source/Concepts/Basic/About-Client-Libraries.rst:127
msgid "By utilizing the common core ROS client library, client libraries written in a variety of programming languages are easier to write and have more consistent behavior."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:8
msgid "Introspection with command line tools"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:13
msgid "ROS 2 includes a suite of command-line tools for introspecting a ROS 2 system."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:16
msgid "Usage"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:18
msgid "The main entry point for the tools is the command ``ros2``, which itself has various sub-commands for introspecting and working with nodes, topics, services, and more."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:20
msgid "To see all available sub-commands run:"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:26
msgid "Examples of sub-commands that are available include:"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:28
msgid "``action``: Introspect/interact with ROS actions"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:29
msgid "``bag``: Record/play a rosbag"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:30
msgid "``component``: Manage component containers"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:31
msgid "``daemon``: Introspect/configure the ROS 2 daemon"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:32
msgid "``doctor``: Check ROS setup for potential issues"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:33
msgid "``interface``: Show information about ROS interfaces"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:34
msgid "``launch``: Run/introspect a launch file"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:35
msgid "``lifecycle``: Introspect/manage nodes with managed lifecycles"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:36
msgid "``multicast``: Multicast debugging commands"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:37
msgid "``node``: Introspect ROS nodes"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:38
msgid "``param``: Introspect/configure parameters on a node"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:39
msgid "``pkg``: Introspect ROS packages"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:40
msgid "``run``: Run ROS nodes"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:41
msgid "``security``: Configure security settings"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:42
msgid "``service``: Introspect/call ROS services"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:43
msgid "``test``: Run a ROS launch test"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:44
msgid "``topic``: Introspect/publish ROS topics"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:45
msgid "``trace``: Tracing tools to get information on ROS nodes execution (only available on Linux)"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:46
msgid "``wtf``: An alias for ``doctor``"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:49
msgid "Example"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:51
msgid "To produce the typical talker-listener example using command-line tools, the ``topic`` sub-command can be used to publish and echo messages on a topic."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:53
msgid "Publish messages in one terminal with:"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:63
msgid "Echo messages received in another terminal with:"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:73
msgid "Behind the scenes"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:75
msgid "ROS 2 uses a distributed discovery process for nodes to connect to each other. As this process purposefully does not use a centralized discovery mechanism, it can take time for ROS nodes to discover all other participants in the ROS graph. Because of this, there is a long-running daemon in the background that stores information about the ROS graph to provide faster responses to queries, e.g. the list of node names."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:79
msgid "The daemon is automatically started when the relevant command-line tools are used for the first time. You can run ``ros2 daemon --help`` for more options for interacting with the daemon."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:83
msgid "Implementation"
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:85
msgid "The source code for the ``ros2`` command is available at https://github.com/ros2/ros2cli."
msgstr ""

#: ../../source/Concepts/Basic/About-Command-Line-Tools.rst:87
msgid "The ``ros2`` tool has been implemented as a framework that can be extended via plugins. For example, the `sros2 <https://github.com/ros2/sros2>`__ package provides a ``security`` sub-command that is automatically detected by the ``ros2`` tool if the ``sros2`` package is installed."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:2
msgid "Discovery"
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:7
msgid "Discovery of nodes happens automatically through the underlying middleware of ROS 2. It can be summarized as follows:"
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:10
msgid "When a node is started, it advertises its presence to other nodes on the network with the same ROS domain (set with the ROS_DOMAIN_ID environment variable). Nodes respond to this advertisement with information about themselves so that the appropriate connections can be made and the nodes can communicate."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:12
msgid "Nodes periodically advertise their presence so that connections can be made with new-found entities, even after the initial discovery period."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:13
msgid "Nodes advertise to other nodes when they go offline."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:15
msgid "Nodes will only establish connections with other nodes if they have compatible :doc:`Quality of Service <../../Tutorials/Demos/Quality-of-Service>` settings."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:17
msgid "Take the :ref:`talker-listener demo <talker-listener>` for example. Running the C++ talker node in one terminal will publish messages on a topic, and the Python listener node running in another terminal  will subscribe to messages on the same topic."
msgstr ""

#: ../../source/Concepts/Basic/About-Discovery.rst:21
msgid "You should see that these nodes discover each other automatically, and begin to exchange messages."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:7
msgid "Interfaces"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:13
msgid "Background"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:15
msgid "ROS applications typically communicate through interfaces of one of three types: :doc:`topics <About-Topics>`, :doc:`services <About-Services>`, or :doc:`actions <About-Actions>`. ROS 2 uses a simplified description language, the interface definition language (IDL), to describe these interfaces. This description makes it easy for ROS tools to automatically generate source code for the interface type in several target languages."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:19
msgid "In this document we will describe the supported types:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:21
msgid "msg: ``.msg`` files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:22
msgid "srv: ``.srv`` files describe a service. They are composed of two parts: a request and a response. The request and response are message declarations."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:23
msgid "action: ``.action`` files describe actions. They are composed of three parts: a goal, a result, and feedback. Each part is a message declaration itself."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:27
msgid "Messages"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:29
msgid "Messages are a way for a ROS 2 node to send data on the network to other ROS nodes, with no response expected. For instance, if a ROS 2 node reads temperature data from a sensor, it can then publish that data on the ROS 2 network using a ``Temperature`` message. Other nodes on the ROS 2 network can subscribe to that data and receive the ``Temperature`` message."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:33
msgid "Messages are described and defined in ``.msg`` files in the ``msg/`` directory of a ROS package. ``.msg`` files are composed of two parts: fields and constants."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:37
msgid "Fields"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:39
msgid "Each field consists of a type and a name, separated by a space, i.e:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:47 ../../source/Concepts/Basic/About-Interfaces.rst:193 ../../source/Concepts/Basic/About-Interfaces.rst:217
msgid "For example:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:55
msgid "Field types"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:57
msgid "Field types can be:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:59
msgid "a built-in-type"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:60
msgid "names of Message descriptions defined on their own, such as \"geometry_msgs/PoseStamped\""
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:62
msgid "*Built-in-types currently supported:*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:67 ../../source/Concepts/Basic/About-Interfaces.rst:137
msgid "Type name"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:68 ../../source/Concepts/Basic/About-Interfaces.rst:138
msgid "`C++ <https://design.ros2.org/articles/generated_interfaces_cpp.html>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:69 ../../source/Concepts/Basic/About-Interfaces.rst:139
msgid "`Python <https://design.ros2.org/articles/generated_interfaces_python.html>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:70 ../../source/Concepts/Basic/About-Interfaces.rst:140
msgid "`DDS type <https://design.ros2.org/articles/mapping_dds_types.html>`__"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:71 ../../source/Concepts/Basic/About-Interfaces.rst:72
msgid "bool"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:73
msgid "builtins.bool"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:74
msgid "boolean"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:75
msgid "byte"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:76 ../../source/Concepts/Basic/About-Interfaces.rst:96
msgid "uint8_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:77
msgid "builtins.bytes*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:78 ../../source/Concepts/Basic/About-Interfaces.rst:94 ../../source/Concepts/Basic/About-Interfaces.rst:98
msgid "octet"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:79 ../../source/Concepts/Basic/About-Interfaces.rst:80 ../../source/Concepts/Basic/About-Interfaces.rst:82
msgid "char"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:81 ../../source/Concepts/Basic/About-Interfaces.rst:155
msgid "builtins.str*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:83
msgid "float32"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:84 ../../source/Concepts/Basic/About-Interfaces.rst:86
msgid "float"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:85 ../../source/Concepts/Basic/About-Interfaces.rst:89
msgid "builtins.float*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:87
msgid "float64"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:88 ../../source/Concepts/Basic/About-Interfaces.rst:90
msgid "double"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:91
msgid "int8"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:92
msgid "int8_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:93 ../../source/Concepts/Basic/About-Interfaces.rst:97 ../../source/Concepts/Basic/About-Interfaces.rst:101 ../../source/Concepts/Basic/About-Interfaces.rst:105 ../../source/Concepts/Basic/About-Interfaces.rst:109 ../../source/Concepts/Basic/About-Interfaces.rst:113 ../../source/Concepts/Basic/About-Interfaces.rst:117 ../../source/Concepts/Basic/About-Interfaces.rst:121
msgid "builtins.int*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:95
msgid "uint8"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:99
msgid "int16"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:100
msgid "int16_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:102
msgid "short"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:103
msgid "uint16"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:104
msgid "uint16_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:106
msgid "unsigned short"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:107
msgid "int32"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:108
msgid "int32_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:110
msgid "long"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:111
msgid "uint32"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:112
msgid "uint32_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:114
msgid "unsigned long"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:115
msgid "int64"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:116
msgid "int64_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:118
msgid "long long"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:119
msgid "uint64"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:120
msgid "uint64_t"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:122
msgid "unsigned long long"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:123 ../../source/Concepts/Basic/About-Interfaces.rst:126 ../../source/Concepts/Basic/About-Interfaces.rst:156
msgid "string"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:124 ../../source/Concepts/Basic/About-Interfaces.rst:154
msgid "std::string"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:125 ../../source/Concepts/Basic/About-Interfaces.rst:129
msgid "builtins.str"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:127 ../../source/Concepts/Basic/About-Interfaces.rst:130
msgid "wstring"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:128
msgid "std::u16string"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:132
msgid "*Every built-in-type can be used to define arrays:*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:141
msgid "static array"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:142
msgid "std::array<T, N>"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:143 ../../source/Concepts/Basic/About-Interfaces.rst:151
msgid "builtins.list*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:144
msgid "T[N]"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:145
msgid "unbounded dynamic array"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:146
msgid "std::vector"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:147
msgid "builtins.list"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:148
msgid "sequence"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:149
msgid "bounded dynamic array"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:150
msgid "custom_class<T, N>"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:152
msgid "sequence<T, N>"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:153
msgid "bounded string"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:158
msgid "All types that are more permissive than their ROS definition enforce the ROS constraints in range and length by software."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:160
msgid "*Example of message definition using arrays and bounded types:*"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:176
msgid "Field names"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:178
msgid "Field names must be lowercase alphanumeric characters with underscores for separating words. They must start with an alphabetic character, and they must not end with an underscore or have two consecutive underscores."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:182
msgid "Field default value"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:184
msgid "Default values can be set to any field in the message type. Currently default values are not supported for string arrays and complex types (i.e. types not present in the built-in-types table above; that applies to all nested messages)."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:187
msgid "Defining a default value is done by adding a third element to the field definition line, i.e:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:204
msgid "string values must be defined in single ``'`` or double ``\"`` quotes"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:205
msgid "currently string values are not escaped"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:208
msgid "Constants"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:210
msgid "Each constant definition is like a field description with a default value, except that this value can never be changed programatically. This value assignment is indicated by use of an equal '=' sign, e.g."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:228
msgid "Constants names have to be UPPERCASE"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:231 ../../source/Concepts/Basic/About-Services.rst:2 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:98
msgid "Services"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:233
msgid "Services are a request/response communication, where the client (requester) is waiting for the server (responder) to make a short computation and return a result."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:235
msgid "Services are described and defined in ``.srv`` files in the ``srv/`` directory of a ROS package."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:237
msgid "A service description file consists of a request and a response msg type, separated by ``---``. Any two ``.msg`` files concatenated with a ``---`` are a legal service description."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:240
msgid "Here is a very simple example of a service that takes in a string and returns a string:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:248
msgid "We can of course get much more complicated (if you want to refer to a message from the same package you must not mention the package name):"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:266
msgid "You cannot embed another service inside of a service."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:271
msgid "Actions are a long-running request/response communication, where the action client (requester) is waiting for the action server (the responder) to take some action and return a result. In contrast to services, actions can be long-running (many seconds or minutes), provide feedback while they are happening, and can be interrupted."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:274
msgid "Action definitions have the following form:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:284
msgid "Like services, the request fields are before and the response fields are after the first triple-dash (``---``), respectively. There is also a third set of fields after the second triple-dash, which is the fields to be sent when sending feedback."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:287
msgid "There can be arbitrary numbers of request fields (including zero), arbitrary numbers of response fields (including zero), and arbitrary numbers of feedback fields (including zero)."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:289
msgid "The ``<request_type>``, ``<response_type>``, and ``<feedback_type>`` follow all of the same rules as the ``<type>`` for a message. The ``<request_fieldname>``, ``<response_fieldname>``, and ``<feedback_fieldname>`` follow all of the same rules as the ``<fieldname>`` for a message."
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:292
msgid "For instance, the ``Fibonacci`` action definition contains the following:"
msgstr ""

#: ../../source/Concepts/Basic/About-Interfaces.rst:302
msgid "This is an action definition where the action client is sending a single ``int32`` field representing the number of Fibonacci steps to take, and expecting the action server to produce an array of ``int32`` containing the complete steps. Along the way, the action server may also provide an intermediate array of ``int32`` contains the steps accomplished up until a certain point."
msgstr ""

#: ../../source/Concepts/Basic/About-Launch.rst:2
msgid "Launch"
msgstr ""

#: ../../source/Concepts/Basic/About-Launch.rst:7
msgid "A ROS 2 system typically consists of many nodes running across many different processes (and even different machines). While it is possible to run each of these nodes separately, it gets cumbersome quite quickly."
msgstr ""

#: ../../source/Concepts/Basic/About-Launch.rst:10
msgid "The launch system in ROS 2 is meant to automate the running of many nodes with a single command. It helps the user describe the configuration of their system and then executes it as described. The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions which make it easy to reuse components throughout the system by giving them each a different configuration. It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes."
msgstr ""

#: ../../source/Concepts/Basic/About-Launch.rst:15
msgid "All of the above is specified in a launch file, which can be written in Python, XML, or YAML. This launch file can then be run using the ``ros2 launch`` command, and all of the nodes specified will be run."
msgstr ""

#: ../../source/Concepts/Basic/About-Launch.rst:18
msgid "The `design document <https://design.ros2.org/articles/roslaunch.html>`__ details the goal of the design of ROS 2's launch system (not all functionality is currently available)."
msgstr ""

#: ../../source/Concepts/Basic/About-Nodes.rst:2
msgid "Nodes"
msgstr ""

#: ../../source/Concepts/Basic/About-Nodes.rst:7
msgid "A node is a participant in the ROS 2 graph, which uses a :doc:`client library <About-Client-Libraries>` to communicate with other nodes. Nodes can communicate with other nodes within the same process, in a different process, or on a different machine. Nodes are typically the unit of computation in a ROS graph; each node should do one logical thing."
msgstr ""

#: ../../source/Concepts/Basic/About-Nodes.rst:11
msgid "Nodes can :doc:`publish <About-Topics>` to named topics to deliver data to other nodes, or :doc:`subscribe <About-Topics>` to named topics to get data from other nodes. They can also act as a :doc:`service client <About-Services>` to have another node perform a computation on their behalf, or as a :doc:`service server <About-Services>` to provide functionality to other nodes. For long-running computations, a node can act as an :doc:`action client <About-Actions>` to have another node perform it on their behalf, or as an :doc:`action server <About-Actions>` to provide functionality to other nodes. Nodes can provide configurable :doc:`parameters <About-Parameters>` to change behavior during run-time."
msgstr ""

#: ../../source/Concepts/Basic/About-Nodes.rst:16
msgid "Nodes are often a complex combination of publishers, subscribers, service servers, service clients, action servers, and action clients, all at the same time."
msgstr ""

#: ../../source/Concepts/Basic/About-Nodes.rst:18
msgid "Connections between nodes are established through a distributed :doc:`discovery <About-Discovery>` process."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:15
msgid "Parameters in ROS 2 are associated with individual nodes. Parameters are used to configure nodes at startup (and during runtime), without changing the code. The lifetime of a parameter is tied to the lifetime of the node (though the node could implement some sort of persistence to reload values after restart)."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:19
msgid "Parameters are addressed by node name, node namespace, parameter name, and parameter namespace. Providing a parameter namespace is optional."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:22
msgid "Each parameter consists of a key, a value, and a descriptor. The key is a string and the value is one of the following types: ``bool``, ``int64``, ``float64``, ``string``, ``byte[]``, ``bool[]``, ``int64[]``, ``float64[]`` or ``string[]``. By default all descriptors are empty, but can contain parameter descriptions, value ranges, type information, and additional constraints."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:26
msgid "For an hands-on tutorial with ROS parameters see :doc:`../../Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Parameters/Understanding-ROS2-Parameters`."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:29
msgid "Parameters background"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:32
msgid "Declaring parameters"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:34
msgid "By default, a node needs to *declare* all of the parameters that it will accept during its lifetime. This is so that the type and name of the parameters are well-defined at node startup time, which reduces the chances of misconfiguration later on. See :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python` for tutorials on declaring and using parameters from a node."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:38
msgid "For some types of nodes, not all of the parameters will be known ahead of time. In these cases, the node can be instantiated with ``allow_undeclared_parameters`` set to ``true``, which will allow parameters to be get and set on the node even if they haven't been declared."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:42
msgid "Parameter types"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:44
msgid "Each parameter on a ROS 2 node has one of the pre-defined parameter types as mentioned in the Overview. By default, attempts to change the type of a declared parameter at runtime will fail. This prevents common mistakes, such as putting a boolean value into an integer parameter."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:48
msgid "If a parameter needs to be multiple different types, and the code using the parameter can handle it, this default behavior can be changed. When the parameter is declared, it should be declared using a ``ParameterDescriptor`` with the ``dynamic_typing`` member variable set to ``true``."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:52
msgid "Parameter callbacks"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:54
msgid "A ROS 2 node can register two different types of callbacks to be informed when changes are happening to parameters. Both of the callbacks are optional."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:57
msgid "The first is known as a \"set parameter\" callback, and can be set by calling ``add_on_set_parameters_callback`` from the node API. The callback is passed a list of immutable ``Parameter`` objects, and returns an ``rcl_interfaces/msg/SetParametersResult``. The main purpose of this callback is to give the user the ability to inspect the upcoming change to the parameter and explicitly reject the change."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:62
msgid "It is important that \"set parameter\" callbacks have no side-effects. Since multiple \"set parameter\" callbacks can be chained, there is no way for an individual callback to know if a later callback will reject the update. If the individual callback were to make changes to the class it is in, for instance, it may get out-of-sync with the actual parameter. To get a callback *after* a parameter has been successfully changed, see the next type of callback below."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:67
msgid "The second type of callback is known as an \"on parameter event\" callback, and can be set by calling ``on_parameter_event`` from the parameter client APIs. The callback is passed an ``rcl_interfaces/msg/ParameterEvent`` object, and returns nothing. This callback will be called after all parameters in the input event have been declared, changed, or deleted. The main purpose of this callback is to give the user the ability to react to changes from parameters that have successfully been accepted."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:73
msgid "Interacting with parameters"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:75
msgid "ROS 2 nodes can perform parameter operations through node APIs as described in :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-CPP` or :doc:`../../Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python`. External processes can perform parameter operations via parameter services that are created by default when a node is instantiated. The services that are created by default are:"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:79
msgid "``/node_name/describe_parameters``: Uses a service type of ``rcl_interfaces/srv/DescribeParameters``. Given a list of parameter names, returns a list of descriptors associated with the parameters."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:81
msgid "``/node_name/get_parameter_types``: Uses a service type of ``rcl_interfaces/srv/GetParameterTypes``. Given a list of parameter names, returns a list of parameter types associated with the parameters."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:83
msgid "``/node_name/get_parameters``: Uses a service type of ``rcl_interfaces/srv/GetParameters``. Given a list of parameter names, returns a list of parameter values associated with the parameters."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:85
msgid "``/node_name/list_parameters``: Uses a service type of ``rcl_interfaces/srv/ListParameters``. Given an optional list of parameter prefixes, returns a list of the available parameters with that prefix.  If the prefixes are empty, returns all parameters."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:87
msgid "``/node_name/set_parameters``: Uses a service type of ``rcl_interfaces/srv/SetParameters``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a list of results from trying to set each parameter; some of them may have succeeded and some may have failed."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:89
msgid "``/node_name/set_parameters_atomically``: Uses a service type of ``rcl_interfaces/srv/SetParametersAtomically``. Given a list of parameter names and values, attempts to set the parameters on the node.  Returns a single result from trying to set all parameters, so if one failed, all of them failed."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:93
msgid "Setting initial parameter values when running a node"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:95
msgid "Initial parameter values can be set when running the node either through individual command-line arguments, or through YAML files. See :ref:`NodeArgsParameters` for examples on how to set initial parameter values."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:99
msgid "Setting initial parameter values when launching nodes"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:101
msgid "Initial parameter values can also be set when running the node through the ROS 2 launch facility. See :doc:`this document <../../Tutorials/Intermediate/Launch/Using-ROS2-Launch-For-Large-Projects>` for information on how to specify parameters via launch."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:105
msgid "Manipulating parameter values at runtime"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:107
msgid "The ``ros2 param`` command is the general way to interact with parameters for nodes that are already running. ``ros2 param`` uses the parameter service API as described above to perform the various operations. See :doc:`this how-to guide <../../How-To-Guides/Using-ros2-param>` for details on how to use ``ros2 param``."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:112
msgid "Migrating from ROS 1"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:114
msgid "The :doc:`Launch file migration guide <../../How-To-Guides/Migrating-from-ROS1/Migrating-Launch-Files>` explains how to migrate ``param`` and ``rosparam`` launch tags from ROS 1 to ROS 2."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:116
msgid "The :doc:`YAML parameter file migration guide <../../How-To-Guides/Migrating-from-ROS1/Migrating-Parameters>` explains how to migrate parameter files from ROS 1 to ROS 2."
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:118
msgid "In ROS 1, the ``roscore`` acted like a global parameter blackboard where all nodes could get and set parameters. Since there is no central ``roscore`` in ROS 2, that functionality no longer exists. The recommended approach in ROS 2 is to use per-node parameters that are closely tied to the nodes that use them. If a global blackboard is still needed, it is possible to create a dedicated node for this purpose. ROS 2 ships with one in the ``ros-humble-demo-nodes-cpp`` package called ``parameter_blackboard``; it can be run with:"
msgstr ""

#: ../../source/Concepts/Basic/About-Parameters.rst:128
msgid "The code for the ``parameter_blackboard`` is `here <https://github.com/ros2/demos/blob/humble/demo_nodes_cpp/src/parameters/parameter_blackboard.cpp>`__."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:7
msgid "In ROS 2, a service refers to a remote procedure call. In other words, a node can make a remote procedure call to another node which will do a computation and return a result."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:10
msgid "This structure is reflected in how a service message definition looks:"
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:18
msgid "In ROS 2, services are expected to return quickly, as the client is generally waiting on the result. Services should never be used for longer running processes, in particular processes that might need to be preempted for exceptional situations. If you have a service that will be doing a long-running computation, consider using an :doc:`action <About-Actions>` instead."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:22
msgid "Services are identified by a service name, which looks much like a topic name (but is in a different namespace)."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:24
msgid "A service consists of two parts: the service server and the service client."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:27
msgid "Service server"
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:29
msgid "A service server is the entity that will accept a remote procedure request, and perform some computation on it. For instance, suppose the ROS 2 message contains the following:"
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:39
msgid "The service server would be the entity that receives this message, adds ``a`` and ``b`` together, and returns the ``sum``."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:43
msgid "There should only ever be one service server per service name. It is undefined which service server will receive client requests in the case of multiple service servers on the same service name."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:47
msgid "Service client"
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:49
msgid "A service client is an entity that will request a remote service server to perform a computation on its behalf. Following from the example above, the service client is the entity that creates the initial message containing ``a`` and ``b``, and waits for the service server to compute the sum and return the result."
msgstr ""

#: ../../source/Concepts/Basic/About-Services.rst:52
msgid "Unlike the service server, there can be arbitrary numbers of service clients using the same service name."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:2
msgid "Topics"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:7
msgid "Topics are one of the three primary styles of interfaces provided by ROS 2. Topics should be used for continuous data streams, like sensor data, robot state, etc."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:10
msgid "As stated earlier, ROS 2 is a strongly-typed, anonymous publish/subscribe system. Let's break down that sentence and explain it a bit more."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:14
msgid "Publish/Subscribe"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:16
msgid "A publish/subscribe system is one in which there are producers of data (publishers) and consumers of data (subscribers). The publishers and subscribers know how to contact each other through the concept of a \"topic\", which is a common name so that the entites can find each other. For instance, when you create a publisher, you must also give it a string that is the name of the topic; the same goes for the subscriber. Any publishers and subscribers that are on the same topic name can directly communicate with each other. There may be zero or more publishers and zero or more subscribers on any particular topic. When data is published to the topic by any of the publishers, all subscribers in the system will receive the data. This system is also known as a \"bus\", since it somewhat resembles a device bus from electrical engineering. This concept of a bus is part of what makes ROS 2 a powerful and flexible system. Publishers and subscribers can come and go as needed, meaning that debugging and introspection are natural extensions to the system. For instance, if you want to record data, you can use the ``ros2 bag record`` command. Under the hood, ``ros2 bag record`` creates a new subscriber to whatever topic you tell it, without interrupting the flow of data to the other parts of the system."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:29
msgid "Anonymous"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:31
msgid "Another fact mentioned in the introduction is that ROS 2 is \"anonymous\". This means that when a subscriber gets a piece of data, it doesn't generally know or care which publisher originally sent it (though it can find out if it wants). The benefit to this architecture is that publishers and subscribers can be swapped out at will without affecting the rest of the system."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:36
msgid "Strongly-typed"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:38
msgid "Finally, the introduction also mentioned that the publish/subscribe system is \"strongly-typed\". That has two meanings in this context:"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:41
msgid "The types of each field in a ROS message are typed, and that type is enforced at various levels. For instance, if the ROS message contains:"
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:49
msgid "Then the code will ensure that ``field`` is always an unsigned integer and that ``field2`` is always a string."
msgstr ""

#: ../../source/Concepts/Basic/About-Topics.rst:51
msgid "The semantics of each field are well-defined.  There is no automated mechanism to ensure this, but all of the core ROS types have strong semantics associated with them.  For instance, the IMU message contains a 3-dimensional vector for the measured angular velocity, and each of the dimensions is specified to be in radians/second.  Other interpretations should not be placed into the message."
msgstr ""

#: ../../source/Concepts/Intermediate.rst:2
msgid "Intermediate Concepts"
msgstr ""

#: ../../source/Concepts/Intermediate.rst:4
msgid "These are the concepts that further your understanding of a basic ROS 2 system."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:6
msgid "Composition"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:12
msgid "ROS 1 - Nodes vs. Nodelets"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:14
msgid "In ROS 1 you can write your code either as a `ROS node <https://wiki.ros.org/Nodes>`__ or as a `ROS nodelet <https://wiki.ros.org/nodelet>`__. ROS 1 nodes are compiled into executables. ROS 1 nodelets on the other hand are compiled into a shared library which is then loaded at runtime by a container process."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:19
msgid "ROS 2 - Unified API"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:21
msgid "In ROS 2 the recommended way of writing your code is similar to a nodelet - we call it a ``Component``. This makes it easy to add common concepts to existing code, like a `life cycle <https://design.ros2.org/articles/node_lifecycle.html>`__. Having different APIs, which was the biggest drawback in ROS 1, is avoided in ROS 2 since both approaches use the same API."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:27
msgid "It is still possible to use the node-like style of \"writing your own main\" but for the common case it is not recommended."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:29
msgid "By making the process layout a deploy-time decision the user can choose between:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:31
msgid "running multiple nodes in separate processes with the benefits of process/fault isolation as well as easier debugging of individual nodes and"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:32
msgid "running multiple nodes in a single process with the lower overhead and optionally more efficient communication (see :doc:`Intra Process Communication <../../Tutorials/Demos/Intra-Process-Communication>`)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:34
msgid "Additionally ``ros2 launch`` can be used to automate these actions through specialized launch actions."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:37
msgid "Writing a Component"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:39
msgid "Since a component is only built into a shared library, it doesn't have a ``main`` function (see `Talker source code <https://github.com/ros2/demos/blob/humble/composition/src/talker_component.cpp>`__). A component is commonly a subclass of ``rclcpp::Node``. Since it is not in control of the thread, it shouldn't perform any long running or blocking tasks in its constructor. Instead, it can use timers to get periodic notifications. Additionally, it can create publishers, subscriptions, servers, and clients."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:45
msgid "An important aspect of making such a class a component is that the class registers itself using macros from the package ``rclcpp_components`` (see the last line in the source code). This makes the component discoverable when its library is being loaded into a running process - it acts as kind of an entry point."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:48
msgid "Additionally, once a component is created, it must be registered with the index to be discoverable by the tooling."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:59
msgid "In order for the component_container to be able to find desired components, it must be executed or launched from a shell that has sourced the corresponding workspace."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:62
msgid "Using Components"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:64
msgid "The `composition <https://github.com/ros2/demos/tree/humble/composition>`__ package contains a couple of different approaches on how to use components. The three most common ones are:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:67
msgid "Start a (`generic container process <https://github.com/ros2/rclcpp/blob/humble/rclcpp_components/src/component_container.cpp>`__) and call the ROS service `load_node <https://github.com/ros2/rcl_interfaces/blob/humble/composition_interfaces/srv/LoadNode.srv>`__ offered by the container. The ROS service will then load the component specified by the passed package name and library name and start executing it within the running process. Instead of calling the ROS service programmatically you can also use a `command line tool <https://github.com/ros2/ros2cli/tree/humble/ros2component>`__ to invoke the ROS service with the passed command line arguments"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:70
msgid "Create a `custom executable <https://github.com/ros2/demos/blob/humble/composition/src/manual_composition.cpp>`__ containing multiple nodes which are known at compile time. This approach requires that each component has a header file (which is not strictly needed for the first case)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:72
msgid "Create a launch file and use ``ros2 launch`` to create a container process with multiple components loaded."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:75
msgid "Practical application"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Composition.rst:77
msgid "Try the :doc:`Composition demos <../../Tutorials/Intermediate/Composition>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:6
msgid "Cross-compilation"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:17
msgid "Open Robotics provides pre-built ROS 2 packages for multiple platforms, but a number of developers still rely on `cross-compilation <https://en.wikipedia.org/wiki/Cross_compiler>`__ for different reasons such as:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:15
msgid "The development machine does not match the target system."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:16
msgid "Tuning the build for specific core architecture (e.g. setting -mcpu=cortex-a53 -mfpu=neon-fp-armv8 when building for Raspberry Pi3)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:17
msgid "Targeting a file system other than the ones supported by the pre-built images released by Open Robotics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:20
msgid "How does it work ?"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:22
msgid "Cross-compiling simple software (e.g. no dependencies on external libraries) is relatively simple and only requiring a cross-compiler toolchain to be used instead of the native toolchain."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:27
msgid "There are a number of factors which make this process more complex:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:25
msgid "The software being built must support the target architecture. Architecture specific code must be properly isolated and enabled during the build according to the target architecture. Examples include assembly code."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:26
msgid "All dependencies (e.g. libraries) must be present, either as pre-built or cross-compiled packages, before the target software using them is cross-compiled."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:27
msgid "When building software stacks (as opposed to standalone software) using build tools (e.g. colcon), it is expected that the build tool provides a mechanism to allow the developer to enable cross-compilation on the underlying build system used by each piece of software in the stack."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:30
msgid "Cross-compiling ROS 2"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:32
msgid "The ROS 2 cross-compile tool is under shared ownership of Open Robotics and ROS Tooling Working Group. It is a Python script that compiles ROS 2 source files for supported target architectures using an emulator in a docker container. Detailed design of the tool can be found on `ROS 2 design <https://design.ros2.org/articles/cc_build_tools.html>`__. Instructions to use the tool are in the `cross_compile package <https://github.com/ros-tooling/cross_compile>`__."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Cross-Compilation.rst:37
msgid "If you are using an older version, please follow the :doc:`cross-compilation guide <../../How-To-Guides/Cross-compilation>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:7
msgid "Different ROS 2 middleware vendors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:12
msgid "ROS 2 is built on top of DDS/RTPS as its middleware, which provides discovery, serialization and transportation. `This article <https://design.ros2.org/articles/ros_on_dds.html>`__ explains the motivation behind using DDS implementations, and/or the RTPS wire protocol of DDS, in detail. In summary, DDS is an end-to-end middleware that provides features which are relevant to ROS systems, such as distributed discovery (not centralized like in ROS 1) and control over different \"Quality of Service\" options for the transportation."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:16
msgid "`DDS <https://www.omg.org/omg-dds-portal>`__ is an industry standard which is implemented by a range of vendors, such as RTI's `Connext DDS <https://www.rti.com/products/>`__, eProsima's `Fast DDS <https://fast-dds.docs.eprosima.com/>`__, Eclipse's `Cyclone DDS <https://projects.eclipse.org/projects/iot.cyclonedds>`__, or GurumNetworks's `GurumDDS <https://gurum.cc/index_eng>`__. RTPS (a.k.a. `DDSI-RTPS <https://www.omg.org/spec/DDSI-RTPS/About-DDSI-RTPS/>`__\\ ) is the wire protocol used by DDS to communicate over the network."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:19
msgid "ROS 2 supports multiple DDS/RTPS implementations because it is not necessarily \"one size fits all\" when it comes to choosing a vendor/implementation. There are many factors you might consider while choosing a middleware implementation: logistical considerations like the license, or technical considerations like platform availability, or computation footprint. Vendors may provide more than one DDS or RTPS implementation targeted at meeting different needs. For example, RTI has a few variations of their Connext implementation that vary in purpose, like one that specifically targets microcontrollers and another which targets applications requiring special safety certifications (we only support their standard desktop version at this time)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:24
msgid "In order to use a DDS/RTPS implementation with ROS 2, a \"\\ **R**\\ OS **M**\\ iddle\\ **w**\\ are interface\" (a.k.a. ``rmw`` interface or just ``rmw``\\ ) package needs to be created that implements the abstract ROS middleware interface using the DDS or RTPS implementation's API and tools. It's a lot of work to implement and maintain RMW packages for supporting DDS implementations, but supporting at least a few implementations is important for ensuring that the ROS 2 codebase is not tied to any one particular implementation, as users may wish to switch out implementations depending on their project's needs."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:28
msgid "Supported RMW implementations"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:33
msgid "Product name"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:34
msgid "License"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:35
msgid "RMW implementation"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:36
msgid "Status"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:37
msgid "eProsima *Fast DDS*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:38
msgid "Apache 2"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:39
msgid "``rmw_fastrtps_cpp``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:40
msgid "Full support. Default RMW. Packaged with binary releases."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:41
msgid "Eclipse *Cyclone DDS*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:42
msgid "Eclipse Public License v2.0"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:43
msgid "``rmw_cyclonedds_cpp``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:44
msgid "Full support. Packaged with binary releases."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:45
msgid "RTI *Connext DDS*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:46
msgid "commercial, research"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:47
msgid "``rmw_connextdds``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:48
msgid "Full support. Support included in binaries, but Connext installed separately."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:49
msgid "GurumNetworks *GurumDDS*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:50
msgid "commercial"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:51
msgid "``rmw_gurumdds_cpp``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:52
msgid "Community support. Support included in binaries, but GurumDDS installed separately."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:54
msgid "For practical information on working with multiple RMW implementations, see the :doc:`\"Working with multiple RMW implementations\" <../../How-To-Guides/Working-with-multiple-RMW-implementations>` tutorial."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:57
msgid "Multiple RMW implementations"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:59
msgid "The ROS 2 binary releases for currently active distros have built-in support for several RMW implementations out of the box (Fast DDS, RTI Connext Pro, Eclipse Cyclone DDS, GurumNetworks GurumDDS). The default is Fast DDS, which works without any additional installation steps because we distribute it with our binary packages."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:62
msgid "Other RMWs like Cyclone DDS, Connext or GurumDDS can be enabled by :doc:`installing additional packages <../../Installation/DDS-Implementations>`, but without having to rebuild anything or replace any existing packages."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:64
msgid "A ROS 2 workspace that has been built from source may build and install multiple RMW implementations simultaneously. While the core ROS 2 code is being compiled, any RMW implementation that is found will be built if the relevant DDS/RTPS implementation has been installed properly and the relevant environment variables have been configured. For example, if the code for the `RMW package for RTI Connext DDS <https://github.com/ros2/rmw_connextdds>`__ is in the workspace, it will be built if an installation of RTI's Connext Pro can also be found."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:68
msgid "For many cases you will find that nodes using different RMW implementations are able to communicate, however this is not true under all circumstances. Here is a list of inter-vendor communication configurations that are not supported:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:71
msgid "Fast DDS <-> Connext"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:72
msgid "``WString`` published by Fast DDS can't be received correctly by Connext on macOS"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:74
msgid "Connext <-> Cyclone DDS"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:74
msgid "does not support pub/sub communication for ``WString``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:77
msgid "Default RMW implementation"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:79
msgid "If a ROS 2 workspace has multiple RMW implementations, Fast DDS is selected as the default RMW implementation if it is available. If the Fast DDS RMW implementation is not installed, the RMW implementation with the first RMW implementation identifier in alphabetical order will be used. The implementation identifier is the name of the ROS package that provides the RMW implementation, e.g. ``rmw_cyclonedds_cpp``. For example, if both ``rmw_cyclonedds_cpp`` and ``rmw_connextdds`` ROS packages are installed, ``rmw_connextdds`` would be the default. If ``rmw_fastrtps_cpp`` is ever installed, it would be the default."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Different-Middleware-Vendors.rst:85
msgid "See the :doc:`guide <../../How-To-Guides/Working-with-multiple-RMW-implementations>` for how to specify which RMW implementation is to be used when running the ROS 2 examples."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:6
msgid "The ROS_DOMAIN_ID"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:14
msgid "As explained elsewhere, the default middleware that ROS 2 uses for communication is DDS. In DDS, the primary mechanism for having different logical networks share a physical network is known as the Domain ID. ROS 2 nodes on the same domain can freely discover and send messages to each other, while ROS 2 nodes on different domains cannot. All ROS 2 nodes use domain ID 0 by default. To avoid interference between different groups of computers running ROS 2 on the same network, a different domain ID should be set for each group."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:21
msgid "Choosing a domain ID (short version)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:23
msgid "The text below explains the derivation of the range of domain IDs that should be used in ROS 2. To skip that background and just choose a safe number, simply choose a domain ID between 0 and 101, inclusive."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:28
msgid "Choosing a domain ID (long version)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:30
msgid "The domain ID is used by DDS to compute the UDP ports that will be used for discovery and communication. See `this article <https://community.rti.com/content/forum-topic/statically-configure-firewall-let-omg-dds-traffic-through>`__ for details on how the ports are computed. Remembering our basic networking, the UDP port is an `unsigned 16-bit integer <https://en.wikipedia.org/wiki/User_Datagram_Protocol#Ports>`__. Thus, the highest port number that can be allocated is 65535. Doing some math with the formula in the article above, this means that the highest domain ID that can possibly be assigned is 232, while the lowest that can be assigned is 0."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:37
msgid "Platform-specific constraints"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:39
msgid "For maximum compatibility, some additional platform-specific constraints should be followed when choosing a domain ID. In particular, it is best to avoid allocating domain IDs in the operating system's `ephemeral port range <https://en.wikipedia.org/wiki/Ephemeral_port>`__. This avoids possible conflicts between the ports used by the ROS 2 nodes and other networking services on the computers."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:43
msgid "Here are some platform-specific notes about ephemeral ports."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:47
msgid "Linux"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:49
msgid "By default, the Linux kernel uses ports 32768-60999 for ephemeral ports. This means that domain IDs 0-101 and 215-232 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Linux by setting custom values in ``/proc/sys/net/ipv4/ip_local_port_range``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:54
msgid "macOS"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:56
msgid "By default, the ephemeral port range on macOS is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in macOS by setting custom sysctl values for ``net.inet.ip.portrange.first`` and ``net.inet.ip.portrange.last``. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:61
msgid "Windows"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:63
msgid "By default, the ephemeral port range on Windows is 49152-65535. This means that domain IDs 0-166 can be safely used without colliding with ephemeral ports. The ephemeral port range is configurable in Windows by `using netsh <https://docs.microsoft.com/en-us/troubleshoot/windows-server/networking/default-dynamic-port-range-tcpip-chang>`__. If a custom ephemeral port range is used, the above numbers may have to be adjusted accordingly."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:69
msgid "Participant constraints"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:71
msgid "For each ROS 2 process running on a computer, one DDS \"participant\" is created. Since each DDS participant takes up two ports on the computer, running more than 120 ROS 2 processes on one computer may spill over into other domain IDs or the ephemeral ports."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:74
msgid "To see why, consider the domain IDs 1 and 2."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:76
msgid "Domain ID 1 uses port 7650 and 7651 for multicast."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:77
msgid "Domain ID 2 uses port 7900 and 7901 for multicast."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:78
msgid "When creating the 1st process (zeroth participant) in domain ID 1, the ports 7660 and 7661 are used for unicast."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:79
msgid "When creating the 120th process (119th participant) in domain ID 1, the ports 7898 and 7899 are used for unicast."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:80
msgid "When creating the 121st process (120th participant) in domain ID 1, the ports 7900 and 7901 are used for unicast and overlap with domain ID 2."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:82
msgid "If it is known that the computer will only ever be on a single domain ID at a time, and the domain ID is low enough, it is safe to create more ROS 2 processes than this."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:84
msgid "When choosing a domain ID that is near the top of the range of platform-specific domain IDs, one additional constraint should be considered."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:86
msgid "For instance, assume a Linux computer with a domain ID of 101:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:88
msgid "The zero'th ROS 2 process on the computer will connect to ports 32650, 32651, 32660, and 32661."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:89
msgid "The first ROS 2 process on the computer will connect to ports 32650, 32651, 32662, and 32663."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:90
msgid "The 53rd ROS 2 process on the computer will connect to ports 32650, 32651, 32766, and 32767."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:91
msgid "The 54th ROS 2 process on the computer will connect to ports 32650, 32651, 32768, and 32769, running into the ephemeral port range."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:93
msgid "Thus the maximum number of processes that should be created when using domain ID 101 on Linux is 54. Similarly, the maximum number of processes that should be created when using domain ID 232 on Linux is 63, as the maximum port number is 65535."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:96
msgid "The situation is similar on macOS and Windows, though the numbers are different. On macOS and Windows, when choosing a domain ID of 166 (the top of the range), the maximum number of ROS 2 processes that can be created on a computer before running into the ephemeral port range is 120."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Domain-ID.rst:100
msgid "Domain ID to UDP Port Calculator"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:6
msgid "Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:14
msgid "Execution management in ROS 2 is handled by Executors. An Executor uses one or more threads of the underlying operating system to invoke the callbacks of subscriptions, timers, service servers, action servers, etc. on incoming messages and events. The explicit Executor class (in `executor.hpp <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/executor.hpp>`_ in rclcpp, in `executors.py <https://github.com/ros2/rclpy/blob/humble/rclpy/rclpy/executors.py>`_ in rclpy, or in `executor.h <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_ in rclc) provides more control over execution management than the spin mechanism in ROS 1, although the basic API is very similar."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:18
msgid "In the following, we focus on the C++ Client Library *rclcpp*."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:21
msgid "Basic use"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:23
msgid "In the simplest case, the main thread is used for processing the incoming messages and events of a Node by calling ``rclcpp::spin(..)`` as follows:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:44
msgid "The call to ``spin(node)`` basically expands to an instantiation and invocation of the Single-Threaded Executor, which is the simplest Executor:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:52
msgid "By invoking ``spin()`` of the Executor instance, the current thread starts querying the rcl and middleware layers for incoming messages and other events and calls the corresponding callback functions until the node shuts down. In order not to counteract the QoS settings of the middleware, an incoming message is not stored in a queue on the Client Library layer but kept in the middleware until it is taken for processing by a callback function. (This is a crucial difference to ROS 1.) A *wait set* is used to inform the Executor about available messages on the middleware layer, with one binary flag per queue. The *wait set* is also used to detect when timers expire."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:60
msgid "The Single-Threaded Executor is also used by the container process for :doc:`components <./About-Composition>`, i.e. in all cases where nodes are created and executed without an explicit main function."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:63
msgid "Types of Executors"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:65
msgid "Currently, rclcpp provides three Executor types, derived from a shared parent class:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:81
msgid "The *Multi-Threaded Executor* creates a configurable number of threads to allow for processing multiple messages or events in parallel. The *Static Single-Threaded Executor* optimizes the runtime costs for scanning the structure of a node in terms of subscriptions, timers, service servers, action servers, etc. It performs this scan only once when the node is added, while the other two executors regularly scan for such changes. Therefore, the Static Single-Threaded Executor should be used only with nodes that create all subscriptions, timers, etc. during initialization."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:86
msgid "All three executors can be used with multiple nodes by calling ``add_node(..)`` for each node."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:100
msgid "In the above example, the one thread of a Static Single-Threaded Executor is used to serve three nodes together. In case of a Multi-Threaded Executor, the actual parallelism depends on the callback groups."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:104
msgid "Callback groups"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:106
msgid "ROS 2 allows organizing the callbacks of a node in groups. In rclcpp, such a *callback group* can be created by the ``create_callback_group`` function of the Node class. In rclpy, the same is done by calling the constructor of the specific callback group type. The callback group must be stored throughout execution of the node (eg. as a class member), or otherwise the executor won't be able to trigger the callbacks. Then, this callback group can be specified when creating a subscription, timer, etc. - for example by the subscription options:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:114 ../../source/Concepts/Intermediate/About-Logging.rst:48 ../../source/Concepts/Intermediate/About-Logging.rst:184
msgid "C++"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:125 ../../source/Concepts/Intermediate/About-Logging.rst:71 ../../source/Concepts/Intermediate/About-Logging.rst:190
msgid "Python"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:133
msgid "All subscriptions, timers, etc. that are created without the indication of a callback group are assigned to the *default callback group*. The default callback group can be queried via ``NodeBaseInterface::get_default_callback_group()`` in rclcpp and by ``Node.default_callback_group`` in rclpy."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:137
msgid "There are two types of callback groups, where the type has to be specified at instantiation time:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:139
msgid "*Mutually exclusive:* Callbacks of this group must not be executed in parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:140
msgid "*Reentrant:* Callbacks of this group may be executed in parallel."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:142
msgid "Callbacks of different callback groups may always be executed in parallel. The Multi-Threaded Executor uses its threads as a pool to process as many callbacks as possible in parallel according to these conditions. For tips on how to use callback groups efficiently, see :doc:`Using Callback Groups <../../How-To-Guides/Using-callback-groups>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:146
msgid "The Executor base class in rclcpp also has the function ``add_callback_group(..)``, which allows distributing callback groups to different Executors. By configuring the underlying threads using the operating system scheduler, specific callbacks can be prioritized over other callbacks. For example, the subscriptions and timers of a control loop can be prioritized over all other subscriptions and standard services of a node. The `examples_rclcpp_cbg_executor package <https://github.com/ros2/examples/tree/humble/rclcpp/executors/cbg_executor>`_ provides a demo of this mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:152
msgid "Scheduling semantics"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:154
msgid "If the processing time of the callbacks is shorter than the period with which messages and events occur, the Executor basically processes them in FIFO order. However, if the processing time of some callbacks is longer, messages and events will be queued on the lower layers of the stack. The wait set mechanism reports only very little information about these queues to the Executor. In detail, it only reports whether there are any messages for a certain topic or not. The Executor uses this information to process the messages (including services and actions) in a round-robin fashion - but not in FIFO order. The following flow diagram visualizes this scheduling semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:163
msgid "This semantics was first described in a `paper by Casini et al. at ECRTS 2019 <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_. (Note: The paper also explains that timer events are prioritized over all other messages. `This prioritization was removed in Eloquent. <https://github.com/ros2/rclcpp/pull/841>`_)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:168
msgid "Outlook"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:170
msgid "While the three Executors of rclcpp work well for most applications, there are some issues that make them not suitable for real-time applications, which require well-defined execution times, determinism, and custom control over the execution order. Here is a summary of some of these issues:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:173
msgid "Complex and mixed scheduling semantics. Ideally you want well defined scheduling semantics to perform a formal timing analysis."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:175
msgid "Callbacks may suffer from priority inversion. Higher priority callbacks may be blocked by lower priority callbacks."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:177
msgid "No explicit control over the callbacks execution order."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:178
msgid "No built-in control over triggering for specific topics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:180
msgid "Additionally, the executor overhead in terms of CPU and memory usage is considerable. The Static Single-Threaded Executor reduces this overhead greatly but it might not be enough for some applications."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:183
msgid "These issues have been partially addressed by the following developments:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:185
msgid "`rclcpp WaitSet <https://github.com/ros2/rclcpp/blob/humble/rclcpp/include/rclcpp/wait_set.hpp>`_: The ``WaitSet`` class of rclcpp allows waiting directly on subscriptions, timers, service servers, action servers, etc. instead of using an Executor. It can be used to implement deterministic, user-defined processing sequences, possibly processing multiple messages from different subscriptions together. The `examples_rclcpp_wait_set package <https://github.com/ros2/examples/tree/humble/rclcpp/wait_set>`_ provides several examples for the use of this user-level wait set mechanism."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:188
msgid "`rclc Executor <https://github.com/ros2/rclc/blob/master/rclc/include/rclc/executor.h>`_: This Executor from the C Client Library *rclc*, developed for micro-ROS, gives the user fine-grained control over the execution order of callbacks and allows for custom trigger conditions to activate callbacks. Furthermore, it implements ideas of the Logical Execution Time (LET) semantics."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:192
msgid "Further information"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:194
msgid "Michael Pöhnl et al.: `\"ROS 2 Executor: How to make it efficient, real-time and deterministic?\" <https://www.apex.ai/roscon-21>`_. Workshop at ROS World 2021. Virtual event. 19 October 2021."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:195
msgid "Ralph Lange: `\"Advanced Execution Management with ROS 2\" <https://www.youtube.com/watch?v=Sz-nllmtcc8&t=109s>`_. ROS Industrial Conference. Virtual event. 16 December 2020."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Executors.rst:196
msgid "Daniel Casini, Tobias Blass, Ingo Lütkebohle, and Björn Brandenburg: `“Response-Time Analysis of ROS 2 Processing Chains under Reservation-Based Scheduling” <https://drops.dagstuhl.de/opus/volltexte/2019/10743/pdf/LIPIcs-ECRTS-2019-6.pdf>`_, Proc. of 31st ECRTS 2019, Stuttgart, Germany, July 2019."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:7
msgid "Logging and logger configuration"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:15
msgid "The logging subsystem in ROS 2 aims to deliver logging messages to a variety of targets, including:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:17
msgid "To the console (if one is attached)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:18
msgid "To log files on disk (if local storage is available)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:19
msgid "To the ``/rosout`` topic on the ROS 2 network"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:21
msgid "By default, log messages in ROS 2 nodes will go out to the console (on stderr), to log files on disk, and to the ``/rosout`` topic on the ROS 2 network. All of the targets can be individually enabled or disabled on a per-node basis."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:24
msgid "The rest of this document will go over some of the ideas behind the logging subsystem."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:27
msgid "Severity level"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:29
msgid "Log messages have a severity level associated with them: ``DEBUG``, ``INFO``, ``WARN``, ``ERROR`` or ``FATAL``, in ascending order."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:31
msgid "A logger will only process log messages with severity at or higher than a specified level chosen for the logger."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:33
msgid "Each node has a logger associated with it that automatically includes the node's name and namespace. If the node's name is externally remapped to something other than what is defined in the source code, it will be reflected in the logger name. Non-node loggers can also be created that use a specific name."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:37
msgid "Logger names represent a hierarchy. If the level of a logger named \"abc.def\" is unset, it will defer to the level of its parent named \"abc\", and if that level is also unset, the default logger level will be used. When the level of logger \"abc\" is changed, all of its descendants (e.g. \"abc.def\", \"abc.ghi.jkl\") will have their level impacted unless their level has been explicitly set."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:42
msgid "APIs"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:44
msgid "These are the APIs that end users of the ROS 2 logging infrastructure should use, split up by client library."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:50
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}`` - output the given printf-style message every time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:51
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_ONCE`` - output the given printf-style message only the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:52
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_EXPRESSION`` - output the given printf-style message only if the given expression is true"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:53
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_FUNCTION`` - output the given printf-style message only if the given function returns true"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:54
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST`` - output the given printf-style message all but the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:55
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:56
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_SKIPFIRST_THROTTLE`` - output the given printf-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:57
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM`` - output the given C++ stream-style message every time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:58
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_ONCE`` - output the given C++ stream-style message only the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:59
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_EXPRESSION`` - output the given C++ stream-style message only if the given expression is true"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:60
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_FUNCTION`` - output the given C++ stream-style message only if the given function returns true"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:61
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST`` - output the given C++ stream-style message all but the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:62
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:63
msgid "``RCLCPP_{DEBUG,INFO,WARN,ERROR,FATAL}_STREAM_SKIPFIRST_THROTTLE`` - output the given C++ stream-style message no more than the given rate in integer milliseconds, but skip the first"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:65
msgid "Each of the above APIs takes an ``rclcpp::Logger`` object as the first argument. This can be pulled from the node API by calling ``node->get_logger()`` (recommended), or by constructing a stand-alone ``rclcpp::Logger`` object."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:68
msgid "``rcutils_logging_set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:69
msgid "``rcutils_logging_get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:73
msgid "``logger.{debug,info,warning,error,fatal}`` - output the given Python string to the logging infrastructure.  The calls accept the following keyword args to control behavior:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:75
msgid "``throttle_duration_sec`` - if not None, the duration of the throttle interval in floating-point seconds"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:76
msgid "``skip_first`` - if True, output the message all but the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:77
msgid "``once`` - if True, only output the message the first time this line is hit"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:79
msgid "``rclpy.logging.set_logger_level`` - Set the logging level for a particular logger name to the given severity level"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:80
msgid "``rclpy.logging.get_logger_effective_level`` - Given a logger name, return the logger level (which may be unset)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:83
msgid "Configuration"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:85
msgid "Since ``rclcpp`` and ``rclpy`` use the same underlying logging infrastructure, the configuration options are the same."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:88
msgid "Environment variables"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:90
msgid "The following environment variables control some aspects of the ROS 2 loggers. For each of the environment settings, note that this is a process-wide setting, so it applies to all nodes in that process."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:93
msgid "``ROS_LOG_DIR`` - Control the logging directory that is used for writing logging messages to disk (if that is enabled).  If non-empty, use the exact directory as specified in this variable.  If empty, use the contents of the ``ROS_HOME`` environment variable to construct a path of the form ``$ROS_HOME/.log``.  In all cases, the ``~`` character is expanded to the user's HOME directory."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:94
msgid "``ROS_HOME`` - Control the home directory that is used for various ROS files, including logging and config files.  In the context of logging, this variable is used to construct a path to a directory for log files.  If non-empty, use the contents of this variable for the ROS_HOME path.  In all cases, the ``~`` character is expanded to the users's HOME directory."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:95
msgid "``RCUTILS_LOGGING_USE_STDOUT`` - Control what stream output messages go to.  If this is unset or 0, use stderr.  If this is 1, use stdout."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:96
msgid "``RCUTILS_LOGGING_BUFFERED_STREAM`` - Control whether the logging stream (as configured in ``RCUTILS_LOGGING_USE_STDOUT``) should be line buffered or unbuffered.  If this is unset, use the default of the stream (generally line buffered for stdout, and unbuffered for stderr).  If this is 0, force the stream to be unbuffered.  If this is 1, force the stream to be line buffered."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:97
msgid "``RCUTILS_COLORIZED_OUTPUT`` - Control whether colors are used when outputting messages.  If unset, automatically determine based on the platform and whether the console is a TTY.  If 0, force disable using colors for output.  If 1, force enable using colors for output."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:98
msgid "``RCUTILS_CONSOLE_OUTPUT_FORMAT`` - Control the fields that are output for each log message.  The available fields are:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:100
msgid "``{severity}`` - The severity level."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:101
msgid "``{name}`` - The name of the logger (may be empty)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:102
msgid "``{message}`` - The log message (may be empty)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:103
msgid "``{function_name}`` - The function name this was called from (may be empty)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:104
msgid "``{file_name}`` - The file name this was called from (may be empty)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:105
msgid "``{time}`` - The time in seconds since the epoch."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:106
msgid "``{time_as_nanoseconds}`` - The time in nanoseconds since the epoch."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:107
msgid "``{line_number}`` - The line number this was called from (may be empty)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:109
msgid "If no format is given, a default of ``[{severity}] [{time}] [{name}]: {message}`` is used."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:113
msgid "Node creation"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:115
msgid "When initializing a ROS 2 node, it is possible to control some aspects of the behavior via node options. Since these are per-node options, they can be set differently for different nodes even when the nodes are composed into a single process."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:118
msgid "``log_levels`` - The log level to use for a component within this particular node.  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-level talker:=DEBUG``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:119
msgid "``external_log_config_file`` - The external file to use to configure the backend logger.  If it is NULL, the default configuration will be used.  Note that the format of this file is backend-specific (and is currently unimplemented for the default backend logger of spdlog).  This can be set with the following: ``ros2 run demo_nodes_cpp talker --ros-args --log-config-file log-config.txt``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:120
msgid "``log_stdout_disabled`` - Whether to disable writing log messages to the console.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-stdout-logs``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:121
msgid "``log_rosout_disabled`` - Whether to disable writing log messages out to ``/rosout``.  This can significantly save on network bandwidth, but external observers will not be able to monitor logging.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-rosout-logs``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:122
msgid "``log_ext_lib_disabled`` - Whether to completely disable the use of an external logger.  This may be faster in some cases, but means that logs will not be written to disk.  This can be done with the following: ``ros2 run demo_nodes_cpp talker --ros-args --disable-external-lib-logs``"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:125
msgid "Logging subsystem design"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:127
msgid "The image below shows the five main pieces to the logging subsystem and how they interact."
msgstr ""

msgid "ROS 2 logging architecture"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:135
msgid "rcutils"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:137
msgid "``rcutils`` has a logging implementation that can format log messages according to a certain format (see ``Configuration`` above), and output those log messages to a console. ``rcutils`` implements a complete logging solution, but allows higher-level components to insert themselves into the logging infrastructure in a dependency-injection model. This will become more evident when we talk about the ``rcl`` layer below."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:141
msgid "Note that this is a *per-process* logging implementation, so anything that is configured at this level will affect the entire process, not just individual nodes."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:144
msgid "rcl_logging_spdlog"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:146
msgid "``rcl_logging_spdlog`` implements the ``rcl_logging_interface`` API, and thus provides external logging services to the ``rcl`` layer. In particular, the ``rcl_logging_spdlog`` implementation takes formatted log messages and writes them out to log files on disk using the ``spdlog`` library, typically within ``~/.ros/log`` (though this is configurable; see ``Configuration`` above)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:150
msgid "rcl"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:152
msgid "The logging subsystem in ``rcl`` uses ``rcutils`` and ``rcl_logging_spdlog`` to provide the bulk of the ROS 2 logging services. When log messages come in, ``rcl`` decides where to send them. There are 3 main places that logging messages can be delivered; an individual node may have any combination of them enabled:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:156
msgid "To the console via the ``rcutils`` layer"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:157
msgid "To disk via the ``rcl_logging_spdlog`` layer"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:158
msgid "To the ``/rosout`` topic on the ROS 2 network via the RMW layer"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:161
msgid "rclcpp"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:163
msgid "This is the main ROS 2 C++ API which sits atop the ``rcl`` API. In the context of logging, ``rclcpp`` provides the ``RCLCPP_`` logging macros; see ``APIs`` above for a complete list. When one of the ``RCLCPP_`` macros runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured. Note that ``rclcpp`` uses a global mutex for log calls, so all logging calls within the same process end up being single-threaded."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:171
msgid "rclpy"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:173
msgid "This is the main ROS 2 Python API which sits atop the ``rcl`` API. In the context of logging, ``rclpy`` provides the ``logger.debug``-style functions; see ``APIs`` above for a complete list. When one of the ``logger.debug`` functions runs, it checks the current severity level of the node against the severity level of the macro. If the severity level of the macro is greater than or equal to the node severity level, the message will be formatted and output to all of the places that are currently configured."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:180
msgid "Logging usage"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:186
msgid "See the `rclcpp logging demo <https://github.com/ros2/demos/tree/humble/logging_demo>`_ for some simple examples."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:187
msgid "See the :doc:`logging demo <../../Tutorials/Demos/Logging-and-logger-configuration>` for example usage."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:188
msgid "See the `rclcpp documentation <https://docs.ros2.org/latest/api/rclcpp/logging_8hpp.html>`__ for an extensive list of functionality."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:192
msgid "See the `rclpy examples <https://github.com/ros2/examples/blob/humble/rclpy/services/minimal_client/examples_rclpy_minimal_client/client.py>`__ for example usage of a node's logger."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Logging.rst:193
msgid "See the `rclpy tests <https://github.com/ros2/rclpy/blob/humble/rclpy/test/test_logging.py>`__ for example usage of keyword arguments (e.g. ``skip_first``, ``once``)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:7
msgid "Quality of Service settings"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:15
msgid "ROS 2 offers a rich variety of Quality of Service (QoS) policies that allow you to tune communication between nodes. With the right set of Quality of Service policies, ROS 2 can be as reliable as TCP or as best-effort as UDP, with many, many possible states in between. Unlike ROS 1, which primarily only supported TCP, ROS 2 benefits from the flexibility of the underlying DDS transport in environments with lossy wireless networks where a \"best effort\" policy would be more suitable, or in real-time computing systems where the right Quality of Service profile is needed to meet deadlines."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:19
msgid "A set of QoS \"policies\" combine to form a QoS \"profile\". Given the complexity of choosing the correct QoS policies for a given scenario, ROS 2 provides a set of predefined QoS profiles for common use cases (e.g. sensor data). At the same time, developers are given the flexibility to control specific policies of the QoS profiles."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:23
msgid "QoS profiles can be specified for publishers, subscriptions, service servers and clients. A QoS profile can be applied independently to each instance of the aforementioned entities, but if different profiles are used, it is possible that they will be incompatible, preventing the delivery of messages."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:28
msgid "QoS policies"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:30
msgid "The base QoS profile currently includes settings for the following policies:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:32
msgid "History"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:34
msgid "*Keep last*: only store up to N samples, configurable via the queue depth option."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:35
msgid "*Keep all*: store all samples, subject to the configured resource limits of the underlying middleware."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:37
msgid "Depth"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:39
msgid "*Queue size*: only honored if the \"history\" policy was set to \"keep last\"."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:41
msgid "Reliability"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:43
msgid "*Best effort*: attempt to deliver samples, but may lose them if the network is not robust."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:44
msgid "*Reliable*: guarantee that samples are delivered, may retry multiple times."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:46
msgid "Durability"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:48
msgid "*Transient local*: the publisher becomes responsible for persisting samples for \"late-joining\" subscriptions."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:49
msgid "*Volatile*: no attempt is made to persist samples."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:51
msgid "Deadline"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:53
msgid "*Duration*: the expected maximum amount of time between subsequent messages being published to a topic"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:55
msgid "Lifespan"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:57
msgid "*Duration*: the maximum amount of time between the publishing and the reception of a message without the message being considered stale or expired (expired messages are silently dropped and are effectively never received)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:59
msgid "Liveliness"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:61
msgid "*Automatic*: the system will consider all of the node’s publishers to be alive for another \"lease duration\" when any one of its publishers has published a message."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:62
msgid "*Manual by topic*: the system will consider the publisher to be alive for another \"lease duration\" if it manually asserts that it is still alive (via a call to the publisher API)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:64
msgid "Lease Duration"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:66
msgid "*Duration*: the maximum period of time a publisher has to indicate that it is alive before the system considers it to have lost liveliness (losing liveliness could be an indication of a failure)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:68
msgid "For each of the policies that is not a duration, there is also the option of \"system default\", which uses the default of the underlying middleware. For each of the policies that is a duration, there also exists a \"default\" option that means the duration is unspecified, which the underlying middleware will usually interpret as an infinitely long duration."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:74
msgid "The \"history\" and \"depth\" policies in ROS 2 combine to provide functionality akin to the queue size in ROS 1."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:76
msgid "The \"reliability\" policy in ROS 2 is akin to the use of either UDPROS (only in ``roscpp``) for \"best effort\", or TCPROS (ROS 1 default) for \"reliable\". Note however that even the reliable policy in ROS 2 is implemented using UDP, which allows for multicasting if appropriate."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:79
msgid "The \"durability\" policy \"transient local\", combined with any depth, provides functionality similar to that of \"latching\" publishers. The remaining policies in ROS 2 are not akin to anything that is available in ROS 1, meaning that ROS 2 is more featureful than ROS 1 in this respect. It is possible that in the future, even more QoS policies will be available in ROS 2."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:85
msgid "QoS profiles"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:87
msgid "Profiles allow developers to focus on their applications without worrying about every QoS setting possible. A QoS profile defines a set of policies that are expected to go well together for a particular use case."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:90
msgid "The currently defined QoS profiles are:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:92
msgid "Default QoS settings for publishers and subscriptions"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:94
msgid "In order to make the transition from ROS 1 to ROS 2 easier, exercising a similar network behavior is desirable. By default, publishers and subscriptions in ROS 2 have \"keep last\" for history with a queue size of 10, \"reliable\" for reliability, \"volatile\" for durability, and \"system default\" for liveliness. Deadline, lifespan, and lease durations are also all set to \"default\"."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:100
msgid "In the same vein as publishers and subscriptions, services are reliable. It is especially important for services to use volatile durability, as otherwise service servers that re-start may receive outdated requests. While the client is protected from receiving multiple responses, the server is not protected from side-effects of receiving the outdated requests."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:104
msgid "Sensor data"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:106
msgid "For sensor data, in most cases it’s more important to receive readings in a timely fashion, rather than ensuring that all of them arrive. That is, developers want the latest samples as soon as they are captured, at the expense of maybe losing some. For that reason the sensor data profile uses best effort reliability and a smaller queue size."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:112
msgid "Parameters in ROS 2 are based on services, and as such have a similar profile. The difference is that parameters use a much larger queue depth so that requests do not get lost when, for example, the parameter client is unable to reach the parameter service server."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:115
msgid "System default"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:117
msgid "This uses the RMW implementation’s default values for all of the policies. Different RMW implementations may have different defaults."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:120
msgid "`Click here <https://github.com/ros2/rmw/blob/humble/rmw/include/rmw/qos_profiles.h>`__ for the specific policies in use for the above profiles. The settings in these profiles are subject to further tweaks, based on the feedback from the community."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:125
msgid "QoS compatibilities"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:127
msgid "**Note:** This section refers to publishers and subscriptions but the content applies to service servers and clients in the same manner."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:129
msgid "QoS profiles may be configured for publishers and subscriptions independently. A connection between a publisher and a subscription is only made if the pair has compatible QoS profiles."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:132
msgid "QoS profile compatibility is determined based on a \"Request vs Offered\" model. Subscriptions *request* a QoS profile that is the \"minimum quality\" that it is willing to accept, and publishers *offer* a QoS profile that is the \"maximum quality\" that it is able to provide. Connections are only made if every policy of the requested QoS profile is not more stringent than that of the offered QoS profile. Multiple subscriptions can be connected to a single publisher simultaneously even if their requested QoS profiles are different. The compatibility between a publisher and a subscription is unaffected by the presence of other publishers and subscriptions."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:138
msgid "The following tables show the compatibility of the different policy settings and the result:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:140
msgid "*Compatibility of reliability QoS policies:*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:145 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:166 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:197 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:224 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:247
msgid "Publisher"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:146 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:167 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:198 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:225 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:248
msgid "Subscription"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:147 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:168 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:199 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:226 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:249
msgid "Compatible"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:148 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:149 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:151 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:155
msgid "Best effort"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:150 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:156 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:159 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:172 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:180 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:184 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:202 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:208 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:211 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:214 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:229 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:235 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:238 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:252 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:258 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:261 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:264
msgid "Yes"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:152 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:154 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:157 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:158
msgid "Reliable"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:153 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:176 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:205 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:217 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:232 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:255 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:267
msgid "No"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:161
msgid "*Compatibility of durability QoS policies:*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:169
msgid "Result"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:170 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:171 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:174 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:179
msgid "Volatile"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:173 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:181
msgid "New messages only"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:175 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:178 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:182 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:183
msgid "Transient local"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:177
msgid "No communication"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:185
msgid "New and old messages"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:187
msgid "To achieve a \"latched\" topic that is visible to late subscribers, both the publisher and subscriber must agree to use 'Transient Local'."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:190
msgid "*Compatibility of deadline QoS policies:*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:192 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:242
msgid "Assume *x* and *y* are arbitrary valid duration values."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:200 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:201 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:203 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:207 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:250 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:251 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:253 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:257
msgid "Default"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:204 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:206 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:209 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:210 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:212 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:215 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:254 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:256 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:259 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:260 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:262 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:265
msgid "*x*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:213 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:263
msgid "*y* (where *y* > *x*)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:216 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:266
msgid "*y* (where *y* < *x*)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:219
msgid "*Compatibility of liveliness QoS policies:*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:227 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:228 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:230 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:234
msgid "Automatic"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:231 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:233 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:236 ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:237
msgid "Manual by topic"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:240
msgid "*Compatibility of lease duration QoS policies:*"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:269
msgid "In order for a connection to be made, all of the policies that affect compatibility must be compatible. For example, even if a requested and offered QoS profile pair has compatible reliability QoS policies, but they have incompatible durability QoS policies, a connection will still not be made."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:272
msgid "When connections are not made, no messages will be passed between the publisher and subscription. There are mechanisms to detect this situation, which will be covered in a later section."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:278
msgid "Historically in ROS 1, any publisher and subscriber with the same message type on the same topic would be connected. The possibility of incompatible requested and offered QoS profiles is something new to be aware of when using ROS 2."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:283
msgid "QoS events"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:285
msgid "Some QoS policies have possible events related to them. Developers may provide each publisher and subscription with callback functions that are triggered by these QoS events and handle them in a way they see fit, similar to how messages received on a topic are handled."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:288
msgid "Developers may subscribe to the following QoS events that are associated with a publisher:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:290
msgid "Offered deadline missed"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:292
msgid "The publisher has not published a message within the expected duration that was set out by the deadline QoS policy."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:294
msgid "Liveliness lost"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:296
msgid "The publisher has failed to indicate its liveliness within the lease duration."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:298
msgid "Offered incompatible QoS"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:300
msgid "The publisher has encountered a subscription on the same topic that is requesting a QoS profile that the offered QoS profile cannot satisfy, resulting in no connection between the publisher and that subscription."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:302
msgid "Developers may subscribe to the following QoS events that are associated with a subscription:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:304
msgid "Requested deadline missed"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:306
msgid "The subscription has not received a message within the expected duration that was set out by the deadline QoS policy."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:308
msgid "Liveliness changed"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:310
msgid "The subscription has noticed that one or more publishers on the subscribed topic has failed to indicate their liveliness within the lease duration."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:312
msgid "Requested incompatible QoS"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Quality-of-Service-Settings.rst:314
msgid "The subscription has encountered a publisher on the same topic that is offering a QoS profile that does not satisfy the requested QoS profile, resulting in no connection between the subscription and that publisher."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:8
msgid "Overview and usage of RQt"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:16
msgid "RQt is a graphical user interface framework that implements various tools and interfaces in the form of plugins. One can run all the existing GUI tools as dockable windows within RQt. The tools can still run in a traditional standalone method, but RQt makes it easier to manage all the various windows in a single screen layout."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:20
msgid "You can run any RQt tools/plugins easily by:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:26
msgid "This GUI allows you to choose any available plugins on your system. You can also run plugins in standalone windows. For example, RQt Python Console:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:34
msgid "Users can create their own plugins for RQt with either ``Python`` or ``C++``. To see what RQt plugins are available for your system, run:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:41
msgid "And then look for packages that start with ``rqt_``."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:44
msgid "System setup"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:47
msgid "Installing From Debian"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:55
msgid "Building From Source"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:57
msgid "See :doc:`Building RQt from Source <../../How-To-Guides/RQt-Source-Install>`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:60
msgid "RQt Components Structure"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:62
msgid "RQt consists of two metapackages:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:64
msgid "*rqt* - core infrastucture modules."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:65
msgid "*rqt_common_plugins* - Commonly useful debugging tools."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:68
msgid "Advantage of RQt framework"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:70
msgid "Compared to building your own GUIs from scratch:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:72
msgid "Standardized common procedures for GUI (start-shutdown hook, restore previous states)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:73
msgid "Multiple widgets can be docked in a single window."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:74
msgid "Easily turn your existing Qt widgets into RQt plugins."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:75
msgid "Expect support at `Robotics Stack Exchange <https://robotics.stackexchange.com/>`__ (ROS community website for the questions)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:77
msgid "From system architecture's perspective:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:79
msgid "Support multi-platform (basically wherever `QT <http://qt-project.org/>`__ and ROS run) and multi-language (``Python``, ``C++``)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:80
msgid "Manageable lifecycle: RQt plugins using a common API makes maintainance & reuse easier."
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:84
msgid "Further Reading"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:86
msgid "ROS 2 Discourse `announcement of porting to ROS 2 <https://discourse.ros.org/t/rqt-in-ros2/6428>`__)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:87
msgid "`RQt for ROS 1 documentation <https://wiki.ros.org/rqt>`__"
msgstr ""

#: ../../source/Concepts/Intermediate/About-RQt.rst:88
msgid "Brief overview of RQt (from `a Willow Garage intern blog post <http://web.archive.org/web/20130518142837/http://www.willowgarage.com/blog/2012/10/21/ros-gui>`__)"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:6
msgid "ROS 2 Security"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:14
msgid "ROS 2 includes the ability to secure communications among nodes within the ROS 2 computational graph. Similar to discovery, security happens through the underlying ROS 2 middleware (provided it has support for the corresponding security plugins). No additional software installation is needed to enable security; however, the middleware requires configuration files for each ROS graph participant. These files enable encryption and authentication, and define policies both for individual nodes and for the overall ROS graph. ROS 2 also adds a master \"on/off\" switch to control security behavior."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:20
msgid "ROS utilities can create the authoritative `trust anchor <https://en.wikipedia.org/wiki/Trust_anchor>`_ for a ROS application, or an external certificate authority can be used."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:22
msgid "Built-in ROS 2 security features enable control over communications throughout the ROS graph. This not only allows for encrypting data in transit between ROS domain participants, but also enables authentication of participants sending data, ensures the integrity of data being sent, and enables domain-wide access controls."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:25
msgid "ROS 2 security services are provided by the underlying `Data Distribution Service (DDS) <https://www.omg.org/spec/DDS/>`_ which is used for communications between nodes. DDS vendors provide open source and commercial DDS implementations that work with ROS. However, in order to create a specification-compliant implementation of DDS, all vendors must include security plugins as outlined in the `DDS Security Specification <https://www.omg.org/spec/DDS-SECURITY/About-DDS-SECURITY/>`_. ROS security features take advantage of these DDS security plugins to provide policy-based encryption, authentication and access control. DDS and ROS security is enabled through predefined configuration files and environment variables."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:33
msgid "The Security Enclave"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:35
msgid "A security enclave encapsulates a single policy for protecting ROS communications. The enclave may set policy for multiple nodes, for an entire ROS graph, or any combination of protected ROS processes and devices. Security enclaves can be flexibly mapped to processes, users, or devices at deployment. Adjusting this default behavior becomes important for optimizing communications and for complex systems. See the ROS 2 Security Enclaves `design document <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ for additional details."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:43
msgid "Security Files"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:45
msgid "A `ROS 2 security enclave <https://design.ros2.org/articles/ros2_security_enclaves.html>`_ is established with six files as outlined by the DDS specification. Three of these files define an enclave's identity, while three other files define the permissions to be granted to the enclave. All six files reside in a single directory, and nodes launched without a qualified enclave path use files in the default root level enclave."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:50
msgid "Enclave Identity"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:52
msgid "The Identity Certificate Authority file ``identity_ca.cert.pem`` acts as the trust anchor used to identify participants. Each enclave also holds its unique identifying certificate in the file ``cert.pem``, and the associated private key in the file ``key.pem``. Because the ``cert.pem`` certificate has been signed by identity certificate, when a participant presents this certificate to other domain members, they are able to validate the participant's identity using their own copy of the identity certificate. This valid certificate exchange allows the enclave to securely establish trusted communications with other participants. The enclave does not not share the ``key.pem`` private key, but only uses it for decryption and message signing."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:59
msgid "Enclave Permissions"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:61
msgid "The Permissions Certificate Authority file ``permissions_ca.cert.pem`` serves as the trust anchor to grant permissions to security enclaves. This certificate is used to create the signed file ``governance.p7s``, an XML document which defines domain-wide protection policies. Similarly the XML file ``permissions.p7s`` outlines permissions of this particular enclave and has been signed by the Permissions CA. Domain members use a copy of the permissions CA to validate these signed files and grant the requested access."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:66
msgid "Although these two certificate authorities enable separate workflows for identity and permissions, often the same certificate serves as both the identity and the permissions authority."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:69
msgid "Private Keys"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:71
msgid "The identity and permissions certificates also have associated private key files. Add new enclaves to the domain by signing their Certificate Signing Request (CSR) with the identity certificate's private key. Similarly, grant permissions for a new enclave by signing a permissions XML document with the permission certificate's private key."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:77
msgid "Security Environment Variables"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:79
msgid "The environment variable ``ROS_SECURITY_ENABLE`` acts as the enclave's master \"on/off\" switch for ROS 2 security features. Security has been turned off by default, so security features will not be enabled even when the proper security files are present. In order to enable ROS 2 security, set this environment variable to ``true`` (case sensitive)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:83
msgid "Once security has been enabled, the environment variable ``ROS_SECURITY_STRATEGY`` defines how domain participants handle problems when launching participants. Security features depend on certificates and properly signed configuration files, yet by default, an improperly configured participant will still launch successfully but without security features. In order to enforce strict compliance with security settings and fail to launch non-compliant enclaves, set this environment variable to ``Enforce`` (case sensitive)."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:87
msgid "Additional security-related environment variables can be found in the `ROS 2 DDS-Security Integration design document <https://design.ros2.org/articles/ros2_dds_security.html>`_. These variables generally assist ROS in managing enclaves and locating the security files."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:92
msgid "Learn More"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Security.rst:94
msgid "For more information and hands-on exercises enabling ROS 2 communications security, see the :doc:`../../Tutorials/Advanced/Security/Introducing-ros2-security`."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:6
msgid "Tf2"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:14
msgid "tf2 is the transform library, which lets the user keep track of multiple coordinate frames over time. tf2 maintains the relationship between coordinate frames in a tree structure buffered in time and lets the user transform points, vectors, etc. between any two coordinate frames at any desired point in time."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:20
msgid "Properties of tf2"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:22
msgid "A robotic system typically has many 3D coordinate frames that change over time, such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:25
msgid "Where was the head frame relative to the world frame 5 seconds ago?"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:26
msgid "What is the pose of the object in my gripper relative to my base?"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:27
msgid "What is the current pose of the base frame in the map frame?"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:29
msgid "tf2 can operate in a distributed system. This means all the information about the coordinate frames of a robot is available to all ROS 2 components on any computer in the system. tf2 can have every component in your distributed system build its own transform information database or have a central node that gathers and stores all transform information."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:34
msgid "Tutorials"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:36
msgid "We created a set of :doc:`tutorials <../../Tutorials/Intermediate/Tf2/Tf2-Main>` that walks you through using tf2, step by step. You can get started on the :doc:`introduction to tf2 <../../Tutorials/Intermediate/Tf2/Introduction-To-Tf2>` tutorial. For a complete list of all tf2 and tf2-related tutorials check out the :doc:`tutorials <../../Tutorials/Intermediate/Tf2/Tf2-Main>` page."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:40
msgid "There are essentially two main tasks that any user would use tf2 for, listening for transforms and broadcasting transforms."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:42
msgid "If you want to use tf2 to transform between coordinate frames, your nodes will need to listen for transforms. What you will do is receive and buffer all coordinate frames that are broadcasted in the system, and query for specific transforms between frames. Check out the \"Writing a listener\" tutorial :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Listener-Cpp>` to learn more."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:46
msgid "To extend the capabilities of a robot, you will need to start broadcasting transforms. Broadcasting transforms means to send out the relative pose of coordinate frames to the rest of the system. A system can have many broadcasters that each provide information about a different part of the robot. Check out the \"Writing a broadcaster\" tutorial :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Broadcaster-Cpp>` to learn more."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:51
msgid "In addition to that, tf2 can broadcast static transforms that do not change over time. This mainly saves storage and lookup time, but also reduces the publishing overhead. You should note that static transforms are published once and assumed to not change, so no history is stored. If you want to define static transforms in your tf2 tree, take a look at the \"Writing a static broadcaster\" :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Writing-A-Tf2-Static-Broadcaster-Cpp>` tutorial."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:56
msgid "You can also learn how to add fixed and dynamic frames to your tf2 tree in the \"Adding a frame\" :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Adding-A-Frame-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Adding-A-Frame-Cpp>` tutorial."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:58
msgid "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Learning-About-Tf2-And-Time-Cpp>` teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time :doc:`(Python) <../../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Py>` :doc:`(C++) <../../Tutorials/Intermediate/Tf2/Time-Travel-With-Tf2-Cpp>` teaches the principles of time traveling with tf2."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:63
msgid "Paper"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Tf2.rst:65
msgid "There is a paper on tf2 presented at TePRA 2013: `tf: The transform library <https://ieeexplore.ieee.org/abstract/document/6556373>`_."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:7
msgid "Topic statistics"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:15
msgid "ROS 2 provides integrated measurement of statistics for messages received by any subscription. Allowing a user to collect subscription statistics enables them to characterize the performance of their system or aid in diagnosis of any present issues."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:18
msgid "The measurements provided are the received message age and received message period. For each measurement the statistics provided are the average, maximum, minimum, standard deviation, and sample count. These statistics are calculated in a moving window."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:23
msgid "How statistics are calculated"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:25
msgid "Each statistic set is calculated in constant time and constant memory by using the utilities implemented in the `libstatistics_collector <https://github.com/ros-tooling/libstatistics_collector>`__ package. When a new message is received by a subscription, this is a new sample for calculation in the current measurement window. The average calculated is simply a `moving average <https://en.wikipedia.org/wiki/Moving_average>`__. The maximum, minimum, and sample count are updated upon receipt of each new sample, whereas the standard deviation is calculated using `Welford's online algorithm <https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm>`__."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:31
msgid "Types of statistics calculated"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:33
msgid "Received message period"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:35 ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:40
msgid "Units: milliseconds"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:36
msgid "Uses the system clock to measure the period between received messages"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:38
msgid "Received message age"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:41
msgid "Requires a message to have a timestamp populated in the header field in order to calculate the age of the message as sent from a publisher"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:44
msgid "Behavior"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:46
msgid "By default, Topic Statistics measurements are not enabled. After enabling this feature for a specific node via the subscription configuration options, both received message age and received message period measurements are enabled for that specific subscription."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:49
msgid "The data is published as a `statistics_msg/msg/MetricsMessage <https://github.com/ros2/rcl_interfaces/blob/humble/statistics_msgs/msg/MetricsMessage.msg>`__ at a configurable period (default 1 second) to a configurable topic (default ``/statistics``). Note that the publishing period also serves as the sample collection window period."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:53
msgid "Since received message period requires a message timestamp in a header field, empty data is published. That is, all statistics values are NaN if no timestamp is found. Publishing NaN values instead of not publishing at all avoids the absence of a signal problem and is meant to explicitly show that a measurement could not be made."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:57
msgid "The first sample of each window for the received message period statistic does not yield a measurement. This is because calculating this statistic requires knowing the time the previous message arrived, so subsequent samples in the window yield measurements."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:63
msgid "Similar to ROS 1 `Topic Statistics <https://wiki.ros.org/Topics#Topic_statistics>`__, both message age and message period are calculated, albeit from the subscription side. Other ROS 1 metrics, e.g., the number of dropped messages or traffic volume, are currently not provided."
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:67
msgid "Support"
msgstr ""

#: ../../source/Concepts/Intermediate/About-Topic-Statistics.rst:69
msgid "This feature is currently supported in ROS 2 Foxy for C++ only (rclcpp). Future work and improvements, such as Python support, can be found `here <https://github.com/ros2/ros2/issues/917>`__."
msgstr ""

